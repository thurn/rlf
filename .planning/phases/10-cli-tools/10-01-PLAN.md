---
phase: 10-cli-tools
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/rlf-cli/Cargo.toml
  - crates/rlf-cli/src/main.rs
  - crates/rlf-cli/src/commands/mod.rs
  - crates/rlf-cli/src/commands/check.rs
  - crates/rlf-cli/src/output/mod.rs
  - crates/rlf-cli/src/output/diagnostic.rs
  - Cargo.toml
autonomous: true

must_haves:
  truths:
    - "User can run `rlf check file.rlf` and see OK or syntax errors"
    - "Errors show file:line:column location with source context"
    - "Exit code is 0 on success, non-zero on failure"
    - "`--strict` mode validates against source file"
  artifacts:
    - path: "crates/rlf-cli/Cargo.toml"
      provides: "CLI crate with clap, miette, owo-colors dependencies"
      contains: "[dependencies]"
    - path: "crates/rlf-cli/src/main.rs"
      provides: "CLI entry point with subcommand dispatch"
      contains: "Commands::Check"
    - path: "crates/rlf-cli/src/commands/check.rs"
      provides: "Check command implementation"
      contains: "pub fn run_check"
    - path: "crates/rlf-cli/src/output/diagnostic.rs"
      provides: "Miette diagnostic wrapper for ParseError"
      contains: "RlfDiagnostic"
  key_links:
    - from: "crates/rlf-cli/src/commands/check.rs"
      to: "rlf::parser::parse_file"
      via: "parse_file call"
      pattern: "parse_file"
    - from: "crates/rlf-cli/src/commands/check.rs"
      to: "crates/rlf-cli/src/output/diagnostic.rs"
      via: "RlfDiagnostic::from_parse_error"
      pattern: "RlfDiagnostic::from_parse_error"
---

<objective>
Create the rlf-cli crate with the `rlf check` subcommand for syntax validation.

Purpose: Provide developers with a CLI tool to validate .rlf file syntax, report errors with source context, and integrate with CI pipelines via exit codes.

Output: Working `rlf check` command that validates files and shows compiler-quality diagnostics.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-cli-tools/10-CONTEXT.md
@.planning/phases/10-cli-tools/10-RESEARCH.md
@crates/rlf/src/lib.rs
@crates/rlf/src/parser/mod.rs
@crates/rlf/src/parser/error.rs
@crates/rlf/src/parser/ast.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rlf-cli crate with clap subcommand structure</name>
  <files>
    crates/rlf-cli/Cargo.toml
    crates/rlf-cli/src/main.rs
    crates/rlf-cli/src/commands/mod.rs
    Cargo.toml
  </files>
  <action>
Create the rlf-cli binary crate in crates/rlf-cli/:

1. Create Cargo.toml with dependencies from RESEARCH.md:
   - clap = { version = "4", features = ["derive", "color", "env"] }
   - miette = { version = "7", features = ["fancy"] }
   - owo-colors = { version = "4", features = ["supports-colors"] }
   - serde = { version = "1", features = ["derive"] }
   - serde_json = "1"
   - exitcode = "1"
   - thiserror = "2"
   - rlf = { path = "../rlf" }

2. Set [[bin]] name = "rlf" in Cargo.toml

3. Create main.rs with:
   - Cli struct with clap derive (from RESEARCH.md pattern)
   - ColorWhen enum (Auto, Always, Never) with global --color flag
   - --verbose global flag
   - Commands enum with Check variant
   - setup_colors() function using owo_colors::set_override
   - miette::set_hook() for terminal_links, unicode, context_lines(2)
   - Main dispatch to commands

4. Create commands/mod.rs with Commands enum re-export

5. Add rlf-cli to workspace members in root Cargo.toml
  </action>
  <verify>
`cargo check -p rlf-cli` compiles without errors
`cargo run -p rlf-cli -- --help` shows usage with `check` subcommand listed
  </verify>
  <done>
Binary compiles and shows help with check subcommand. Exit codes work via exitcode crate.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement check command with miette diagnostics</name>
  <files>
    crates/rlf-cli/src/commands/check.rs
    crates/rlf-cli/src/commands/mod.rs
    crates/rlf-cli/src/output/mod.rs
    crates/rlf-cli/src/output/diagnostic.rs
  </files>
  <action>
1. Create output/mod.rs and output/diagnostic.rs:
   - RlfDiagnostic struct implementing miette::Diagnostic and thiserror::Error
   - Fields: src (NamedSource), span (SourceSpan), message (String), help (Option)
   - from_parse_error() constructor that converts ParseError line:column to byte offset
   - Byte offset calculation: sum of (line_length + 1) for lines before error line, plus column

2. Create commands/check.rs:
   - CheckArgs struct with clap::Args derive
   - files: Vec<PathBuf> (required, multiple files supported)
   - --json flag for JSON output
   - --strict Option<PathBuf> for source file validation

3. Implement run_check(args: CheckArgs) -> miette::Result<i32>:
   - Iterate files, read each with std::fs::read_to_string
   - Handle missing file with miette::miette! and exitcode::NOINPUT
   - Call rlf::parser::parse_file(&content)
   - On success: print "file.rlf: OK" (not in JSON mode)
   - On error: create RlfDiagnostic and print via miette::Report
   - Track total_errors, limit to ~10 per file with "and N more" message
   - JSON mode: collect FileResult structs, serialize at end

4. Implement --strict mode:
   - Parse source file to get phrase names
   - Parse target file(s) and check all source phrases exist
   - Report missing phrases as errors

5. Return exit codes:
   - exitcode::OK (0) if all files valid
   - exitcode::DATAERR (65) if syntax errors found
   - exitcode::NOINPUT (66) if file not found

6. Update commands/mod.rs to include check module and update main.rs to call run_check
  </action>
  <verify>
Create test.rlf with valid syntax: `cargo run -p rlf-cli -- check test.rlf` shows OK
Create bad.rlf with invalid syntax: `cargo run -p rlf-cli -- check bad.rlf` shows error with line/column
`cargo run -p rlf-cli -- check missing.rlf` exits with non-zero code
`cargo run -p rlf-cli -- check bad.rlf --json` outputs JSON
`echo $?` after each command shows correct exit code
  </verify>
  <done>
Check command validates files, shows compiler-quality diagnostics with source context, supports --json and --strict, uses correct exit codes.
  </done>
</task>

</tasks>

<verification>
Run the complete test sequence:
```bash
# Create test files
echo 'greeting = "Hello";' > /tmp/good.rlf
echo 'broken = ' > /tmp/bad.rlf

# Test valid file
cargo run -p rlf-cli -- check /tmp/good.rlf
# Expected: good.rlf: OK

# Test invalid file - should show error with line:column and source context
cargo run -p rlf-cli -- check /tmp/bad.rlf

# Test JSON output
cargo run -p rlf-cli -- check /tmp/bad.rlf --json

# Test multiple files
cargo run -p rlf-cli -- check /tmp/good.rlf /tmp/bad.rlf

# Test missing file
cargo run -p rlf-cli -- check /tmp/nonexistent.rlf; echo "Exit: $?"

# Test help
cargo run -p rlf-cli -- check --help
```
</verification>

<success_criteria>
- CLI-01: `rlf check` parses and validates .rlf file syntax
- CLI-02: Errors show file:line:column with source context via miette
- CLI-03: Exit 0 on success, non-zero (65 DATAERR) on failure
- CLI-04: `--strict` mode validates translations against source file
- Colors auto-detect TTY, respect --color flag
- JSON output works without color codes
</success_criteria>

<output>
After completion, create `.planning/phases/10-cli-tools/10-01-SUMMARY.md`
</output>
