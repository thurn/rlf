---
phase: 09-asian-language-transforms
plan: 03
type: execute
wave: 3
depends_on: ["09-02"]
files_modified:
  - crates/rlf/src/interpreter/transforms.rs
  - crates/rlf/tests/interpreter_transforms.rs
autonomous: true

must_haves:
  truths:
    - "Korean @particle selects 가/이 for subject based on final sound"
    - "Korean @particle selects 를/을 for object based on final sound"
    - "Korean @particle selects 는/은 for topic based on final sound"
    - "Turkish @inflect applies plural suffix with vowel harmony (-ler/-lar)"
    - "Turkish @inflect applies dative suffix with vowel harmony (-e/-a)"
    - "Turkish @inflect chains multiple suffixes correctly (e.g., evlere)"
  artifacts:
    - path: "crates/rlf/src/interpreter/transforms.rs"
      provides: "KoreanParticle, TurkishInflect transforms"
      contains: "KoreanParticle"
  key_links:
    - from: "crates/rlf/src/interpreter/transforms.rs"
      to: "hangeul::ends_with_jongseong"
      via: "import and function call"
      pattern: "ends_with_jongseong"
---

<objective>
Implement Korean @particle transform with phonology-based selection and Turkish @inflect with vowel harmony suffix chains.

Purpose: Enable Korean context-sensitive particles (가/이, 를/을, 는/은) and Turkish agglutinative morphology with vowel harmony.
Output: Two algorithmic transforms with comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-asian-language-transforms/09-RESEARCH.md
@.planning/phases/09-asian-language-transforms/09-02-SUMMARY.md
@crates/rlf/src/interpreter/transforms.rs
@docs/APPENDIX_STDLIB.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Korean @particle transform</name>
  <files>crates/rlf/src/interpreter/transforms.rs</files>
  <action>
Add import at top of file:
```rust
use hangeul::ends_with_jongseong;
```

Add TransformKind::KoreanParticle variant.

Create KoreanParticle enum for particle types:
```rust
#[derive(Clone, Copy)]
enum KoreanParticle {
    Subject,  // 가/이
    Object,   // 를/을
    Topic,    // 는/은
}
```

Implement korean_particle_transform:
1. Parse context to determine particle type:
   - "subj" -> Subject
   - "obj" -> Object
   - "topic" -> Topic
   - Default to Subject if unknown
2. Get text from value.to_string()
3. Use hangeul::ends_with_jongseong(&text) to check if text ends in consonant (has jongseong/batchim)
4. Select particle based on (particle_type, has_consonant):
   - (Subject, false) -> "가" (vowel-final)
   - (Subject, true) -> "이" (consonant-final)
   - (Object, false) -> "를"
   - (Object, true) -> "을"
   - (Topic, false) -> "는"
   - (Topic, true) -> "은"
5. Return just the particle string (NOT prepended to text - template handles concatenation)

Per RESEARCH.md pitfall: For non-Hangul text, ends_with_jongseong returns false, so treat as vowel-ending.

Wire in TransformKind::execute() and register in TransformRegistry::get():
- ("ko", "particle") => Some(TransformKind::KoreanParticle)
  </action>
  <verify>Run `just check` to verify code compiles</verify>
  <done>Korean @particle transform implemented and registered</done>
</task>

<task type="auto">
  <name>Task 2: Implement Turkish @inflect transform with vowel harmony</name>
  <files>crates/rlf/src/interpreter/transforms.rs</files>
  <action>
Add TransformKind::TurkishInflect variant.

Create TurkishHarmony enum:
```rust
#[derive(Clone, Copy)]
enum TurkishHarmony {
    Front,  // e, i, o, u (front vowels)
    Back,   // a, i, o, u (back vowels)
}
```

Create TurkishSuffix enum for supported suffixes:
```rust
#[derive(Clone, Copy)]
enum TurkishSuffix {
    Plural,      // -ler/-lar (2-way)
    Nominative,  // (no suffix)
    Accusative,  // -i/-i/-u/-u (4-way) - simplified to 2-way for this version
    Dative,      // -e/-a (2-way)
    Genitive,    // -in/-in (simplified)
    Locative,    // -de/-da (2-way, ignoring voicing)
    Ablative,    // -den/-dan (2-way, ignoring voicing)
    Poss1Sg,     // -im/-im/-um/-um (4-way, simplified)
    Poss2Sg,     // -in/-in
    Poss3Sg,     // -i/-i
}
```

Implement helper to parse suffix chain from context:
```rust
fn parse_turkish_suffix_chain(context: Option<&Value>) -> Vec<TurkishSuffix> {
    // Parse dot-separated suffix names: "dat.pl" -> [Dative, Plural]
    // Order in context: left-to-right application order
}
```

Implement 2-way harmony suffix selection:
```rust
fn turkish_suffix_2way(suffix: TurkishSuffix, harmony: TurkishHarmony) -> &'static str {
    match (suffix, harmony) {
        (Plural, Front) => "ler",
        (Plural, Back) => "lar",
        (Dative, Front) => "e",
        (Dative, Back) => "a",
        (Locative, Front) => "de",
        (Locative, Back) => "da",
        (Ablative, Front) => "den",
        (Ablative, Back) => "dan",
        // ... etc
    }
}
```

Implement turkish_inflect_transform:
1. Get initial harmony from :front or :back tag on value
2. Return MissingTag error if neither tag present
3. Parse suffix chain from context
4. Apply each suffix left-to-right, appending to result string
5. For simplicity, harmony persists through chain (last suffix vowel determines next)
6. Return inflected word

Wire in TransformKind::execute() and register:
- ("tr", "inflect") => Some(TransformKind::TurkishInflect)
  </action>
  <verify>Run `just check` to verify code compiles</verify>
  <done>Turkish @inflect transform implemented and registered</done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive tests for Korean and Turkish transforms</name>
  <files>crates/rlf/tests/interpreter_transforms.rs</files>
  <action>
Add test module for Korean @particle with tests:

Korean @particle tests - vowel-final words:
- test_korean_particle_subj_vowel: "사과" (apple, ends in 과) + :subj -> "가"
- test_korean_particle_obj_vowel: "사과" + :obj -> "를"
- test_korean_particle_topic_vowel: "사과" + :topic -> "는"

Korean @particle tests - consonant-final words:
- test_korean_particle_subj_consonant: "책" (book, ends in 책) + :subj -> "이"
- test_korean_particle_obj_consonant: "책" + :obj -> "을"
- test_korean_particle_topic_consonant: "책" + :topic -> "은"

Korean @particle tests - edge cases:
- test_korean_particle_english_text: "card" (non-Hangul) + :subj -> "가" (treated as vowel)
- test_korean_particle_default: no context -> defaults to Subject particle

Add test module for Turkish @inflect with tests:

Turkish @inflect tests - basic suffixes:
- test_turkish_inflect_plural_back: :back "ev" (house) + :pl -> "evler"
- test_turkish_inflect_plural_front: :front "goz" (eye, actually "göz") + :pl -> "gozler"
- test_turkish_inflect_dative_back: :back "ev" + :dat -> "eve"
- test_turkish_inflect_dative_front: :front "goz" + :dat -> "goze"

Turkish @inflect tests - suffix chains:
- test_turkish_inflect_pl_dat: :back "ev" + :pl.dat -> "evlere"
- test_turkish_inflect_abl: :back "ev" + :abl -> "evden"

Turkish @inflect tests - error cases:
- test_turkish_inflect_missing_harmony: phrase without :front/:back returns MissingTag error

Use established test patterns from prior plans.
  </action>
  <verify>Run `just review` to verify all tests pass and code quality checks pass</verify>
  <done>All Korean and Turkish transform tests passing, just review clean</done>
</task>

</tasks>

<verification>
1. `just check` passes (code compiles)
2. `just test` passes (all existing + new tests)
3. `just review` passes (formatting, clippy, tests)
4. Korean @particle:subj on "사과" returns "가" (vowel-final)
5. Korean @particle:subj on "책" returns "이" (consonant-final)
6. Korean @particle:obj on "사과" returns "를"
7. Korean @particle:topic on "책" returns "은"
8. Turkish @inflect:pl on :back "ev" returns "evler"
9. Turkish @inflect:dat on :front "goz" returns "goze"
10. Turkish @inflect:pl.dat on :back "ev" returns "evlere"
11. Both transforms return MissingTag error when required tags missing
</verification>

<success_criteria>
- Korean @particle transform correctly selects particles based on final sound
- Turkish @inflect transform applies suffixes with vowel harmony
- Suffix chaining works for Turkish (pl.dat produces correct result)
- All tests pass including new Korean and Turkish tests
- just review passes clean
</success_criteria>

<output>
After completion, create `.planning/phases/09-asian-language-transforms/09-03-SUMMARY.md`
</output>
