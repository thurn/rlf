---
phase: 05-macro-code-generation
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - crates/rlf-macros/src/codegen.rs
  - crates/rlf-macros/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Each phrase generates a Rust function with the same name"
    - "Functions with parameters accept impl Into<Value> for each parameter"
    - "Functions return Phrase type"
    - "Parameterless phrases generate functions taking only &Locale"
    - "SOURCE_PHRASES const embeds all phrase definitions"
    - "register_source_phrases() function loads phrases into locale"
    - "phrase_ids module contains PhraseId constants in SCREAMING_CASE"
  artifacts:
    - path: "crates/rlf-macros/src/codegen.rs"
      provides: "Code generation logic"
      contains: "fn codegen"
  key_links:
    - from: "crates/rlf-macros/src/lib.rs"
      to: "crates/rlf-macros/src/codegen.rs"
      via: "codegen() call after validation"
      pattern: "codegen\\("
---

<objective>
Implement code generation for the rlf! macro.

Purpose: Transform validated MacroInput into Rust code that provides typed functions, PhraseId constants, and phrase registration. This is the final stage of the parse -> validate -> codegen pipeline.

Output: A codegen() function that produces TokenStream containing all generated Rust code.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-macro-code-generation/05-CONTEXT.md
@.planning/phases/05-macro-code-generation/05-RESEARCH.md
@.planning/phases/05-macro-code-generation/05-01-SUMMARY.md
@docs/APPENDIX_RUST_INTEGRATION.md
@crates/rlf/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement phrase function generation</name>
  <files>crates/rlf-macros/src/codegen.rs</files>
  <action>
Create codegen.rs with the main code generation logic:

Based on APPENDIX_RUST_INTEGRATION.md, generate:

1. **Phrase functions** (MACRO-02, MACRO-03, MACRO-04):
   - Parameterless: `pub fn name(locale: &::rlf::Locale) -> ::rlf::Phrase`
   - With params: `pub fn name(locale: &::rlf::Locale, p1: impl Into<::rlf::Value>, ...) -> ::rlf::Phrase`

2. **Doc comments**: `/// Returns the "name" phrase.`

```rust
use proc_macro2::TokenStream;
use quote::{quote, format_ident};
use crate::input::*;

/// Main code generation entry point.
pub fn codegen(input: &MacroInput) -> TokenStream {
    let functions = generate_functions(input);
    let source_phrases = generate_source_phrases(input);
    let phrase_ids_module = generate_phrase_ids_module(input);

    quote! {
        #functions
        #source_phrases
        #phrase_ids_module
    }
}

fn generate_functions(input: &MacroInput) -> TokenStream {
    let functions: Vec<TokenStream> = input.phrases.iter()
        .map(generate_function)
        .collect();

    quote! {
        #(#functions)*
    }
}

fn generate_function(phrase: &PhraseDefinition) -> TokenStream {
    let fn_name = format_ident!("{}", phrase.name.name);
    let phrase_name = &phrase.name.name;
    let doc = format!("Returns the \"{}\" phrase.", phrase_name);

    if phrase.parameters.is_empty() {
        // Parameterless phrase
        quote! {
            #[doc = #doc]
            pub fn #fn_name(locale: &::rlf::Locale) -> ::rlf::Phrase {
                locale.get_phrase(#phrase_name)
                    .expect(concat!("phrase '", #phrase_name, "' should exist"))
            }
        }
    } else {
        // Phrase with parameters
        let param_names: Vec<_> = phrase.parameters.iter()
            .map(|p| format_ident!("{}", p.name))
            .collect();

        let param_decls: Vec<TokenStream> = param_names.iter()
            .map(|name| quote! { #name: impl Into<::rlf::Value> })
            .collect();

        let param_conversions: Vec<TokenStream> = param_names.iter()
            .map(|name| quote! { #name.into() })
            .collect();

        quote! {
            #[doc = #doc]
            pub fn #fn_name(locale: &::rlf::Locale, #(#param_decls),*) -> ::rlf::Phrase {
                locale.call_phrase(#phrase_name, &[#(#param_conversions),*])
                    .expect(concat!("phrase '", #phrase_name, "' should exist"))
            }
        }
    }
}
```

Key points from CONTEXT.md decisions:
- Functions panic on error (not Result) - programming errors caught during development
- Locale is always first parameter
- Parameters use `impl Into<Value>` for ergonomic conversion
- Use fully qualified paths: `::rlf::Locale`, `::rlf::Phrase`, `::rlf::Value`
  </action>
  <verify>
`cargo build -p rlf-macros` compiles successfully.
`just review` passes all checks.
  </verify>
  <done>Phrase functions are generated with correct signatures and doc comments.</done>
</task>

<task type="auto">
  <name>Task 2: Implement SOURCE_PHRASES and register_source_phrases</name>
  <files>crates/rlf-macros/src/codegen.rs</files>
  <action>
Add generation of SOURCE_PHRASES constant and register_source_phrases function (MACRO-05, MACRO-06):

```rust
fn generate_source_phrases(input: &MacroInput) -> TokenStream {
    // Reconstruct phrase definitions as RLF source text
    // This is embedded verbatim for the interpreter to parse
    let source = reconstruct_source(input);

    quote! {
        /// Source language phrases embedded as data.
        /// Parsed by the interpreter at runtime.
        const SOURCE_PHRASES: &str = #source;

        /// Registers source language phrases with the locale.
        /// Call once at startup before using phrase functions.
        ///
        /// # Example
        ///
        /// ```ignore
        /// let mut locale = Locale::new();
        /// register_source_phrases(&mut locale);
        /// ```
        pub fn register_source_phrases(locale: &mut ::rlf::Locale) {
            locale.load_translations_str("en", SOURCE_PHRASES)
                .expect("source phrases should parse successfully");
        }
    }
}

/// Reconstruct RLF source from MacroInput.
/// This recreates the phrase definitions in RLF syntax for the interpreter.
fn reconstruct_source(input: &MacroInput) -> String {
    let mut lines = Vec::new();

    for phrase in &input.phrases {
        let mut line = String::new();

        // Tags
        for tag in &phrase.tags {
            line.push(':');
            line.push_str(&tag.name);
            line.push(' ');
        }

        // Name
        line.push_str(&phrase.name.name);

        // Parameters
        if !phrase.parameters.is_empty() {
            line.push('(');
            let params: Vec<_> = phrase.parameters.iter()
                .map(|p| p.name.as_str())
                .collect();
            line.push_str(&params.join(", "));
            line.push(')');
        }

        line.push_str(" = ");

        // Body
        match &phrase.body {
            PhraseBody::Simple(template) => {
                line.push('"');
                line.push_str(&reconstruct_template(template));
                line.push('"');
            }
            PhraseBody::Variants(variants) => {
                line.push_str("{ ");
                let variant_strs: Vec<String> = variants.iter()
                    .map(|v| {
                        let keys: Vec<_> = v.keys.iter()
                            .map(|k| k.name.as_str())
                            .collect();
                        format!("{}: \"{}\"", keys.join(", "), reconstruct_template(&v.template))
                    })
                    .collect();
                line.push_str(&variant_strs.join(", "));
                line.push_str(" }");
            }
        }

        line.push(';');
        lines.push(line);
    }

    lines.join("\n")
}

/// Reconstruct a template string from Template AST.
fn reconstruct_template(template: &Template) -> String {
    let mut result = String::new();

    for segment in &template.segments {
        match segment {
            Segment::Literal(text) => {
                // Escape special characters
                result.push_str(&text.replace('{', "{{").replace('}', "}}"));
            }
            Segment::Interpolation(interp) => {
                result.push('{');

                // Transforms
                for transform in &interp.transforms {
                    result.push('@');
                    result.push_str(&transform.name);
                    result.push(' ');
                }

                // Reference
                match &interp.reference {
                    Reference::Identifier(ident) => {
                        result.push_str(&ident.name);
                    }
                    Reference::Call { name, args } => {
                        result.push_str(&name.name);
                        result.push('(');
                        let arg_strs: Vec<String> = args.iter()
                            .map(|a| match a {
                                Reference::Identifier(i) => i.name.clone(),
                                Reference::Call { name, .. } => name.name.clone(),
                            })
                            .collect();
                        result.push_str(&arg_strs.join(", "));
                        result.push(')');
                    }
                }

                // Selectors
                for selector in &interp.selectors {
                    result.push(':');
                    result.push_str(&selector.name.name);
                }

                result.push('}');
            }
        }
    }

    result
}
```

Per CONTEXT.md: register_source_phrases hardcodes "en" as source language.
  </action>
  <verify>
`cargo build -p rlf-macros` compiles successfully.
`just review` passes all checks.
  </verify>
  <done>SOURCE_PHRASES const and register_source_phrases() function are generated.</done>
</task>

<task type="auto">
  <name>Task 3: Implement phrase_ids module generation</name>
  <files>crates/rlf-macros/src/codegen.rs</files>
  <action>
Add generation of the phrase_ids module with PhraseId constants (MACRO-07):

```rust
fn generate_phrase_ids_module(input: &MacroInput) -> TokenStream {
    let constants: Vec<TokenStream> = input.phrases.iter()
        .map(generate_phrase_id_constant)
        .collect();

    quote! {
        /// PhraseId constants for all defined phrases.
        ///
        /// Use these for serializable phrase references:
        /// ```ignore
        /// use crate::strings::phrase_ids;
        ///
        /// let id = phrase_ids::CARD;
        /// let phrase = id.resolve(&locale)?;
        /// ```
        pub mod phrase_ids {
            #(#constants)*
        }
    }
}

fn generate_phrase_id_constant(phrase: &PhraseDefinition) -> TokenStream {
    let phrase_name = &phrase.name.name;

    // Convert to SCREAMING_CASE per CONTEXT.md
    let const_name = format_ident!("{}", to_screaming_case(phrase_name));

    // Doc comment with parameter info if applicable
    let doc = if phrase.parameters.is_empty() {
        format!("ID for the \"{}\" phrase.", phrase_name)
    } else {
        let param_names: Vec<_> = phrase.parameters.iter()
            .map(|p| p.name.as_str())
            .collect();
        format!(
            "ID for the \"{}\" phrase. Call with {} argument(s) ({}).",
            phrase_name,
            phrase.parameters.len(),
            param_names.join(", ")
        )
    };

    quote! {
        #[doc = #doc]
        pub const #const_name: ::rlf::PhraseId = ::rlf::PhraseId::from_name(#phrase_name);
    }
}

/// Convert snake_case to SCREAMING_CASE.
fn to_screaming_case(s: &str) -> String {
    s.to_uppercase()
}
```

Per CONTEXT.md:
- PhraseId constants use SCREAMING_CASE: `phrase_ids::FIRE_ELEMENTAL`
- Use fully qualified path: `::rlf::PhraseId::from_name(...)`
  </action>
  <verify>
`cargo build -p rlf-macros` compiles successfully.
`just review` passes all checks.
  </verify>
  <done>phrase_ids module is generated with SCREAMING_CASE constants.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo build -p rlf-macros` compiles successfully
2. `just review` passes all checks
3. codegen() produces valid Rust tokens
4. Generated functions match APPENDIX_RUST_INTEGRATION.md examples
5. SOURCE_PHRASES embeds phrase definitions as a string constant
6. register_source_phrases() loads phrases with "en" language
7. phrase_ids module contains PhraseId constants in SCREAMING_CASE
</verification>

<success_criteria>
- Parameterless phrases generate functions taking only &Locale
- Phrases with params generate functions with impl Into<Value> params
- All functions return Phrase and use expect() for errors
- Doc comments are generated for all functions
- SOURCE_PHRASES const contains valid RLF source
- phrase_ids module has one constant per phrase
- All paths are fully qualified (::rlf::*)
</success_criteria>

<output>
After completion, create `.planning/phases/05-macro-code-generation/05-03-SUMMARY.md`
</output>
