---
phase: 05-macro-code-generation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/rlf-macros/Cargo.toml
  - crates/rlf-macros/src/lib.rs
  - crates/rlf-macros/src/parse.rs
  - crates/rlf-macros/src/input.rs
  - Cargo.toml
autonomous: true

must_haves:
  truths:
    - "rlf-macros crate compiles as a proc-macro crate"
    - "rlf! macro parses phrase definitions into internal AST"
    - "Spans are preserved for all identifiers (for error messages)"
  artifacts:
    - path: "crates/rlf-macros/Cargo.toml"
      provides: "Proc-macro crate configuration"
      contains: "proc-macro = true"
    - path: "crates/rlf-macros/src/lib.rs"
      provides: "Macro entry point"
      exports: ["rlf"]
    - path: "crates/rlf-macros/src/parse.rs"
      provides: "TokenStream parsing into MacroInput"
      contains: "impl Parse"
    - path: "crates/rlf-macros/src/input.rs"
      provides: "Internal AST types"
      contains: "struct MacroInput"
  key_links:
    - from: "crates/rlf-macros/src/lib.rs"
      to: "crates/rlf-macros/src/parse.rs"
      via: "parse_macro_input!"
      pattern: "parse_macro_input!"
---

<objective>
Create the rlf-macros proc-macro crate with TokenStream parsing for phrase definitions.

Purpose: Foundation for the rlf! macro - parse user's phrase definitions into an internal AST that can be validated and code-generated. This is the first step in the parse -> validate -> codegen pipeline.

Output: A new rlf-macros crate that can parse rlf! { ... } blocks into a structured MacroInput type with span preservation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-macro-code-generation/05-CONTEXT.md
@.planning/phases/05-macro-code-generation/05-RESEARCH.md
@docs/APPENDIX_RUST_INTEGRATION.md
@crates/rlf/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rlf-macros crate with dependencies</name>
  <files>
    crates/rlf-macros/Cargo.toml
    crates/rlf-macros/src/lib.rs
    Cargo.toml
  </files>
  <action>
Create a new proc-macro crate at `crates/rlf-macros/`:

1. Create `crates/rlf-macros/Cargo.toml`:
```toml
[package]
name = "rlf-macros"
version = "0.1.0"
edition = "2024"

[lib]
proc-macro = true

[dependencies]
syn = { version = "2.0", features = ["full", "parsing", "printing"] }
quote = "1.0"
proc-macro2 = "1.0"
strsim = "0.11"  # For typo suggestions (matches rlf crate)

[dev-dependencies]
trybuild = "1.0"
```

2. Create `crates/rlf-macros/src/lib.rs` with basic macro entry point:
```rust
use proc_macro::TokenStream;

mod input;
mod parse;

/// The rlf! macro for defining localized phrases.
///
/// Parses phrase definitions and generates typed Rust functions
/// with compile-time validation.
#[proc_macro]
pub fn rlf(input: TokenStream) -> TokenStream {
    let input = syn::parse_macro_input!(input as input::MacroInput);

    // TODO: Validation (Plan 02)
    // TODO: Code generation (Plan 03)

    // For now, just produce empty output so the crate compiles
    proc_macro2::TokenStream::new().into()
}
```

3. Add rlf-macros to workspace in root `Cargo.toml`:
```toml
[workspace]
members = ["crates/rlf", "crates/rlf-macros"]
```

Note: Do NOT add rlf-macros as a dependency of rlf yet - that will be done in Plan 04 after code generation is complete.
  </action>
  <verify>
`cargo build -p rlf-macros` compiles successfully.
`cargo build` compiles the entire workspace.
  </verify>
  <done>rlf-macros crate exists with proc-macro = true and syn/quote/proc-macro2 dependencies.</done>
</task>

<task type="auto">
  <name>Task 2: Define internal AST types with span preservation</name>
  <files>crates/rlf-macros/src/input.rs</files>
  <action>
Create the internal AST types that mirror the existing parser AST but with Span information for error messages.

Based on APPENDIX_RUST_INTEGRATION.md and the existing parser types in crates/rlf/src/parser/, create:

```rust
use proc_macro2::Span;
use syn::Ident;

/// Top-level macro input containing all phrase definitions.
pub struct MacroInput {
    pub phrases: Vec<PhraseDefinition>,
}

/// A single phrase definition: `name(params) = body;`
pub struct PhraseDefinition {
    pub name: SpannedIdent,
    pub parameters: Vec<SpannedIdent>,
    pub tags: Vec<SpannedIdent>,
    pub body: PhraseBody,
}

/// Wrapper for identifiers that preserves span information.
#[derive(Clone)]
pub struct SpannedIdent {
    pub name: String,
    pub span: Span,
}

impl SpannedIdent {
    pub fn new(ident: &Ident) -> Self {
        Self {
            name: ident.to_string(),
            span: ident.span(),
        }
    }
}

/// Phrase body: either simple template or variant map.
pub enum PhraseBody {
    Simple(Template),
    Variants(Vec<VariantEntry>),
}

/// A variant entry: `key: "template"`
pub struct VariantEntry {
    pub keys: Vec<SpannedIdent>,  // Multi-key support (nom, acc: "shared")
    pub template: Template,
}

/// A template string with interpolations.
pub struct Template {
    pub segments: Vec<Segment>,
    pub span: Span,
}

/// A segment of a template: literal text or interpolation.
pub enum Segment {
    Literal(String),
    Interpolation(Interpolation),
}

/// An interpolation: `{@transform name:selector}`
pub struct Interpolation {
    pub transforms: Vec<SpannedIdent>,
    pub reference: Reference,
    pub selectors: Vec<Selector>,
    pub span: Span,
}

/// A reference to a parameter or phrase.
pub enum Reference {
    /// Simple identifier (resolved later as parameter or phrase)
    Identifier(SpannedIdent),
    /// Phrase call with arguments: `foo(x, y)`
    Call {
        name: SpannedIdent,
        args: Vec<Reference>,
    },
}

/// A selector: `:name` (literal) or `:n` (parameter-based)
pub struct Selector {
    pub name: SpannedIdent,
}
```

This mirrors the parser AST structure but adds span information everywhere an error might need to point to user code.
  </action>
  <verify>`cargo build -p rlf-macros` compiles successfully.</verify>
  <done>Internal AST types exist with SpannedIdent for span preservation on all user-provided names.</done>
</task>

<task type="auto">
  <name>Task 3: Implement syn Parse traits for all AST types</name>
  <files>crates/rlf-macros/src/parse.rs</files>
  <action>
Implement `syn::parse::Parse` for all AST types to convert TokenStream into MacroInput.

Key parsing patterns based on APPENDIX_RUST_INTEGRATION.md syntax:

1. **MacroInput**: Zero or more PhraseDefinitions
2. **PhraseDefinition**:
   - Optional tags: `:tag1 :tag2`
   - Name: identifier
   - Optional params: `(p1, p2)`
   - `=`
   - Body (Simple or Variants)
   - `;`

3. **PhraseBody**:
   - If starts with `{` and contains `:` -> Variants
   - Otherwise -> Simple template

4. **Template parsing**:
   - Parse as a raw string literal `"..."`
   - Extract segments by finding `{...}` blocks
   - For each `{...}`, parse as Interpolation

5. **Interpolation parsing** (within `{...}`):
   - Optional transforms: `@cap @upper`
   - Reference: identifier or call `name(args)`
   - Optional selectors: `:sel1 :sel2`

```rust
use syn::{parse::{Parse, ParseStream}, Token, Ident, LitStr, braced};
use syn::punctuated::Punctuated;
use crate::input::*;

impl Parse for MacroInput {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let mut phrases = Vec::new();
        while !input.is_empty() {
            phrases.push(input.parse()?);
        }
        Ok(MacroInput { phrases })
    }
}

impl Parse for PhraseDefinition {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        // Parse optional tags (: followed by ident)
        let mut tags = Vec::new();
        while input.peek(Token![:]) && !input.peek2(syn::token::Brace) {
            input.parse::<Token![:]>()?;
            let ident: Ident = input.parse()?;
            tags.push(SpannedIdent::new(&ident));
        }

        // Parse phrase name
        let name_ident: Ident = input.parse()?;
        let name = SpannedIdent::new(&name_ident);

        // Parse optional parameters
        let parameters = if input.peek(syn::token::Paren) {
            let content;
            syn::parenthesized!(content in input);
            let params: Punctuated<Ident, Token![,]> =
                Punctuated::parse_terminated(&content)?;
            params.into_iter().map(|i| SpannedIdent::new(&i)).collect()
        } else {
            Vec::new()
        };

        // Parse =
        input.parse::<Token![=]>()?;

        // Parse body
        let body = input.parse()?;

        // Parse ;
        input.parse::<Token![;]>()?;

        Ok(PhraseDefinition { name, parameters, tags, body })
    }
}

// Continue with PhraseBody, Template, Interpolation, Reference, Selector parsing...
```

For template parsing, parse the string literal then manually extract interpolations from the string content. Use `proc_macro2::Span::call_site()` for spans within string literals (limitation of proc-macros - we can't point inside strings).

Handle edge cases:
- Escaped braces: `{{` and `}}` become literal `{` and `}`
- Nested braces in interpolations: not supported, error
- Empty interpolations: `{}` is an error
  </action>
  <verify>
`cargo build -p rlf-macros` compiles successfully.
`just review` passes all checks.
  </verify>
  <done>All Parse implementations exist and the macro can parse phrase definitions into MacroInput AST.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo build -p rlf-macros` compiles the proc-macro crate
2. `cargo build` compiles the entire workspace
3. `just review` passes all checks
4. The macro entry point exists and uses parse_macro_input!
5. Internal AST types have span information on all identifiers
</verification>

<success_criteria>
- rlf-macros crate exists with proc-macro = true configuration
- syn 2.0, quote 1.0, proc-macro2 1.0 are dependencies
- MacroInput type can represent all phrase definition syntax
- Parse implementations convert TokenStream to MacroInput
- SpannedIdent preserves span information for all user identifiers
- Workspace builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/05-macro-code-generation/05-01-SUMMARY.md`
</output>
