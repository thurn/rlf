---
phase: 05-macro-code-generation
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - crates/rlf-macros/src/validate.rs
  - crates/rlf-macros/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Undefined phrase references produce compile error with span"
    - "Undefined parameter references produce compile error with span"
    - "Invalid literal selectors produce compile error listing available variants"
    - "Unknown transforms produce compile error"
    - "Cyclic references produce compile error showing the cycle chain"
    - "Parameter shadowing phrase names produces compile error"
    - "Typo suggestions appear in error messages (Levenshtein distance)"
  artifacts:
    - path: "crates/rlf-macros/src/validate.rs"
      provides: "All 7 validation checks"
      contains: "fn validate"
  key_links:
    - from: "crates/rlf-macros/src/lib.rs"
      to: "crates/rlf-macros/src/validate.rs"
      via: "validate() call before codegen"
      pattern: "validate\\("
---

<objective>
Implement compile-time validation for the rlf! macro.

Purpose: Catch errors at compile time with helpful error messages and source spans. The 7 validation checks ensure users get immediate feedback when something is wrong, following the "IDE autocomplete works immediately" principle.

Output: A validate() function that performs all compile-time checks and returns syn::Result with spanned errors.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-macro-code-generation/05-CONTEXT.md
@.planning/phases/05-macro-code-generation/05-RESEARCH.md
@.planning/phases/05-macro-code-generation/05-01-SUMMARY.md
@docs/APPENDIX_RUST_INTEGRATION.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement reference and parameter validation</name>
  <files>crates/rlf-macros/src/validate.rs</files>
  <action>
Create validate.rs with the first set of validation checks:

1. **Build phrase index**: Collect all phrase names from MacroInput
2. **Undefined phrase reference (MACRO-08)**: Every `{phrase_name}` must be defined
3. **Undefined parameter reference (MACRO-09)**: Every `{param}` must be in parameter list
4. **Parameter shadowing (MACRO-15)**: Parameter names cannot match phrase names
5. **Typo suggestions (MACRO-17)**: Use strsim for Levenshtein distance

```rust
use std::collections::{HashMap, HashSet};
use proc_macro2::Span;
use strsim::levenshtein;
use crate::input::*;

/// Validation context built from MacroInput.
pub struct ValidationContext {
    /// All defined phrase names
    pub phrases: HashSet<String>,
    /// Phrase name -> defined variants (for literal selector validation)
    pub phrase_variants: HashMap<String, HashSet<String>>,
    /// Phrase name -> defined tags
    pub phrase_tags: HashMap<String, HashSet<String>>,
}

impl ValidationContext {
    pub fn from_input(input: &MacroInput) -> Self {
        // Build phrase index, variants, tags
        // ...
    }
}

/// Main validation entry point.
pub fn validate(input: &MacroInput) -> syn::Result<()> {
    let ctx = ValidationContext::from_input(input);

    // Check each phrase definition
    for phrase in &input.phrases {
        validate_phrase(phrase, &ctx)?;
    }

    // Check for cycles (separate pass)
    detect_cycles(input)?;

    Ok(())
}

fn validate_phrase(phrase: &PhraseDefinition, ctx: &ValidationContext) -> syn::Result<()> {
    let params: HashSet<String> = phrase.parameters.iter()
        .map(|p| p.name.clone())
        .collect();

    // Check parameter shadowing (MACRO-15)
    for param in &phrase.parameters {
        if ctx.phrases.contains(&param.name) {
            return Err(syn::Error::new(
                param.span,
                format!(
                    "parameter '{}' shadows phrase '{}'\nhelp: use a different parameter name",
                    param.name, param.name
                ),
            ));
        }
    }

    // Validate body references
    match &phrase.body {
        PhraseBody::Simple(template) => validate_template(template, &params, ctx)?,
        PhraseBody::Variants(variants) => {
            for variant in variants {
                validate_template(&variant.template, &params, ctx)?;
            }
        }
    }

    Ok(())
}

fn validate_template(
    template: &Template,
    params: &HashSet<String>,
    ctx: &ValidationContext,
) -> syn::Result<()> {
    for segment in &template.segments {
        if let Segment::Interpolation(interp) = segment {
            validate_reference(&interp.reference, params, ctx)?;
            // Selectors validated later (need to know if reference is literal)
        }
    }
    Ok(())
}

fn validate_reference(
    reference: &Reference,
    params: &HashSet<String>,
    ctx: &ValidationContext,
) -> syn::Result<()> {
    match reference {
        Reference::Identifier(ident) => {
            // If it's a parameter, that's valid
            if params.contains(&ident.name) {
                return Ok(());
            }
            // Otherwise it must be a phrase
            if !ctx.phrases.contains(&ident.name) {
                let suggestions = compute_suggestions(&ident.name, ctx.phrases.iter());
                let mut msg = format!("unknown phrase '{}'", ident.name);
                if !suggestions.is_empty() {
                    msg.push_str(&format!("\nhelp: did you mean '{}'?", suggestions[0]));
                }
                return Err(syn::Error::new(ident.span, msg));
            }
        }
        Reference::Call { name, args } => {
            // Phrase call - phrase must exist
            if !ctx.phrases.contains(&name.name) {
                let suggestions = compute_suggestions(&name.name, ctx.phrases.iter());
                let mut msg = format!("unknown phrase '{}'", name.name);
                if !suggestions.is_empty() {
                    msg.push_str(&format!("\nhelp: did you mean '{}'?", suggestions[0]));
                }
                return Err(syn::Error::new(name.span, msg));
            }
            // Validate arguments recursively
            for arg in args {
                validate_reference(arg, params, ctx)?;
            }
        }
    }
    Ok(())
}

/// Compute typo suggestions using Levenshtein distance.
/// Match existing runtime behavior: distance ≤ 1 for keys ≤ 3 chars, ≤ 2 for longer.
fn compute_suggestions<'a>(
    name: &str,
    available: impl Iterator<Item = &'a String>,
) -> Vec<String> {
    let max_distance = if name.len() <= 3 { 1 } else { 2 };
    let mut suggestions: Vec<(usize, String)> = available
        .filter_map(|candidate| {
            let dist = levenshtein(name, candidate);
            if dist <= max_distance {
                Some((dist, candidate.clone()))
            } else {
                None
            }
        })
        .collect();

    suggestions.sort_by_key(|(dist, _)| *dist);
    suggestions.into_iter().take(3).map(|(_, s)| s).collect()
}
```

Use syn::Error::new() with the SpannedIdent's span to produce errors pointing to the right location.
  </action>
  <verify>
`cargo build -p rlf-macros` compiles successfully.
`just review` passes all checks.
  </verify>
  <done>Undefined phrase/parameter references and parameter shadowing produce compile errors with spans and suggestions.</done>
</task>

<task type="auto">
  <name>Task 2: Implement selector, transform, and tag validation</name>
  <files>crates/rlf-macros/src/validate.rs</files>
  <action>
Add the remaining validation checks to validate.rs:

1. **Literal selector validation (MACRO-10)**: When selector is not a parameter name, it must match a defined variant
2. **Transform existence (MACRO-11)**: Every @transform must be known (universal: cap, upper, lower)
3. **Transform tag validation (MACRO-12)**: When transform applied to literal phrase, phrase must have required tag
4. **Tag-based selection compatibility (MACRO-13)**: When selecting by tag on literal phrase, phrase's tag must have matching variant

```rust
/// Known transforms (universal only for Phase 5).
const KNOWN_TRANSFORMS: &[&str] = &["cap", "upper", "lower"];

fn validate_interpolation(
    interp: &Interpolation,
    params: &HashSet<String>,
    ctx: &ValidationContext,
) -> syn::Result<()> {
    // Validate transforms exist (MACRO-11)
    for transform in &interp.transforms {
        if !KNOWN_TRANSFORMS.contains(&transform.name.as_str()) {
            return Err(syn::Error::new(
                transform.span,
                format!("unknown transform '@{}'", transform.name),
            ));
        }
    }

    // Validate reference
    validate_reference(&interp.reference, params, ctx)?;

    // Validate selectors
    let is_literal_phrase = match &interp.reference {
        Reference::Identifier(ident) => !params.contains(&ident.name),
        Reference::Call { .. } => true, // Phrase calls are always literal
    };

    if is_literal_phrase {
        let phrase_name = match &interp.reference {
            Reference::Identifier(ident) => &ident.name,
            Reference::Call { name, .. } => &name.name,
        };

        // Get phrase variants and tags
        let phrase_variants = ctx.phrase_variants.get(phrase_name);
        let phrase_tags = ctx.phrase_tags.get(phrase_name);

        for selector in &interp.selectors {
            // If selector name is a parameter, it's dynamic - skip compile-time check
            if params.contains(&selector.name.name) {
                continue;
            }

            // Literal selector - must match a variant (MACRO-10)
            if let Some(variants) = phrase_variants {
                if !variants.contains(&selector.name.name) {
                    let available: Vec<_> = variants.iter().cloned().collect();
                    return Err(syn::Error::new(
                        selector.name.span,
                        format!(
                            "phrase '{}' has no variant '{}'\nnote: available variants: {}",
                            phrase_name,
                            selector.name.name,
                            available.join(", ")
                        ),
                    ));
                }
            }
        }

        // Transform tag validation (MACRO-12)
        // Note: @a/@an transforms are not in Phase 5 (Phase 6+), so skip for now
        // Universal transforms (cap, upper, lower) don't require tags

        // Tag-based selection compatibility (MACRO-13)
        // When selector references a literal phrase's tag, check compatibility
        // This requires knowing when a selector IS a phrase reference for tag lookup
        // Complex case - implement basic check for direct tag selectors
    }

    Ok(())
}
```

Update validate_template to call validate_interpolation for each interpolation segment.

Note: Transform tag validation (MACRO-12) and tag-based selection (MACRO-13) only apply when:
- The transform argument or selector phrase is a literal (not a parameter)
- The transform requires specific tags (Phase 5 only has universal transforms which don't)

For Phase 5, these checks are mostly deferred since universal transforms don't require tags. The infrastructure is in place for Phase 6+ when @a/@an are added.
  </action>
  <verify>
`cargo build -p rlf-macros` compiles successfully.
`just review` passes all checks.
  </verify>
  <done>Literal selector validation and transform existence validation work. Tag validation infrastructure exists for future phases.</done>
</task>

<task type="auto">
  <name>Task 3: Implement cycle detection</name>
  <files>crates/rlf-macros/src/validate.rs</files>
  <action>
Implement cycle detection using DFS with coloring (MACRO-14):

```rust
use std::collections::HashMap;

#[derive(Clone, Copy, PartialEq)]
enum Color {
    White,  // Not visited
    Gray,   // In current DFS path
    Black,  // Fully processed
}

/// Detect cycles in phrase references.
/// Returns an error with the full cycle chain if found.
pub fn detect_cycles(input: &MacroInput) -> syn::Result<()> {
    // Build dependency graph: phrase name -> list of phrase references
    let mut deps: HashMap<String, Vec<(String, Span)>> = HashMap::new();

    for phrase in &input.phrases {
        let refs = collect_phrase_refs(&phrase.body);
        deps.insert(phrase.name.name.clone(), refs);
    }

    // DFS with coloring
    let mut colors: HashMap<String, Color> = deps.keys()
        .map(|k| (k.clone(), Color::White))
        .collect();

    for name in deps.keys() {
        if colors.get(name) == Some(&Color::White) {
            let mut path: Vec<(String, Span)> = Vec::new();
            if let Some((cycle, span)) = dfs_find_cycle(name, &deps, &mut colors, &mut path) {
                // Format cycle chain: a -> b -> c -> a
                let chain = cycle.join(" -> ");
                return Err(syn::Error::new(
                    span,
                    format!("cyclic reference: {}", chain),
                ));
            }
        }
    }

    Ok(())
}

fn dfs_find_cycle(
    name: &str,
    deps: &HashMap<String, Vec<(String, Span)>>,
    colors: &mut HashMap<String, Color>,
    path: &mut Vec<(String, Span)>,
) -> Option<(Vec<String>, Span)> {
    colors.insert(name.to_string(), Color::Gray);

    if let Some(refs) = deps.get(name) {
        for (ref_name, span) in refs {
            match colors.get(ref_name) {
                Some(Color::Gray) => {
                    // Found cycle - extract from path
                    let cycle_start = path.iter()
                        .position(|(n, _)| n == ref_name)
                        .unwrap_or(0);
                    let mut cycle: Vec<String> = path[cycle_start..]
                        .iter()
                        .map(|(n, _)| n.clone())
                        .collect();
                    cycle.push(ref_name.clone());
                    return Some((cycle, *span));
                }
                Some(Color::White) | None => {
                    path.push((name.to_string(), *span));
                    if let Some(result) = dfs_find_cycle(ref_name, deps, colors, path) {
                        return Some(result);
                    }
                    path.pop();
                }
                Some(Color::Black) => {}
            }
        }
    }

    colors.insert(name.to_string(), Color::Black);
    None
}

/// Collect all phrase references from a phrase body.
/// Returns (phrase_name, span) tuples.
fn collect_phrase_refs(body: &PhraseBody) -> Vec<(String, Span)> {
    let mut refs = Vec::new();
    match body {
        PhraseBody::Simple(template) => collect_template_refs(template, &mut refs),
        PhraseBody::Variants(variants) => {
            for variant in variants {
                collect_template_refs(&variant.template, &mut refs);
            }
        }
    }
    refs
}

fn collect_template_refs(template: &Template, refs: &mut Vec<(String, Span)>) {
    for segment in &template.segments {
        if let Segment::Interpolation(interp) = segment {
            collect_reference_refs(&interp.reference, refs);
        }
    }
}

fn collect_reference_refs(reference: &Reference, refs: &mut Vec<(String, Span)>) {
    match reference {
        Reference::Identifier(ident) => {
            // Could be parameter or phrase - we'll filter later
            // Add all for now, cycles only happen between phrases
            refs.push((ident.name.clone(), ident.span));
        }
        Reference::Call { name, args } => {
            refs.push((name.name.clone(), name.span));
            for arg in args {
                collect_reference_refs(arg, refs);
            }
        }
    }
}
```

The cycle detection filters out parameter references by checking against the phrase index in validate() before calling detect_cycles().
  </action>
  <verify>
`cargo build -p rlf-macros` compiles successfully.
`just review` passes all checks.
  </verify>
  <done>Cyclic references are detected with full chain shown in error message.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo build -p rlf-macros` compiles successfully
2. `just review` passes all checks
3. validate() function exists and is called from lib.rs
4. All 7 validation types are implemented:
   - Undefined phrase references
   - Undefined parameter references
   - Invalid literal selectors
   - Unknown transforms
   - Transform tags (infrastructure for future)
   - Tag-based selection (infrastructure for future)
   - Cyclic references
5. Error messages include spans and suggestions where applicable
</verification>

<success_criteria>
- validate() checks all references and selectors
- syn::Error produced with correct spans
- Typo suggestions appear for near-matches
- Cycle detection finds and reports cycles with full chain
- Unknown transforms produce clear errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-macro-code-generation/05-02-SUMMARY.md`
</output>
