---
phase: 05-macro-code-generation
plan: 04
type: execute
wave: 3
depends_on: ["05-02", "05-03"]
files_modified:
  - crates/rlf-macros/src/lib.rs
  - crates/rlf/Cargo.toml
  - crates/rlf/src/lib.rs
  - crates/rlf-macros/tests/integration.rs
  - crates/rlf-macros/tests/fail/undefined_phrase.rs
  - crates/rlf-macros/tests/fail/undefined_phrase.stderr
  - crates/rlf-macros/tests/fail/cycle.rs
  - crates/rlf-macros/tests/fail/cycle.stderr
  - crates/rlf-macros/tests/pass/basic.rs
autonomous: true

must_haves:
  truths:
    - "rlf! macro can be used in a Rust file"
    - "Generated functions compile and work correctly"
    - "IDE autocomplete shows generated functions"
    - "Compile errors point to correct source locations"
    - "trybuild tests verify error messages"
  artifacts:
    - path: "crates/rlf/Cargo.toml"
      provides: "Re-exports rlf! macro"
      contains: "rlf-macros"
    - path: "crates/rlf-macros/tests/integration.rs"
      provides: "Basic integration test"
      contains: "rlf!"
  key_links:
    - from: "crates/rlf/src/lib.rs"
      to: "crates/rlf-macros"
      via: "pub use rlf_macros::rlf"
      pattern: "pub use rlf_macros::rlf"
---

<objective>
Integrate validation and codegen into the macro entry point, add rlf-macros as a dependency of rlf, and create trybuild tests.

Purpose: Complete the macro pipeline and verify it works end-to-end with proper error messages. This is the final integration step that makes the macro usable.

Output: Working rlf! macro that can be used in Rust code, with trybuild tests verifying compile-time errors.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-macro-code-generation/05-CONTEXT.md
@.planning/phases/05-macro-code-generation/05-RESEARCH.md
@.planning/phases/05-macro-code-generation/05-01-SUMMARY.md
@.planning/phases/05-macro-code-generation/05-02-SUMMARY.md
@.planning/phases/05-macro-code-generation/05-03-SUMMARY.md
@docs/APPENDIX_RUST_INTEGRATION.md
@crates/rlf/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire up validation and codegen in macro entry point</name>
  <files>crates/rlf-macros/src/lib.rs</files>
  <action>
Update lib.rs to call validate() and codegen() in the proper pipeline order:

```rust
use proc_macro::TokenStream;
use proc_macro2::TokenStream as TokenStream2;

mod codegen;
mod input;
mod parse;
mod validate;

/// The rlf! macro for defining localized phrases.
///
/// Parses phrase definitions and generates typed Rust functions
/// with compile-time validation.
///
/// # Example
///
/// ```ignore
/// rlf! {
///     card = { one: "card", other: "cards" };
///     draw(n) = "Draw {n} {card:n}.";
/// }
///
/// // Generated:
/// // pub fn card(locale: &Locale) -> Phrase { ... }
/// // pub fn draw(locale: &Locale, n: impl Into<Value>) -> Phrase { ... }
/// // pub const SOURCE_PHRASES: &str = ...;
/// // pub fn register_source_phrases(locale: &mut Locale) { ... }
/// // pub mod phrase_ids { pub const CARD: PhraseId = ...; }
/// ```
#[proc_macro]
pub fn rlf(input: TokenStream) -> TokenStream {
    let input = syn::parse_macro_input!(input as input::MacroInput);

    match expand(input) {
        Ok(tokens) => tokens.into(),
        Err(e) => e.into_compile_error().into(),
    }
}

fn expand(input: input::MacroInput) -> syn::Result<TokenStream2> {
    // Step 1: Validate
    validate::validate(&input)?;

    // Step 2: Generate code
    Ok(codegen::codegen(&input))
}
```

This follows the pattern from RESEARCH.md: use syn::Error::into_compile_error() for error handling, never panic.
  </action>
  <verify>
`cargo build -p rlf-macros` compiles successfully.
`just review` passes all checks.
  </verify>
  <done>Macro entry point calls validate() then codegen() and handles errors properly.</done>
</task>

<task type="auto">
  <name>Task 2: Add rlf-macros as dependency and re-export macro</name>
  <files>
    crates/rlf/Cargo.toml
    crates/rlf/src/lib.rs
  </files>
  <action>
Add rlf-macros as a dependency of rlf and re-export the macro:

1. Update `crates/rlf/Cargo.toml`:
```toml
[dependencies]
# ... existing deps ...
rlf-macros = { path = "../rlf-macros" }
```

2. Update `crates/rlf/src/lib.rs` to re-export the macro:
```rust
pub mod interpreter;
pub mod parser;
pub mod types;

pub use interpreter::{
    EvalContext, EvalError, LoadError, Locale, PhraseRegistry, TransformRegistry,
    compute_suggestions,
};
pub use types::{Phrase, PhraseId, Tag, Value, VariantKey};

// Re-export the rlf! macro
pub use rlf_macros::rlf;
```

Now users can use `rlf::rlf!` or just `use rlf::rlf;` then `rlf! { ... }`.
  </action>
  <verify>
`cargo build` compiles the entire workspace.
`just review` passes all checks.
  </verify>
  <done>rlf crate re-exports the rlf! macro from rlf-macros.</done>
</task>

<task type="auto">
  <name>Task 3: Create trybuild tests for error messages and basic usage</name>
  <files>
    crates/rlf-macros/tests/integration.rs
    crates/rlf-macros/tests/fail/undefined_phrase.rs
    crates/rlf-macros/tests/fail/undefined_phrase.stderr
    crates/rlf-macros/tests/fail/cycle.rs
    crates/rlf-macros/tests/fail/cycle.stderr
    crates/rlf-macros/tests/fail/unknown_transform.rs
    crates/rlf-macros/tests/fail/unknown_transform.stderr
    crates/rlf-macros/tests/pass/basic.rs
  </files>
  <action>
Create trybuild tests to verify compile-time error messages.

1. Create `crates/rlf-macros/tests/integration.rs`:
```rust
#[test]
fn compile_tests() {
    let t = trybuild::TestCases::new();
    t.pass("tests/pass/*.rs");
    t.compile_fail("tests/fail/*.rs");
}
```

2. Create `crates/rlf-macros/tests/pass/basic.rs`:
```rust
// Test basic macro usage compiles successfully
use rlf::{rlf, Locale};

rlf! {
    hello = "Hello, world!";
    card = { one: "card", other: "cards" };
    draw(n) = "Draw {n} {card:n}.";
}

fn main() {
    let mut locale = Locale::new();
    register_source_phrases(&mut locale);

    let _h = hello(&locale);
    let _c = card(&locale);
    let _d = draw(&locale, 3);

    // Test phrase_ids module
    let _id = phrase_ids::HELLO;
    let _card_id = phrase_ids::CARD;
    let _draw_id = phrase_ids::DRAW;
}
```

3. Create `crates/rlf-macros/tests/fail/undefined_phrase.rs`:
```rust
use rlf::rlf;

rlf! {
    card = "card";
    draw(n) = "Draw {n} {cards:n}.";
}

fn main() {}
```

4. Create `crates/rlf-macros/tests/fail/undefined_phrase.stderr`:
```
error: unknown phrase 'cards'
       help: did you mean 'card'?
```
Note: The exact format will be adjusted after running the test once to capture the actual error format.

5. Create `crates/rlf-macros/tests/fail/cycle.rs`:
```rust
use rlf::rlf;

rlf! {
    a = "see {b}";
    b = "see {c}";
    c = "see {a}";
}

fn main() {}
```

6. Create `crates/rlf-macros/tests/fail/cycle.stderr`:
```
error: cyclic reference: a -> b -> c -> a
```

7. Create `crates/rlf-macros/tests/fail/unknown_transform.rs`:
```rust
use rlf::rlf;

rlf! {
    card = "card";
    bad = "{@foo card}";
}

fn main() {}
```

8. Create `crates/rlf-macros/tests/fail/unknown_transform.stderr`:
```
error: unknown transform '@foo'
```

Run `cargo test -p rlf-macros` and update .stderr files to match actual output format.
  </action>
  <verify>
`cargo test -p rlf-macros` runs all tests.
`cargo test` runs all tests in the workspace.
`just review` passes all checks.
  </verify>
  <done>trybuild tests verify compile-time errors and basic macro usage.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo build` compiles the entire workspace
2. `cargo test` runs all tests including trybuild tests
3. `just review` passes all checks
4. The rlf! macro can be used in user code:
   - Phrase definitions parse correctly
   - Functions are generated
   - PhraseId constants exist
   - SOURCE_PHRASES and register_source_phrases work
5. Compile errors have correct spans and helpful messages
6. trybuild tests pass (both pass/ and fail/ cases)
</verification>

<success_criteria>
- rlf! macro works end-to-end
- rlf crate re-exports the macro
- Generated functions compile and are callable
- phrase_ids module is accessible
- register_source_phrases loads phrases into Locale
- Undefined phrases produce compile error with suggestion
- Cycles produce compile error with full chain
- Unknown transforms produce compile error
- All trybuild tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-macro-code-generation/05-04-SUMMARY.md`
</output>
