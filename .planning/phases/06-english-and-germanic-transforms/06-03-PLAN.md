---
phase: 06-english-and-germanic-transforms
plan: 03
type: tdd
wave: 2
depends_on: ["06-01"]
files_modified:
  - crates/rlf/src/interpreter/transforms.rs
  - crates/rlf/tests/interpreter_transforms.rs
autonomous: true

must_haves:
  truths:
    - "Dutch @de selects definite article from :de/:het tags"
    - "Dutch @de with :de tag produces 'de X'"
    - "Dutch @de with :het tag produces 'het X'"
    - "Dutch @een produces 'een X' unconditionally"
    - "Transform alias @het resolves to @de"
    - "Missing :de/:het tag produces MissingTag error"
  artifacts:
    - path: "crates/rlf/src/interpreter/transforms.rs"
      provides: "DutchDe and DutchEen variants in TransformKind"
      contains: "DutchDe"
    - path: "crates/rlf/tests/interpreter_transforms.rs"
      provides: "Tests for Dutch article transforms"
      contains: "dutch_de_with_de_tag"
  key_links:
    - from: "crates/rlf/src/interpreter/transforms.rs"
      to: "Value::has_tag"
      via: "DutchDe checks :de/:het tags"
      pattern: 'value\\.has_tag\\("de"\\)'
---

<objective>
Implement Dutch article transforms (@de/@het and @een) with tag-based gender selection.

Purpose: Enable Dutch definite and indefinite article selection. Dutch is simpler than German - only two article genders (de-words and het-words) and no case system affecting articles. The indefinite article "een" is invariant.

Output: Working @de, @het, @een transforms for Dutch with comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-english-and-germanic-transforms/06-RESEARCH.md
@.planning/phases/06-english-and-germanic-transforms/06-01-SUMMARY.md
@docs/APPENDIX_STDLIB.md (Dutch section)
@crates/rlf/src/interpreter/transforms.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Dutch transforms with TDD</name>
  <files>crates/rlf/src/interpreter/transforms.rs, crates/rlf/tests/interpreter_transforms.rs</files>
  <action>
RED phase - Write failing tests first:

```rust
// Dutch @de transform tests
#[test]
fn dutch_de_with_de_tag() {
    // Phrase with :de tag (common gender) produces "de kaart"
    let phrase = Phrase::builder()
        .text("kaart".to_string())
        .tags(vec!["de".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::DutchDe;
    let result = transform.execute(&value, None, "nl").unwrap();
    assert_eq!(result, "de kaart");
}

#[test]
fn dutch_de_with_het_tag() {
    // Phrase with :het tag (neuter gender) produces "het karakter"
    let phrase = Phrase::builder()
        .text("karakter".to_string())
        .tags(vec!["het".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::DutchDe;
    let result = transform.execute(&value, None, "nl").unwrap();
    assert_eq!(result, "het karakter");
}

#[test]
fn dutch_de_missing_tag_error() {
    // Phrase without :de or :het tag produces error
    let phrase = Phrase::builder()
        .text("ding".to_string())
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::DutchDe;
    let result = transform.execute(&value, None, "nl");
    assert!(matches!(result, Err(EvalError::MissingTag { .. })));
}

#[test]
fn dutch_een_transform() {
    // @een always produces "een X" regardless of gender
    let value = Value::String("kaart".to_string());
    let transform = TransformKind::DutchEen;
    let result = transform.execute(&value, None, "nl").unwrap();
    assert_eq!(result, "een kaart");
}

#[test]
fn dutch_een_with_phrase() {
    // @een works with Phrase values too
    let phrase = Phrase::builder()
        .text("karakter".to_string())
        .tags(vec!["het".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::DutchEen;
    let result = transform.execute(&value, None, "nl").unwrap();
    assert_eq!(result, "een karakter");
}

#[test]
fn dutch_transform_alias_het() {
    // @het resolves to DutchDe
    let registry = TransformRegistry::new();
    let transform = registry.get("het", "nl");
    assert_eq!(transform, Some(TransformKind::DutchDe));
}
```

GREEN phase - Implement transforms:

1. Add enum variants:
```rust
// Dutch transforms (Phase 6)
DutchDe,     // @de/@het - definite article from :de/:het tags
DutchEen,    // @een - indefinite article "een"
```

2. Implement transform functions:
```rust
fn dutch_de_transform(value: &Value) -> Result<String, EvalError> {
    let text = value.to_string();

    if value.has_tag("de") {
        return Ok(format!("de {}", text));
    }
    if value.has_tag("het") {
        return Ok(format!("het {}", text));
    }

    Err(EvalError::MissingTag {
        transform: "de".to_string(),
        expected: vec!["de".to_string(), "het".to_string()],
        phrase: text,
    })
}

fn dutch_een_transform(value: &Value) -> Result<String, EvalError> {
    // Dutch indefinite article is invariant - always "een"
    Ok(format!("een {}", value.to_string()))
}
```

3. Update execute() match:
```rust
TransformKind::DutchDe => dutch_de_transform(value),
TransformKind::DutchEen => dutch_een_transform(value),
```

4. Update TransformRegistry::get() with Dutch entries:
```rust
// Resolve aliases
let canonical = match name {
    "an" => "a",
    "die" | "das" => "der",
    "eine" => "ein",
    "het" => "de",  // Dutch alias
    other => other,
};

// Language-specific transforms
match (lang, canonical) {
    ("en", "a") => Some(TransformKind::EnglishA),
    ("en", "the") => Some(TransformKind::EnglishThe),
    ("de", "der") => Some(TransformKind::GermanDer),
    ("de", "ein") => Some(TransformKind::GermanEin),
    ("nl", "de") => Some(TransformKind::DutchDe),
    ("nl", "een") => Some(TransformKind::DutchEen),
    _ => None,
}
```

Note: Dutch uses `:de` and `:het` as tag names (matching the article names), NOT `:masc`/`:fem`/`:neut`. This is per APPENDIX_STDLIB.md - Dutch grammatical gender system doesn't map cleanly to masculine/feminine, so using article-based tags is more intuitive for Dutch.
  </action>
  <verify>Run `cargo test -p rlf dutch` to run Dutch transform tests. All should pass.</verify>
  <done>DutchDe and DutchEen variants exist, tests pass, @het alias resolves to @de</done>
</task>

<task type="auto">
  <name>Task 2: Dutch integration tests</name>
  <files>crates/rlf/tests/interpreter_transforms.rs</files>
  <action>
Add integration tests that exercise full evaluation with Dutch transforms:

```rust
#[test]
fn dutch_de_in_template() {
    let source = r#"
        kaart = :de "kaart";
        karakter = :het "karakter";
        the_card = "{@de kaart}";
        the_char = "{@het karakter}";
    "#;

    let mut locale = Locale::builder().language("nl").build();
    locale.load_translations_from_str("nl", source).unwrap();

    assert_eq!(
        locale.eval_phrase("nl", "the_card", &[]).unwrap(),
        "de kaart"
    );
    assert_eq!(
        locale.eval_phrase("nl", "the_char", &[]).unwrap(),
        "het karakter"
    );
}

#[test]
fn dutch_een_in_template() {
    let source = r#"
        kaart = :de "kaart";
        karakter = :het "karakter";
        a_card = "{@een kaart}";
        a_char = "{@een karakter}";
    "#;

    let mut locale = Locale::builder().language("nl").build();
    locale.load_translations_from_str("nl", source).unwrap();

    // Indefinite is always "een" regardless of gender
    assert_eq!(
        locale.eval_phrase("nl", "a_card", &[]).unwrap(),
        "een kaart"
    );
    assert_eq!(
        locale.eval_phrase("nl", "a_char", &[]).unwrap(),
        "een karakter"
    );
}

#[test]
fn dutch_de_with_cap() {
    // Test transform ordering: {@cap @de kaart} -> "De kaart"
    let source = r#"
        kaart = :de "kaart";
        the_card = "{@cap @de kaart}";
    "#;

    let mut locale = Locale::builder().language("nl").build();
    locale.load_translations_from_str("nl", source).unwrap();

    // Right-to-left: @de first ("de kaart"), then @cap ("De kaart")
    assert_eq!(
        locale.eval_phrase("nl", "the_card", &[]).unwrap(),
        "De kaart"
    );
}

#[test]
fn dutch_de_missing_tag_full_eval() {
    // Test error when tag missing in full evaluation
    let source = r#"
        ding = "ding";
        the_thing = "{@de ding}";
    "#;

    let mut locale = Locale::builder().language("nl").build();
    locale.load_translations_from_str("nl", source).unwrap();

    let result = locale.eval_phrase("nl", "the_thing", &[]);
    assert!(matches!(result, Err(EvalError::MissingTag { .. })));
}
```
  </action>
  <verify>Run `cargo test -p rlf` - all tests pass. Run `just review` for code quality.</verify>
  <done>Integration tests verify Dutch transforms work in full evaluation</done>
</task>

<task type="auto">
  <name>Task 3: Cross-language verification and cleanup</name>
  <files>crates/rlf/tests/interpreter_transforms.rs</files>
  <action>
Add tests to verify transforms are language-scoped and don't interfere:

```rust
#[test]
fn transforms_are_language_scoped() {
    // @a only works for English, not German or Dutch
    let registry = TransformRegistry::new();

    assert!(registry.get("a", "en").is_some());
    assert!(registry.get("a", "de").is_none());  // German has @der/@ein, not @a
    assert!(registry.get("a", "nl").is_none());  // Dutch has @de/@een, not @a

    assert!(registry.get("der", "de").is_some());
    assert!(registry.get("der", "en").is_none());

    assert!(registry.get("de", "nl").is_some());
    assert!(registry.get("de", "de").is_none());  // "de" is Dutch, not German
}

#[test]
fn universal_transforms_work_in_all_languages() {
    let registry = TransformRegistry::new();

    // @cap, @upper, @lower should work for all languages
    for lang in &["en", "de", "nl", "es", "fr"] {
        assert!(registry.get("cap", lang).is_some(), "cap should work for {}", lang);
        assert!(registry.get("upper", lang).is_some(), "upper should work for {}", lang);
        assert!(registry.get("lower", lang).is_some(), "lower should work for {}", lang);
    }
}

#[test]
fn unknown_transform_error() {
    let registry = TransformRegistry::new();

    // @foo doesn't exist in any language
    assert!(registry.get("foo", "en").is_none());
    assert!(registry.get("foo", "de").is_none());
    assert!(registry.get("foo", "nl").is_none());
}
```

Also add a comprehensive test that uses all three languages:

```rust
#[test]
fn all_phase6_transforms_work() {
    // English
    let en_source = r#"
        card = :a "card";
        event = :an "event";
        test = "Draw {@a card}, play {@an event}, get {@the card}.";
    "#;

    // German
    let de_source = r#"
        karte = :fem "Karte";
        test = "Nimm {@der:acc karte}, benutze {@ein karte}.";
    "#;

    // Dutch
    let nl_source = r#"
        kaart = :de "kaart";
        karakter = :het "karakter";
        test = "Pak {@de kaart}, krijg {@een karakter}.";
    "#;

    let mut locale = Locale::builder().language("en").build();
    locale.load_translations_from_str("en", en_source).unwrap();
    locale.load_translations_from_str("de", de_source).unwrap();
    locale.load_translations_from_str("nl", nl_source).unwrap();

    assert_eq!(
        locale.eval_phrase("en", "test", &[]).unwrap(),
        "Draw a card, play an event, get the card."
    );
    assert_eq!(
        locale.eval_phrase("de", "test", &[]).unwrap(),
        "Nimm die Karte, benutze eine Karte."
    );
    assert_eq!(
        locale.eval_phrase("nl", "test", &[]).unwrap(),
        "Pak de kaart, krijg een karakter."
    );
}
```
  </action>
  <verify>Run `cargo test -p rlf` - all tests pass. Run `just review` for final code quality check.</verify>
  <done>Cross-language tests pass, transforms are properly scoped, phase 6 complete</done>
</task>

</tasks>

<verification>
1. `cargo check -p rlf` compiles without errors
2. `cargo test -p rlf` passes all tests (existing + new)
3. `cargo test -p rlf dutch` shows Dutch-specific tests passing
4. `just review` passes all lints
5. All phase 6 requirements met: EN-01, EN-02, DE-01, DE-02, NL-01, NL-02
</verification>

<success_criteria>
- DutchDe and DutchEen variants added to TransformKind enum
- @de transform reads :de/:het tags and prepends correct article
- @een transform unconditionally prepends "een"
- @het alias resolves to @de in TransformRegistry
- MissingTag error when :de/:het tags absent
- Cross-language tests verify transforms are properly scoped
- All Phase 6 transforms work together (English, German, Dutch)
</success_criteria>

<output>
After completion, create `.planning/phases/06-english-and-germanic-transforms/06-03-SUMMARY.md`
</output>
