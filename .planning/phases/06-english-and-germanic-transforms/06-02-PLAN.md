---
phase: 06-english-and-germanic-transforms
plan: 02
type: tdd
wave: 2
depends_on: ["06-01"]
files_modified:
  - crates/rlf/src/interpreter/transforms.rs
  - crates/rlf/src/interpreter/evaluator.rs
  - crates/rlf/tests/interpreter_transforms.rs
autonomous: true

must_haves:
  truths:
    - "German @der selects definite article by gender (:masc/:fem/:neut) and case context"
    - "German @der defaults to nominative case when no context provided"
    - "German @ein selects indefinite article by gender and case context"
    - "Transform aliases @die, @das resolve to @der; @eine resolves to @ein"
    - "Missing gender tag produces MissingTag error"
  artifacts:
    - path: "crates/rlf/src/interpreter/transforms.rs"
      provides: "GermanDer and GermanEin variants, article lookup tables"
      contains: "GermanDer"
    - path: "crates/rlf/tests/interpreter_transforms.rs"
      provides: "Tests for German article transforms"
      contains: "german_der_nominative"
  key_links:
    - from: "crates/rlf/src/interpreter/transforms.rs"
      to: "german_definite_article"
      via: "GermanDer uses lookup table"
      pattern: "german_definite_article\\(gender, case\\)"
    - from: "crates/rlf/src/interpreter/evaluator.rs"
      to: "TransformKind::execute"
      via: "Context resolution passes case parameter"
      pattern: "context_value\\.as_ref\\(\\)"
---

<objective>
Implement German article transforms (@der/@die/@das and @ein/@eine) with full case declension support.

Purpose: Enable German definite and indefinite article selection based on gender tags and grammatical case context. German has 4 cases x 3 genders = 12 article forms each for definite and indefinite.

Output: Working @der and @ein transforms for German with case context support and comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-english-and-germanic-transforms/06-RESEARCH.md
@.planning/phases/06-english-and-germanic-transforms/06-01-SUMMARY.md
@docs/APPENDIX_STDLIB.md (German section)
@crates/rlf/src/interpreter/transforms.rs
@crates/rlf/src/interpreter/evaluator.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement context resolution in evaluator</name>
  <files>crates/rlf/src/interpreter/evaluator.rs, crates/rlf/tests/interpreter_transforms.rs</files>
  <action>
The current `apply_transforms` function has a placeholder for context resolution. Update it to actually resolve the context selector:

```rust
fn apply_transforms(
    initial_value: &Value,
    transforms: &[Transform],
    transform_registry: &TransformRegistry,
    ctx: &EvalContext<'_>,  // Add ctx parameter
    lang: &str,
) -> Result<String, EvalError> {
    if transforms.is_empty() {
        return Ok(initial_value.to_string());
    }

    let mut current = initial_value.clone();

    for transform in transforms.iter().rev() {
        let transform_kind = transform_registry
            .get(&transform.name, lang)
            .ok_or_else(|| EvalError::UnknownTransform {
                name: transform.name.clone(),
            })?;

        // Resolve context selector if present
        let context_value = if let Some(ctx_selector) = &transform.context {
            match ctx_selector {
                Selector::Identifier(name) => {
                    // Try parameter lookup first
                    if let Some(param) = ctx.get_param(name) {
                        Some(param.clone())
                    } else {
                        // Use as literal string (e.g., "acc", "nom", "dat", "gen")
                        Some(Value::String(name.clone()))
                    }
                }
            }
        } else {
            None
        };

        let result = transform_kind.execute(&current, context_value.as_ref(), lang)?;
        current = Value::String(result);
    }

    Ok(current.to_string())
}
```

Update the call site in `eval_template` to pass `ctx`:
```rust
let transformed = apply_transforms(&selected, transforms, transform_registry, ctx, lang)?;
```

This enables `@der:acc` where `:acc` is resolved as the literal string "acc", or `@der:case` where `case` could be a parameter containing a case string.
  </action>
  <verify>
Run `cargo check -p rlf` to ensure it compiles.

**Critical verification for context resolution:** Add a test that specifically verifies the context value is passed to the transform:

```rust
#[test]
fn context_selector_passed_to_transform() {
    // This test verifies that @der:acc passes "acc" as context to the transform
    // We test this by checking that accusative masculine produces "den" not "der"
    let source = r#"
        charakter = :masc "Charakter";
        destroy_char = "Zerstöre {@der:acc charakter}.";
        see_char = "Sieh {@der charakter}.";
    "#;

    let mut locale = Locale::builder().language("de").build();
    locale.load_translations_from_str("de", source).unwrap();

    // With :acc context -> "den Charakter" (accusative)
    assert_eq!(
        locale.eval_phrase("de", "destroy_char", &[]).unwrap(),
        "Zerstöre den Charakter."
    );
    // Without context -> "der Charakter" (nominative default)
    assert_eq!(
        locale.eval_phrase("de", "see_char", &[]).unwrap(),
        "Sieh der Charakter."
    );
}
```

This test will initially fail (before German transforms are added) but confirms the plumbing. Run `cargo test -p rlf` to verify existing tests still pass.
  </verify>
  <done>Context selector is resolved to Value and passed to transform execute method; test confirms context affects transform output</done>
</task>

<task type="auto">
  <name>Task 2: Add German transforms with TDD</name>
  <files>crates/rlf/src/interpreter/transforms.rs, crates/rlf/tests/interpreter_transforms.rs</files>
  <action>
RED phase - Write failing tests first:

```rust
// German @der transform tests
#[test]
fn german_der_nominative_masculine() {
    let phrase = Phrase::builder()
        .text("Charakter".to_string())
        .tags(vec!["masc".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::GermanDer;
    let result = transform.execute(&value, None, "de").unwrap();
    assert_eq!(result, "der Charakter");
}

#[test]
fn german_der_accusative_masculine() {
    let phrase = Phrase::builder()
        .text("Charakter".to_string())
        .tags(vec!["masc".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let context = Value::String("acc".to_string());
    let transform = TransformKind::GermanDer;
    let result = transform.execute(&value, Some(&context), "de").unwrap();
    assert_eq!(result, "den Charakter");
}

#[test]
fn german_der_dative_feminine() {
    let phrase = Phrase::builder()
        .text("Karte".to_string())
        .tags(vec!["fem".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let context = Value::String("dat".to_string());
    let transform = TransformKind::GermanDer;
    let result = transform.execute(&value, Some(&context), "de").unwrap();
    assert_eq!(result, "der Karte");  // feminine dative = "der"
}

#[test]
fn german_der_neuter() {
    let phrase = Phrase::builder()
        .text("Ereignis".to_string())
        .tags(vec!["neut".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::GermanDer;
    let result = transform.execute(&value, None, "de").unwrap();
    assert_eq!(result, "das Ereignis");
}

#[test]
fn german_ein_accusative_masculine() {
    let phrase = Phrase::builder()
        .text("Charakter".to_string())
        .tags(vec!["masc".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let context = Value::String("acc".to_string());
    let transform = TransformKind::GermanEin;
    let result = transform.execute(&value, Some(&context), "de").unwrap();
    assert_eq!(result, "einen Charakter");
}

#[test]
fn german_ein_nominative_feminine() {
    let phrase = Phrase::builder()
        .text("Karte".to_string())
        .tags(vec!["fem".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::GermanEin;
    let result = transform.execute(&value, None, "de").unwrap();
    assert_eq!(result, "eine Karte");
}

#[test]
fn german_der_missing_gender_error() {
    let phrase = Phrase::builder()
        .text("Ding".to_string())
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::GermanDer;
    let result = transform.execute(&value, None, "de");
    assert!(matches!(result, Err(EvalError::MissingTag { .. })));
}

#[test]
fn german_transform_aliases() {
    let registry = TransformRegistry::new();
    assert_eq!(registry.get("die", "de"), Some(TransformKind::GermanDer));
    assert_eq!(registry.get("das", "de"), Some(TransformKind::GermanDer));
    assert_eq!(registry.get("eine", "de"), Some(TransformKind::GermanEin));
}
```

GREEN phase - Implement transforms:

1. Add enum variants:
```rust
// German transforms (Phase 6)
GermanDer,   // @der/@die/@das - definite article with case context
GermanEin,   // @ein/@eine - indefinite article with case context
```

2. Add helper types and lookup tables:
```rust
#[derive(Clone, Copy)]
enum GermanGender {
    Masculine,
    Feminine,
    Neuter,
}

#[derive(Clone, Copy)]
enum GermanCase {
    Nominative,
    Accusative,
    Dative,
    Genitive,
}

fn parse_german_gender(value: &Value) -> Option<GermanGender> {
    if value.has_tag("masc") {
        Some(GermanGender::Masculine)
    } else if value.has_tag("fem") {
        Some(GermanGender::Feminine)
    } else if value.has_tag("neut") {
        Some(GermanGender::Neuter)
    } else {
        None
    }
}

fn parse_german_case(context: Option<&Value>) -> GermanCase {
    match context {
        Some(Value::String(s)) => match s.as_str() {
            "acc" => GermanCase::Accusative,
            "dat" => GermanCase::Dative,
            "gen" => GermanCase::Genitive,
            _ => GermanCase::Nominative,
        },
        _ => GermanCase::Nominative,
    }
}

fn german_definite_article(gender: GermanGender, case: GermanCase) -> &'static str {
    match (gender, case) {
        // Masculine
        (GermanGender::Masculine, GermanCase::Nominative) => "der",
        (GermanGender::Masculine, GermanCase::Accusative) => "den",
        (GermanGender::Masculine, GermanCase::Dative) => "dem",
        (GermanGender::Masculine, GermanCase::Genitive) => "des",
        // Feminine
        (GermanGender::Feminine, GermanCase::Nominative) => "die",
        (GermanGender::Feminine, GermanCase::Accusative) => "die",
        (GermanGender::Feminine, GermanCase::Dative) => "der",
        (GermanGender::Feminine, GermanCase::Genitive) => "der",
        // Neuter
        (GermanGender::Neuter, GermanCase::Nominative) => "das",
        (GermanGender::Neuter, GermanCase::Accusative) => "das",
        (GermanGender::Neuter, GermanCase::Dative) => "dem",
        (GermanGender::Neuter, GermanCase::Genitive) => "des",
    }
}

fn german_indefinite_article(gender: GermanGender, case: GermanCase) -> &'static str {
    match (gender, case) {
        // Masculine
        (GermanGender::Masculine, GermanCase::Nominative) => "ein",
        (GermanGender::Masculine, GermanCase::Accusative) => "einen",
        (GermanGender::Masculine, GermanCase::Dative) => "einem",
        (GermanGender::Masculine, GermanCase::Genitive) => "eines",
        // Feminine
        (GermanGender::Feminine, GermanCase::Nominative) => "eine",
        (GermanGender::Feminine, GermanCase::Accusative) => "eine",
        (GermanGender::Feminine, GermanCase::Dative) => "einer",
        (GermanGender::Feminine, GermanCase::Genitive) => "einer",
        // Neuter
        (GermanGender::Neuter, GermanCase::Nominative) => "ein",
        (GermanGender::Neuter, GermanCase::Accusative) => "ein",
        (GermanGender::Neuter, GermanCase::Dative) => "einem",
        (GermanGender::Neuter, GermanCase::Genitive) => "eines",
    }
}
```

3. Implement transform functions:
```rust
fn german_der_transform(value: &Value, context: Option<&Value>) -> Result<String, EvalError> {
    let text = value.to_string();
    let gender = parse_german_gender(value).ok_or_else(|| EvalError::MissingTag {
        transform: "der".to_string(),
        expected: vec!["masc".to_string(), "fem".to_string(), "neut".to_string()],
        phrase: text.clone(),
    })?;
    let case = parse_german_case(context);
    let article = german_definite_article(gender, case);
    Ok(format!("{} {}", article, text))
}

fn german_ein_transform(value: &Value, context: Option<&Value>) -> Result<String, EvalError> {
    let text = value.to_string();
    let gender = parse_german_gender(value).ok_or_else(|| EvalError::MissingTag {
        transform: "ein".to_string(),
        expected: vec!["masc".to_string(), "fem".to_string(), "neut".to_string()],
        phrase: text.clone(),
    })?;
    let case = parse_german_case(context);
    let article = german_indefinite_article(gender, case);
    Ok(format!("{} {}", article, text))
}
```

4. Update execute() match:
```rust
TransformKind::GermanDer => german_der_transform(value, context),
TransformKind::GermanEin => german_ein_transform(value, context),
```

5. Update TransformRegistry::get() with German aliases:
```rust
// Resolve aliases
let canonical = match name {
    "an" => "a",
    "die" | "das" => "der",
    "eine" => "ein",
    other => other,
};

// Language-specific transforms
match (lang, canonical) {
    ("en", "a") => Some(TransformKind::EnglishA),
    ("en", "the") => Some(TransformKind::EnglishThe),
    ("de", "der") => Some(TransformKind::GermanDer),
    ("de", "ein") => Some(TransformKind::GermanEin),
    _ => None,
}
```
  </action>
  <verify>Run `cargo test -p rlf german` to run German transform tests. All should pass.</verify>
  <done>GermanDer and GermanEin variants exist, case lookup tables work, aliases resolve correctly</done>
</task>

<task type="auto">
  <name>Task 3: German integration tests</name>
  <files>crates/rlf/tests/interpreter_transforms.rs</files>
  <action>
Add integration tests that exercise full evaluation with German transforms:

```rust
#[test]
fn german_der_in_template() {
    let source = r#"
        karte = :fem "Karte";
        charakter = :masc "Charakter";
        ereignis = :neut "Ereignis";
        the_card = "{@der karte}";
        the_char = "{@der charakter}";
        the_event = "{@das ereignis}";
    "#;

    let mut locale = Locale::builder().language("de").build();
    locale.load_translations_from_str("de", source).unwrap();

    assert_eq!(
        locale.eval_phrase("de", "the_card", &[]).unwrap(),
        "die Karte"
    );
    assert_eq!(
        locale.eval_phrase("de", "the_char", &[]).unwrap(),
        "der Charakter"
    );
    assert_eq!(
        locale.eval_phrase("de", "the_event", &[]).unwrap(),
        "das Ereignis"
    );
}

#[test]
fn german_der_with_case_context() {
    // Test: "Zerstöre {@der:acc karte}." - accusative case
    let source = r#"
        karte = :fem "Karte";
        charakter = :masc "Charakter";
        destroy_card = "Zerstöre {@der:acc karte}.";
        destroy_char = "Zerstöre {@der:acc charakter}.";
    "#;

    let mut locale = Locale::builder().language("de").build();
    locale.load_translations_from_str("de", source).unwrap();

    // Feminine accusative = "die", masculine accusative = "den"
    assert_eq!(
        locale.eval_phrase("de", "destroy_card", &[]).unwrap(),
        "Zerstöre die Karte."
    );
    assert_eq!(
        locale.eval_phrase("de", "destroy_char", &[]).unwrap(),
        "Zerstöre den Charakter."
    );
}

#[test]
fn german_ein_in_template() {
    let source = r#"
        karte = :fem "Karte";
        charakter = :masc "Charakter";
        a_card = "{@ein karte}";
        a_char = "{@ein:acc charakter}";
    "#;

    let mut locale = Locale::builder().language("de").build();
    locale.load_translations_from_str("de", source).unwrap();

    assert_eq!(
        locale.eval_phrase("de", "a_card", &[]).unwrap(),
        "eine Karte"
    );
    assert_eq!(
        locale.eval_phrase("de", "a_char", &[]).unwrap(),
        "einen Charakter"
    );
}

#[test]
fn german_dative_case() {
    // Test dative case for prepositions like "mit" (with)
    let source = r#"
        karte = :fem "Karte";
        charakter = :masc "Charakter";
        with_card = "mit {@der:dat karte}";
        with_char = "mit {@ein:dat charakter}";
    "#;

    let mut locale = Locale::builder().language("de").build();
    locale.load_translations_from_str("de", source).unwrap();

    // Feminine dative definite = "der", masculine dative indefinite = "einem"
    assert_eq!(
        locale.eval_phrase("de", "with_card", &[]).unwrap(),
        "mit der Karte"
    );
    assert_eq!(
        locale.eval_phrase("de", "with_char", &[]).unwrap(),
        "mit einem Charakter"
    );
}
```
  </action>
  <verify>Run `cargo test -p rlf` - all tests pass. Run `just review` for code quality.</verify>
  <done>Integration tests verify German transforms work with case context in full evaluation</done>
</task>

</tasks>

<verification>
1. `cargo check -p rlf` compiles without errors
2. `cargo test -p rlf` passes all tests (existing + new)
3. `cargo test -p rlf german` shows German-specific tests passing
4. `just review` passes all lints
</verification>

<success_criteria>
- GermanDer and GermanEin variants added to TransformKind enum
- @der transform reads :masc/:fem/:neut tags and case context
- @ein transform reads gender tags and case context
- All 12 definite article forms correct (4 cases x 3 genders)
- All 12 indefinite article forms correct
- Default to nominative when no case context provided
- Transform aliases @die, @das resolve to @der; @eine resolves to @ein
- MissingTag error when gender tags absent
- Context resolution in evaluator passes case parameter to transforms
</success_criteria>

<output>
After completion, create `.planning/phases/06-english-and-germanic-transforms/06-02-SUMMARY.md`
</output>
