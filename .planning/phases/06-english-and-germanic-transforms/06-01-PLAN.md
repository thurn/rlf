---
phase: 06-english-and-germanic-transforms
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/rlf/src/interpreter/transforms.rs
  - crates/rlf/src/interpreter/evaluator.rs
  - crates/rlf/tests/interpreter_transforms.rs
autonomous: true

must_haves:
  truths:
    - "English @a transform prepends 'a' when phrase has :a tag"
    - "English @a transform prepends 'an' when phrase has :an tag"
    - "English @a transform returns MissingTag error when neither tag present"
    - "English @the transform prepends 'the' unconditionally"
    - "Transform aliases @an resolves to @a"
  artifacts:
    - path: "crates/rlf/src/interpreter/transforms.rs"
      provides: "EnglishA and EnglishThe variants in TransformKind"
      contains: "EnglishA"
    - path: "crates/rlf/tests/interpreter_transforms.rs"
      provides: "Tests for English article transforms"
      contains: "english_a_with_a_tag"
  key_links:
    - from: "crates/rlf/src/interpreter/evaluator.rs"
      to: "TransformKind::execute"
      via: "apply_transforms passes Value to execute"
      pattern: "transform_kind\\.execute\\(&selected_value"
    - from: "crates/rlf/src/interpreter/transforms.rs"
      to: "Value::has_tag"
      via: "EnglishA checks tags"
      pattern: "value\\.has_tag"
---

<objective>
Implement English article transforms (@a/@an and @the) with proper Value-based tag reading.

Purpose: Enable English indefinite and definite article selection based on phrase metadata tags, following the tag-based approach from DESIGN.md (no phonetic guessing).

Output: Working @a, @an, @the transforms for English with comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-english-and-germanic-transforms/06-RESEARCH.md
@docs/DESIGN.md (transforms section)
@docs/APPENDIX_STDLIB.md (English section)
@crates/rlf/src/interpreter/transforms.rs
@crates/rlf/src/interpreter/evaluator.rs
@crates/rlf/src/types/value.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1a: Modify apply_selectors to return Value</name>
  <files>crates/rlf/src/interpreter/evaluator.rs</files>
  <action>
Update `apply_selectors` to return `Result<Value, EvalError>` instead of `Result<String, EvalError>`:

1. Change the function signature:
   - From: `fn apply_selectors(value: &Value, selectors: &[Selector], ctx: &EvalContext<'_>, lang: &str) -> Result<String, EvalError>`
   - To: `fn apply_selectors(value: &Value, selectors: &[Selector], ctx: &EvalContext<'_>, lang: &str) -> Result<Value, EvalError>`

2. Update the return logic:
   - If selectors are empty, return `Ok(value.clone())` - preserving the original Value type
   - If selectors are present (variant lookup), return `Ok(Value::String(variant_text))`

3. Update the call site in `eval_template` temporarily to convert the result:
   ```rust
   let selected = apply_selectors(&value, selectors, ctx, lang)?;
   let transformed = apply_transforms(&selected.to_string(), transforms, transform_registry, lang)?;
   ```
   (This intermediate step will be fixed in Task 1b)
  </action>
  <verify>Run `cargo check -p rlf` to ensure it compiles. Run `cargo test -p rlf` - existing tests should still pass since we're calling to_string() at the call site.</verify>
  <done>apply_selectors returns Result<Value, EvalError>, preserving Phrase type when no selectors present</done>
</task>

<task type="auto">
  <name>Task 1b: Modify apply_transforms to accept Value</name>
  <files>crates/rlf/src/interpreter/evaluator.rs</files>
  <action>
Update `apply_transforms` to work with `Value` instead of `&str`:

1. Change the function signature:
   - From: `fn apply_transforms(initial_value: &str, transforms: &[Transform], transform_registry: &TransformRegistry, lang: &str) -> Result<String, EvalError>`
   - To: `fn apply_transforms(initial_value: &Value, transforms: &[Transform], transform_registry: &TransformRegistry, lang: &str) -> Result<String, EvalError>`

2. Update the function body:
   ```rust
   fn apply_transforms(
       initial_value: &Value,
       transforms: &[Transform],
       transform_registry: &TransformRegistry,
       lang: &str,
   ) -> Result<String, EvalError> {
       if transforms.is_empty() {
           return Ok(initial_value.to_string());
       }

       let mut current = initial_value.clone();

       for transform in transforms.iter().rev() {
           let transform_kind = transform_registry
               .get(&transform.name, lang)
               .ok_or_else(|| EvalError::UnknownTransform {
                   name: transform.name.clone(),
               })?;

           // Pass full Value to transform so it can read tags
           let result = transform_kind.execute(&current, None, lang)?;
           // After transform, result is String - wrap for next iteration
           current = Value::String(result);
       }

       Ok(current.to_string())
   }
   ```

3. Update the call site in `eval_template` to pass the Value directly:
   ```rust
   let selected = apply_selectors(&value, selectors, ctx, lang)?;
   let transformed = apply_transforms(&selected, transforms, transform_registry, lang)?;
   ```

Key insight: The first transform in the chain receives the original Value (possibly a Phrase with tags). After each transform executes, the result is wrapped as Value::String for subsequent transforms.
  </action>
  <verify>Run `cargo check -p rlf` to ensure it compiles. Run `cargo test -p rlf` - all existing tests pass. Add a quick test to verify Value is passed: add a debug println in transform execute and confirm Phrase type is received.</verify>
  <done>apply_transforms receives Value and passes it to transform execute method; transforms can now access tags on the first call</done>
</task>

<task type="auto">
  <name>Task 2: Add English transforms with TDD</name>
  <files>crates/rlf/src/interpreter/transforms.rs, crates/rlf/tests/interpreter_transforms.rs</files>
  <action>
RED phase - Write failing tests first:

In `crates/rlf/tests/interpreter_transforms.rs`, add tests:

```rust
// English @a transform tests
#[test]
fn english_a_with_a_tag() {
    // Phrase with :a tag produces "a card"
    let phrase = Phrase::builder()
        .text("card".to_string())
        .tags(vec!["a".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::EnglishA;
    let result = transform.execute(&value, None, "en").unwrap();
    assert_eq!(result, "a card");
}

#[test]
fn english_a_with_an_tag() {
    // Phrase with :an tag produces "an event"
    let phrase = Phrase::builder()
        .text("event".to_string())
        .tags(vec!["an".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::EnglishA;
    let result = transform.execute(&value, None, "en").unwrap();
    assert_eq!(result, "an event");
}

#[test]
fn english_a_missing_tag_error() {
    // Phrase without :a or :an tag produces error
    let phrase = Phrase::builder()
        .text("thing".to_string())
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::EnglishA;
    let result = transform.execute(&value, None, "en");
    assert!(matches!(result, Err(EvalError::MissingTag { .. })));
}

#[test]
fn english_the_transform() {
    // @the always produces "the X"
    let value = Value::String("card".to_string());
    let transform = TransformKind::EnglishThe;
    let result = transform.execute(&value, None, "en").unwrap();
    assert_eq!(result, "the card");
}

#[test]
fn english_transform_alias_an() {
    // @an resolves to EnglishA
    let registry = TransformRegistry::new();
    let transform = registry.get("an", "en");
    assert_eq!(transform, Some(TransformKind::EnglishA));
}
```

GREEN phase - Implement transforms:

In `crates/rlf/src/interpreter/transforms.rs`:

1. Add enum variants:
```rust
pub enum TransformKind {
    Cap,
    Upper,
    Lower,
    // English transforms (Phase 6)
    EnglishA,    // @a/@an - indefinite article from :a/:an tags
    EnglishThe,  // @the - definite article "the"
}
```

2. Implement in `execute()`:
```rust
TransformKind::EnglishA => english_a_transform(value),
TransformKind::EnglishThe => english_the_transform(value),
```

3. Add helper functions:
```rust
fn english_a_transform(value: &Value) -> Result<String, EvalError> {
    let text = value.to_string();

    if value.has_tag("a") {
        return Ok(format!("a {}", text));
    }
    if value.has_tag("an") {
        return Ok(format!("an {}", text));
    }

    Err(EvalError::MissingTag {
        transform: "a".to_string(),
        expected: vec!["a".to_string(), "an".to_string()],
        phrase: text,
    })
}

fn english_the_transform(value: &Value) -> Result<String, EvalError> {
    Ok(format!("the {}", value.to_string()))
}
```

4. Update `TransformRegistry::get()` with aliases:
```rust
pub fn get(&self, name: &str, lang: &str) -> Option<TransformKind> {
    // Resolve aliases first
    let canonical = match name {
        "an" => "a",  // English alias
        other => other,
    };

    // Universal transforms (always available)
    match canonical {
        "cap" => return Some(TransformKind::Cap),
        "upper" => return Some(TransformKind::Upper),
        "lower" => return Some(TransformKind::Lower),
        _ => {}
    }

    // Language-specific transforms
    match (lang, canonical) {
        ("en", "a") => Some(TransformKind::EnglishA),
        ("en", "the") => Some(TransformKind::EnglishThe),
        _ => None,
    }
}
```
  </action>
  <verify>Run `cargo test -p rlf english` to run English transform tests. All should pass.</verify>
  <done>EnglishA and EnglishThe variants exist, tests pass, @an alias resolves to @a</done>
</task>

<task type="auto">
  <name>Task 3: Integration tests with full evaluation</name>
  <files>crates/rlf/tests/interpreter_transforms.rs</files>
  <action>
Add integration tests that exercise the full evaluation path with English transforms:

```rust
#[test]
fn english_a_in_template() {
    // Test: "Draw {@a card}." with card = :a "card"
    let source = r#"
        card = :a "card";
        event = :an "event";
        draw_card = "Draw {@a card}.";
        play_event = "Play {@a event}.";
        the_card = "{@the card}";
    "#;

    let mut locale = Locale::builder().language("en").build();
    locale.load_translations_from_str("en", source).unwrap();

    assert_eq!(
        locale.eval_phrase("en", "draw_card", &[]).unwrap(),
        "Draw a card."
    );
    assert_eq!(
        locale.eval_phrase("en", "play_event", &[]).unwrap(),
        "Play an event."
    );
    assert_eq!(
        locale.eval_phrase("en", "the_card", &[]).unwrap(),
        "the card"
    );
}

#[test]
fn english_a_with_cap() {
    // Test transform ordering: {@cap @a card} -> "A card"
    let source = r#"
        card = :a "card";
        a_card = "{@cap @a card}";
    "#;

    let mut locale = Locale::builder().language("en").build();
    locale.load_translations_from_str("en", source).unwrap();

    // Right-to-left: @a first ("a card"), then @cap ("A card")
    assert_eq!(
        locale.eval_phrase("en", "a_card", &[]).unwrap(),
        "A card"
    );
}

#[test]
fn english_a_missing_tag_full_eval() {
    // Test error when tag missing in full evaluation
    let source = r#"
        thing = "thing";
        draw_thing = "Draw {@a thing}.";
    "#;

    let mut locale = Locale::builder().language("en").build();
    locale.load_translations_from_str("en", source).unwrap();

    let result = locale.eval_phrase("en", "draw_thing", &[]);
    assert!(matches!(result, Err(EvalError::MissingTag { .. })));
}
```

Ensure tests use the public API pattern established in Phase 4 (Locale struct).
  </action>
  <verify>Run `cargo test -p rlf` - all tests pass including new integration tests. Run `just review` for code quality.</verify>
  <done>Integration tests verify full evaluation path with English transforms works correctly</done>
</task>

</tasks>

<verification>
1. `cargo check -p rlf` compiles without errors
2. `cargo test -p rlf` passes all tests (existing + new)
3. `cargo test -p rlf english` shows English-specific tests passing
4. `just review` passes all lints
</verification>

<success_criteria>
- EnglishA and EnglishThe variants added to TransformKind enum
- @a transform reads :a/:an tags and prepends correct article
- @the transform unconditionally prepends "the"
- @an alias resolves to @a in TransformRegistry
- MissingTag error when :a/:an tags absent
- Transform execution receives Value (not String) for tag access
- Integration tests verify full evaluation path
</success_criteria>

<output>
After completion, create `.planning/phases/06-english-and-germanic-transforms/06-01-SUMMARY.md`
</output>
