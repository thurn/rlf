---
phase: 07-romance-language-transforms
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/rlf/src/interpreter/transforms.rs
  - crates/rlf/tests/interpreter_transforms.rs
autonomous: true

must_haves:
  truths:
    - "French @le handles elision from :vowel tag (l'ami not le ami)"
    - "French @un selects indefinite article by :masc/:fem tags"
    - "French @de produces contraction (du/de la/de l'/des)"
    - "French @au produces contraction (au/a la/a l'/aux)"
    - "French @liaison selects prevocalic form based on :vowel tag"
    - "Italian @il handles three sound categories (normal/vowel/s_imp)"
    - "Italian @un handles sound-based forms (un/uno/una/un')"
    - "Italian @di produces contraction (del/dello/della/dell'/dei/degli/delle)"
    - "Italian @a produces contraction (al/allo/alla/all'/ai/agli/alle)"
    - "Missing gender tag produces MissingTag error"
  artifacts:
    - path: "crates/rlf/src/interpreter/transforms.rs"
      provides: "French and Italian transform variants with elision/sound rules"
      contains: "FrenchLe"
    - path: "crates/rlf/tests/interpreter_transforms.rs"
      provides: "Tests for French and Italian transforms including elision"
      contains: "french_le_elision"
  key_links:
    - from: "crates/rlf/src/interpreter/transforms.rs"
      to: "french_definite_article"
      via: "FrenchLe uses elision-aware lookup"
      pattern: "french_definite_article\\(gender, has_vowel, plural\\)"
    - from: "crates/rlf/src/interpreter/transforms.rs"
      to: "italian_definite_article"
      via: "ItalianIl uses sound-based lookup"
      pattern: "italian_definite_article\\(gender, sound, plural\\)"
---

<objective>
Implement French and Italian article and contraction transforms with elision/sound rules.

Purpose: Enable French and Italian article selection with complex elision and sound-based rules. French has elision before vowels (l'ami). Italian has three-way sound distinction (il/l'/lo based on normal/vowel/s_imp). Both languages have preposition+article contractions.

Output: Working @le, @un, @de, @au, @liaison (French), @il, @un, @di, @a (Italian) transforms with comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-romance-language-transforms/07-RESEARCH.md
@docs/APPENDIX_STDLIB.md (French and Italian sections)
@crates/rlf/src/interpreter/transforms.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add French transforms with elision</name>
  <files>crates/rlf/src/interpreter/transforms.rs, crates/rlf/tests/interpreter_transforms.rs</files>
  <action>
Add French article and contraction transforms with elision handling.

**Important:** This task assumes RomanceGender and parse_romance_gender/parse_romance_plural helpers exist from Plan 07-01. If executing in parallel, define them here if not present.

1. Add enum variants to TransformKind:
```rust
// French transforms (Phase 7)
/// @le/@la - French definite article with elision
FrenchLe,
/// @un/@une - French indefinite article
FrenchUn,
/// @de - French "de" + article contraction
FrenchDe,
/// @au - French "a" + article contraction
FrenchAu,
/// @liaison - French prevocalic form selection
FrenchLiaison,
```

2. Add French lookup tables:
```rust
// =============================================================================
// French Transforms (Phase 7)
// =============================================================================

/// French definite article lookup table with elision support.
/// Elision produces l' before vowels (singular only).
fn french_definite_article(
    gender: RomanceGender,
    has_vowel: bool,
    plural: RomancePlural,
) -> &'static str {
    match (gender, has_vowel, plural) {
        // Elision before vowel (singular only)
        (_, true, RomancePlural::One) => "l'",
        // Masculine singular
        (RomanceGender::Masculine, false, RomancePlural::One) => "le",
        // Feminine singular
        (RomanceGender::Feminine, false, RomancePlural::One) => "la",
        // Plural (same for both genders, no elision)
        (_, _, RomancePlural::Other) => "les",
    }
}

/// French indefinite article lookup table.
/// No plural forms per APPENDIX_STDLIB.
fn french_indefinite_article(gender: RomanceGender) -> &'static str {
    match gender {
        RomanceGender::Masculine => "un",
        RomanceGender::Feminine => "une",
    }
}

/// French "de" + article contraction lookup table with elision.
fn french_de_contraction(
    gender: RomanceGender,
    has_vowel: bool,
    plural: RomancePlural,
) -> &'static str {
    match (gender, has_vowel, plural) {
        // Elision: de + l' -> de l' (no contraction, but elided article)
        (_, true, RomancePlural::One) => "de l'",
        // Masculine singular: de + le -> du
        (RomanceGender::Masculine, false, RomancePlural::One) => "du",
        // Feminine singular: de + la -> de la (no contraction)
        (RomanceGender::Feminine, false, RomancePlural::One) => "de la",
        // Plural: de + les -> des
        (_, _, RomancePlural::Other) => "des",
    }
}

/// French "a" + article contraction lookup table with elision.
fn french_au_contraction(
    gender: RomanceGender,
    has_vowel: bool,
    plural: RomancePlural,
) -> &'static str {
    match (gender, has_vowel, plural) {
        // Elision: a + l' -> a l' (no contraction, but elided article)
        (_, true, RomancePlural::One) => "a l'",
        // Masculine singular: a + le -> au
        (RomanceGender::Masculine, false, RomancePlural::One) => "au",
        // Feminine singular: a + la -> a la (no contraction)
        (RomanceGender::Feminine, false, RomancePlural::One) => "a la",
        // Plural: a + les -> aux
        (_, _, RomancePlural::Other) => "aux",
    }
}

/// French definite article transform (@le/@la).
/// Handles elision before vowels via :vowel tag.
fn french_le_transform(value: &Value, context: Option<&Value>) -> Result<String, EvalError> {
    let text = value.to_string();
    let gender = parse_romance_gender(value, "le")?;
    let has_vowel = value.has_tag("vowel");
    let plural = parse_romance_plural(context);
    let article = french_definite_article(gender, has_vowel, plural);

    // Elided article (l') attaches directly, no space
    if article.ends_with('\'') {
        Ok(format!("{}{}", article, text))
    } else {
        Ok(format!("{} {}", article, text))
    }
}

/// French indefinite article transform (@un/@une).
fn french_un_transform(value: &Value) -> Result<String, EvalError> {
    let text = value.to_string();
    let gender = parse_romance_gender(value, "un")?;
    let article = french_indefinite_article(gender);
    Ok(format!("{} {}", article, text))
}

/// French "de" + article contraction transform (@de).
fn french_de_transform(value: &Value, context: Option<&Value>) -> Result<String, EvalError> {
    let text = value.to_string();
    let gender = parse_romance_gender(value, "de")?;
    let has_vowel = value.has_tag("vowel");
    let plural = parse_romance_plural(context);
    let contracted = french_de_contraction(gender, has_vowel, plural);

    // "de l'" has apostrophe - attach directly
    if contracted.ends_with('\'') {
        Ok(format!("{}{}", contracted, text))
    } else {
        Ok(format!("{} {}", contracted, text))
    }
}

/// French "a" + article contraction transform (@au).
fn french_au_transform(value: &Value, context: Option<&Value>) -> Result<String, EvalError> {
    let text = value.to_string();
    let gender = parse_romance_gender(value, "au")?;
    let has_vowel = value.has_tag("vowel");
    let plural = parse_romance_plural(context);
    let contracted = french_au_contraction(gender, has_vowel, plural);

    // "a l'" has apostrophe - attach directly
    if contracted.ends_with('\'') {
        Ok(format!("{}{}", contracted, text))
    } else {
        Ok(format!("{} {}", contracted, text))
    }
}

/// French liaison transform (@liaison).
/// Selects between standard and prevocalic forms based on :vowel tag.
/// The input value should have variants "standard" and "vowel".
fn french_liaison_transform(value: &Value, context: Option<&Value>) -> Result<String, EvalError> {
    // Context should be a phrase with :vowel tag (or not)
    let has_vowel = match context {
        Some(v) => v.has_tag("vowel"),
        None => false,
    };

    // Select the appropriate variant from the liaison word
    let variant_key = if has_vowel { "vowel" } else { "standard" };

    // Try to get the variant from the value
    if let Value::Phrase(phrase) = value {
        if let Some(variant_text) = phrase.variants.get(variant_key) {
            // Need to also output the context word
            if let Some(ctx_value) = context {
                return Ok(format!("{} {}", variant_text, ctx_value));
            } else {
                return Ok(variant_text.clone());
            }
        }
    }

    // Fallback: just use the text as-is
    let text = value.to_string();
    if let Some(ctx_value) = context {
        Ok(format!("{} {}", text, ctx_value))
    } else {
        Ok(text)
    }
}
```

3. Update execute() match:
```rust
TransformKind::FrenchLe => french_le_transform(value, context),
TransformKind::FrenchUn => french_un_transform(value),
TransformKind::FrenchDe => french_de_transform(value, context),
TransformKind::FrenchAu => french_au_transform(value, context),
TransformKind::FrenchLiaison => french_liaison_transform(value, context),
```

4. Update TransformRegistry::get() with French:
```rust
// In alias resolution section:
"la" if lang == "fr" => "le",   // French alias
"une" => "un",                   // French alias (shared)

// In language-specific match:
("fr", "le") => Some(TransformKind::FrenchLe),
("fr", "un") => Some(TransformKind::FrenchUn),
("fr", "de") => Some(TransformKind::FrenchDe),
("fr", "au") => Some(TransformKind::FrenchAu),
("fr", "liaison") => Some(TransformKind::FrenchLiaison),
```

5. Add French tests:
```rust
// =============================================================================
// French Transform Tests (Phase 7)
// =============================================================================

#[test]
fn french_le_masculine_no_elision() {
    let phrase = Phrase::builder()
        .text("livre".to_string())
        .tags(vec!["masc".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::FrenchLe;
    let result = transform.execute(&value, None, "fr").unwrap();
    assert_eq!(result, "le livre");
}

#[test]
fn french_le_feminine_no_elision() {
    let phrase = Phrase::builder()
        .text("carte".to_string())
        .tags(vec!["fem".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::FrenchLe;
    let result = transform.execute(&value, None, "fr").unwrap();
    assert_eq!(result, "la carte");
}

#[test]
fn french_le_elision_masculine() {
    let phrase = Phrase::builder()
        .text("ennemi".to_string())
        .tags(vec!["masc".to_string(), "vowel".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::FrenchLe;
    let result = transform.execute(&value, None, "fr").unwrap();
    assert_eq!(result, "l'ennemi");  // No space after apostrophe
}

#[test]
fn french_le_elision_feminine() {
    let phrase = Phrase::builder()
        .text("amie".to_string())
        .tags(vec!["fem".to_string(), "vowel".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::FrenchLe;
    let result = transform.execute(&value, None, "fr").unwrap();
    assert_eq!(result, "l'amie");
}

#[test]
fn french_le_plural_no_elision() {
    // Plural never elides
    let phrase = Phrase::builder()
        .text("ennemis".to_string())
        .tags(vec!["masc".to_string(), "vowel".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let context = Value::String("other".to_string());
    let transform = TransformKind::FrenchLe;
    let result = transform.execute(&value, Some(&context), "fr").unwrap();
    assert_eq!(result, "les ennemis");  // No elision in plural
}

#[test]
fn french_un_masculine() {
    let phrase = Phrase::builder()
        .text("livre".to_string())
        .tags(vec!["masc".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::FrenchUn;
    let result = transform.execute(&value, None, "fr").unwrap();
    assert_eq!(result, "un livre");
}

#[test]
fn french_un_feminine() {
    let phrase = Phrase::builder()
        .text("carte".to_string())
        .tags(vec!["fem".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::FrenchUn;
    let result = transform.execute(&value, None, "fr").unwrap();
    assert_eq!(result, "une carte");
}

#[test]
fn french_de_contraction_masculine() {
    let phrase = Phrase::builder()
        .text("vide".to_string())
        .tags(vec!["masc".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::FrenchDe;
    let result = transform.execute(&value, None, "fr").unwrap();
    assert_eq!(result, "du vide");  // de + le = du
}

#[test]
fn french_de_contraction_feminine() {
    let phrase = Phrase::builder()
        .text("main".to_string())
        .tags(vec!["fem".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::FrenchDe;
    let result = transform.execute(&value, None, "fr").unwrap();
    assert_eq!(result, "de la main");  // No contraction
}

#[test]
fn french_de_elision() {
    let phrase = Phrase::builder()
        .text("ennemi".to_string())
        .tags(vec!["masc".to_string(), "vowel".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::FrenchDe;
    let result = transform.execute(&value, None, "fr").unwrap();
    assert_eq!(result, "de l'ennemi");  // de + l' (elided)
}

#[test]
fn french_de_plural() {
    let phrase = Phrase::builder()
        .text("cartes".to_string())
        .tags(vec!["fem".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let context = Value::String("other".to_string());
    let transform = TransformKind::FrenchDe;
    let result = transform.execute(&value, Some(&context), "fr").unwrap();
    assert_eq!(result, "des cartes");  // de + les = des
}

#[test]
fn french_au_contraction_masculine() {
    let phrase = Phrase::builder()
        .text("marche".to_string())
        .tags(vec!["masc".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::FrenchAu;
    let result = transform.execute(&value, None, "fr").unwrap();
    assert_eq!(result, "au marche");  // a + le = au
}

#[test]
fn french_au_contraction_feminine() {
    let phrase = Phrase::builder()
        .text("main".to_string())
        .tags(vec!["fem".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::FrenchAu;
    let result = transform.execute(&value, None, "fr").unwrap();
    assert_eq!(result, "a la main");  // No contraction
}

#[test]
fn french_au_elision() {
    let phrase = Phrase::builder()
        .text("ami".to_string())
        .tags(vec!["masc".to_string(), "vowel".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::FrenchAu;
    let result = transform.execute(&value, None, "fr").unwrap();
    assert_eq!(result, "a l'ami");  // a + l' (elided)
}

#[test]
fn french_au_plural() {
    let phrase = Phrase::builder()
        .text("marches".to_string())
        .tags(vec!["masc".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let context = Value::String("other".to_string());
    let transform = TransformKind::FrenchAu;
    let result = transform.execute(&value, Some(&context), "fr").unwrap();
    assert_eq!(result, "aux marches");  // a + les = aux
}

#[test]
fn french_le_missing_gender() {
    let phrase = Phrase::builder()
        .text("chose".to_string())
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::FrenchLe;
    let result = transform.execute(&value, None, "fr");
    assert!(matches!(result, Err(EvalError::MissingTag { .. })));
}

#[test]
fn french_transform_aliases() {
    let registry = TransformRegistry::new();
    assert_eq!(registry.get("la", "fr"), Some(TransformKind::FrenchLe));
    assert_eq!(registry.get("une", "fr"), Some(TransformKind::FrenchUn));
}
```
  </action>
  <verify>Run `cargo test -p rlf french` to run French transform tests. All should pass.</verify>
  <done>FrenchLe, FrenchUn, FrenchDe, FrenchAu, FrenchLiaison variants exist, elision handling works</done>
</task>

<task type="auto">
  <name>Task 2: Add Italian transforms with sound rules</name>
  <files>crates/rlf/src/interpreter/transforms.rs, crates/rlf/tests/interpreter_transforms.rs</files>
  <action>
Add Italian article and contraction transforms with sound-based rules.

1. Add enum variants to TransformKind:
```rust
// Italian transforms (Phase 7)
/// @il/@lo/@la - Italian definite article with sound rules
ItalianIl,
/// @un/@uno/@una - Italian indefinite article with sound rules
ItalianUn,
/// @di - Italian "di" + article contraction
ItalianDi,
/// @a - Italian "a" + article contraction
ItalianA,
```

2. Add Italian helper types and lookup tables:
```rust
// =============================================================================
// Italian Transforms (Phase 7)
// =============================================================================

/// Italian sound category for article selection.
#[derive(Clone, Copy)]
enum ItalianSound {
    /// Standard consonant (il, un, del, al)
    Normal,
    /// Starts with vowel (l', un, dell', all')
    Vowel,
    /// Starts with s+consonant, z, gn, ps, x (lo, uno, dello, allo)
    SImpura,
}

/// Parse Italian sound category from tags.
fn parse_italian_sound(value: &Value) -> ItalianSound {
    if value.has_tag("vowel") {
        ItalianSound::Vowel
    } else if value.has_tag("s_imp") {
        ItalianSound::SImpura
    } else {
        ItalianSound::Normal
    }
}

/// Italian definite article lookup table.
/// Gender x Sound x Plural -> article
fn italian_definite_article(
    gender: RomanceGender,
    sound: ItalianSound,
    plural: RomancePlural,
) -> &'static str {
    match (gender, sound, plural) {
        // Masculine singular
        (RomanceGender::Masculine, ItalianSound::Normal, RomancePlural::One) => "il",
        (RomanceGender::Masculine, ItalianSound::Vowel, RomancePlural::One) => "l'",
        (RomanceGender::Masculine, ItalianSound::SImpura, RomancePlural::One) => "lo",
        // Masculine plural
        (RomanceGender::Masculine, ItalianSound::Normal, RomancePlural::Other) => "i",
        (RomanceGender::Masculine, ItalianSound::Vowel, RomancePlural::Other) => "gli",
        (RomanceGender::Masculine, ItalianSound::SImpura, RomancePlural::Other) => "gli",
        // Feminine singular
        (RomanceGender::Feminine, ItalianSound::Vowel, RomancePlural::One) => "l'",
        (RomanceGender::Feminine, _, RomancePlural::One) => "la",
        // Feminine plural
        (RomanceGender::Feminine, _, RomancePlural::Other) => "le",
    }
}

/// Italian indefinite article lookup table.
/// Gender x Sound -> article
fn italian_indefinite_article(gender: RomanceGender, sound: ItalianSound) -> &'static str {
    match (gender, sound) {
        // Masculine
        (RomanceGender::Masculine, ItalianSound::Normal) => "un",
        (RomanceGender::Masculine, ItalianSound::Vowel) => "un",
        (RomanceGender::Masculine, ItalianSound::SImpura) => "uno",
        // Feminine
        (RomanceGender::Feminine, ItalianSound::Vowel) => "un'",
        (RomanceGender::Feminine, _) => "una",
    }
}

/// Italian "di" + article contraction lookup table.
fn italian_di_contraction(
    gender: RomanceGender,
    sound: ItalianSound,
    plural: RomancePlural,
) -> &'static str {
    match (gender, sound, plural) {
        // Masculine singular
        (RomanceGender::Masculine, ItalianSound::Normal, RomancePlural::One) => "del",
        (RomanceGender::Masculine, ItalianSound::Vowel, RomancePlural::One) => "dell'",
        (RomanceGender::Masculine, ItalianSound::SImpura, RomancePlural::One) => "dello",
        // Masculine plural
        (RomanceGender::Masculine, ItalianSound::Normal, RomancePlural::Other) => "dei",
        (RomanceGender::Masculine, ItalianSound::Vowel, RomancePlural::Other) => "degli",
        (RomanceGender::Masculine, ItalianSound::SImpura, RomancePlural::Other) => "degli",
        // Feminine singular
        (RomanceGender::Feminine, ItalianSound::Vowel, RomancePlural::One) => "dell'",
        (RomanceGender::Feminine, _, RomancePlural::One) => "della",
        // Feminine plural
        (RomanceGender::Feminine, _, RomancePlural::Other) => "delle",
    }
}

/// Italian "a" + article contraction lookup table.
fn italian_a_contraction(
    gender: RomanceGender,
    sound: ItalianSound,
    plural: RomancePlural,
) -> &'static str {
    match (gender, sound, plural) {
        // Masculine singular
        (RomanceGender::Masculine, ItalianSound::Normal, RomancePlural::One) => "al",
        (RomanceGender::Masculine, ItalianSound::Vowel, RomancePlural::One) => "all'",
        (RomanceGender::Masculine, ItalianSound::SImpura, RomancePlural::One) => "allo",
        // Masculine plural
        (RomanceGender::Masculine, ItalianSound::Normal, RomancePlural::Other) => "ai",
        (RomanceGender::Masculine, ItalianSound::Vowel, RomancePlural::Other) => "agli",
        (RomanceGender::Masculine, ItalianSound::SImpura, RomancePlural::Other) => "agli",
        // Feminine singular
        (RomanceGender::Feminine, ItalianSound::Vowel, RomancePlural::One) => "all'",
        (RomanceGender::Feminine, _, RomancePlural::One) => "alla",
        // Feminine plural
        (RomanceGender::Feminine, _, RomancePlural::Other) => "alle",
    }
}

/// Italian definite article transform (@il/@lo/@la).
fn italian_il_transform(value: &Value, context: Option<&Value>) -> Result<String, EvalError> {
    let text = value.to_string();
    let gender = parse_romance_gender(value, "il")?;
    let sound = parse_italian_sound(value);
    let plural = parse_romance_plural(context);
    let article = italian_definite_article(gender, sound, plural);

    // Apostrophe articles attach directly
    if article.ends_with('\'') {
        Ok(format!("{}{}", article, text))
    } else {
        Ok(format!("{} {}", article, text))
    }
}

/// Italian indefinite article transform (@un/@uno/@una).
fn italian_un_transform(value: &Value) -> Result<String, EvalError> {
    let text = value.to_string();
    let gender = parse_romance_gender(value, "un")?;
    let sound = parse_italian_sound(value);
    let article = italian_indefinite_article(gender, sound);

    // Apostrophe articles attach directly (un'amica)
    if article.ends_with('\'') {
        Ok(format!("{}{}", article, text))
    } else {
        Ok(format!("{} {}", article, text))
    }
}

/// Italian "di" + article contraction transform (@di).
fn italian_di_transform(value: &Value, context: Option<&Value>) -> Result<String, EvalError> {
    let text = value.to_string();
    let gender = parse_romance_gender(value, "di")?;
    let sound = parse_italian_sound(value);
    let plural = parse_romance_plural(context);
    let contracted = italian_di_contraction(gender, sound, plural);

    if contracted.ends_with('\'') {
        Ok(format!("{}{}", contracted, text))
    } else {
        Ok(format!("{} {}", contracted, text))
    }
}

/// Italian "a" + article contraction transform (@a).
fn italian_a_transform(value: &Value, context: Option<&Value>) -> Result<String, EvalError> {
    let text = value.to_string();
    let gender = parse_romance_gender(value, "a")?;
    let sound = parse_italian_sound(value);
    let plural = parse_romance_plural(context);
    let contracted = italian_a_contraction(gender, sound, plural);

    if contracted.ends_with('\'') {
        Ok(format!("{}{}", contracted, text))
    } else {
        Ok(format!("{} {}", contracted, text))
    }
}
```

3. Update execute() match:
```rust
TransformKind::ItalianIl => italian_il_transform(value, context),
TransformKind::ItalianUn => italian_un_transform(value),
TransformKind::ItalianDi => italian_di_transform(value, context),
TransformKind::ItalianA => italian_a_transform(value, context),
```

4. Update TransformRegistry::get() with Italian:
```rust
// In alias resolution section:
"lo" | "la" if lang == "it" => "il",  // Italian aliases
"uno" | "una" if lang == "it" => "un", // Italian aliases

// In language-specific match:
("it", "il") => Some(TransformKind::ItalianIl),
("it", "un") => Some(TransformKind::ItalianUn),
("it", "di") => Some(TransformKind::ItalianDi),
("it", "a") => Some(TransformKind::ItalianA),
```

5. Add Italian tests:
```rust
// =============================================================================
// Italian Transform Tests (Phase 7)
// =============================================================================

#[test]
fn italian_il_masculine_normal() {
    let phrase = Phrase::builder()
        .text("libro".to_string())
        .tags(vec!["masc".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::ItalianIl;
    let result = transform.execute(&value, None, "it").unwrap();
    assert_eq!(result, "il libro");
}

#[test]
fn italian_il_masculine_vowel() {
    let phrase = Phrase::builder()
        .text("amico".to_string())
        .tags(vec!["masc".to_string(), "vowel".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::ItalianIl;
    let result = transform.execute(&value, None, "it").unwrap();
    assert_eq!(result, "l'amico");  // Elision
}

#[test]
fn italian_il_masculine_s_impura() {
    let phrase = Phrase::builder()
        .text("studente".to_string())
        .tags(vec!["masc".to_string(), "s_imp".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::ItalianIl;
    let result = transform.execute(&value, None, "it").unwrap();
    assert_eq!(result, "lo studente");
}

#[test]
fn italian_il_feminine_normal() {
    let phrase = Phrase::builder()
        .text("carta".to_string())
        .tags(vec!["fem".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::ItalianIl;
    let result = transform.execute(&value, None, "it").unwrap();
    assert_eq!(result, "la carta");
}

#[test]
fn italian_il_feminine_vowel() {
    let phrase = Phrase::builder()
        .text("amica".to_string())
        .tags(vec!["fem".to_string(), "vowel".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::ItalianIl;
    let result = transform.execute(&value, None, "it").unwrap();
    assert_eq!(result, "l'amica");  // Elision
}

#[test]
fn italian_il_plural_normal() {
    let phrase = Phrase::builder()
        .text("libri".to_string())
        .tags(vec!["masc".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let context = Value::String("other".to_string());
    let transform = TransformKind::ItalianIl;
    let result = transform.execute(&value, Some(&context), "it").unwrap();
    assert_eq!(result, "i libri");
}

#[test]
fn italian_il_plural_vowel() {
    let phrase = Phrase::builder()
        .text("amici".to_string())
        .tags(vec!["masc".to_string(), "vowel".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let context = Value::String("other".to_string());
    let transform = TransformKind::ItalianIl;
    let result = transform.execute(&value, Some(&context), "it").unwrap();
    assert_eq!(result, "gli amici");
}

#[test]
fn italian_il_plural_s_impura() {
    let phrase = Phrase::builder()
        .text("studenti".to_string())
        .tags(vec!["masc".to_string(), "s_imp".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let context = Value::String("other".to_string());
    let transform = TransformKind::ItalianIl;
    let result = transform.execute(&value, Some(&context), "it").unwrap();
    assert_eq!(result, "gli studenti");
}

#[test]
fn italian_un_masculine_normal() {
    let phrase = Phrase::builder()
        .text("libro".to_string())
        .tags(vec!["masc".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::ItalianUn;
    let result = transform.execute(&value, None, "it").unwrap();
    assert_eq!(result, "un libro");
}

#[test]
fn italian_un_masculine_s_impura() {
    let phrase = Phrase::builder()
        .text("studente".to_string())
        .tags(vec!["masc".to_string(), "s_imp".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::ItalianUn;
    let result = transform.execute(&value, None, "it").unwrap();
    assert_eq!(result, "uno studente");
}

#[test]
fn italian_un_feminine_normal() {
    let phrase = Phrase::builder()
        .text("carta".to_string())
        .tags(vec!["fem".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::ItalianUn;
    let result = transform.execute(&value, None, "it").unwrap();
    assert_eq!(result, "una carta");
}

#[test]
fn italian_un_feminine_vowel() {
    let phrase = Phrase::builder()
        .text("amica".to_string())
        .tags(vec!["fem".to_string(), "vowel".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::ItalianUn;
    let result = transform.execute(&value, None, "it").unwrap();
    assert_eq!(result, "un'amica");  // Feminine elision with apostrophe
}

#[test]
fn italian_di_contraction_normal() {
    let phrase = Phrase::builder()
        .text("libro".to_string())
        .tags(vec!["masc".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::ItalianDi;
    let result = transform.execute(&value, None, "it").unwrap();
    assert_eq!(result, "del libro");
}

#[test]
fn italian_di_contraction_vowel() {
    let phrase = Phrase::builder()
        .text("amico".to_string())
        .tags(vec!["masc".to_string(), "vowel".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::ItalianDi;
    let result = transform.execute(&value, None, "it").unwrap();
    assert_eq!(result, "dell'amico");
}

#[test]
fn italian_di_contraction_s_impura() {
    let phrase = Phrase::builder()
        .text("studente".to_string())
        .tags(vec!["masc".to_string(), "s_imp".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::ItalianDi;
    let result = transform.execute(&value, None, "it").unwrap();
    assert_eq!(result, "dello studente");
}

#[test]
fn italian_a_contraction_normal() {
    let phrase = Phrase::builder()
        .text("libro".to_string())
        .tags(vec!["masc".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::ItalianA;
    let result = transform.execute(&value, None, "it").unwrap();
    assert_eq!(result, "al libro");
}

#[test]
fn italian_a_contraction_vowel() {
    let phrase = Phrase::builder()
        .text("amico".to_string())
        .tags(vec!["masc".to_string(), "vowel".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::ItalianA;
    let result = transform.execute(&value, None, "it").unwrap();
    assert_eq!(result, "all'amico");
}

#[test]
fn italian_il_missing_gender() {
    let phrase = Phrase::builder()
        .text("cosa".to_string())
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::ItalianIl;
    let result = transform.execute(&value, None, "it");
    assert!(matches!(result, Err(EvalError::MissingTag { .. })));
}

#[test]
fn italian_transform_aliases() {
    let registry = TransformRegistry::new();
    assert_eq!(registry.get("lo", "it"), Some(TransformKind::ItalianIl));
    assert_eq!(registry.get("la", "it"), Some(TransformKind::ItalianIl));
    assert_eq!(registry.get("uno", "it"), Some(TransformKind::ItalianUn));
    assert_eq!(registry.get("una", "it"), Some(TransformKind::ItalianUn));
}
```
  </action>
  <verify>Run `cargo test -p rlf italian` to run Italian transform tests. All should pass.</verify>
  <done>ItalianIl, ItalianUn, ItalianDi, ItalianA variants exist, sound-based lookup works</done>
</task>

<task type="auto">
  <name>Task 3: French and Italian integration tests</name>
  <files>crates/rlf/tests/interpreter_transforms.rs</files>
  <action>
Add integration tests that exercise full evaluation with French and Italian transforms:

```rust
// =============================================================================
// French/Italian Integration Tests (Phase 7)
// =============================================================================

#[test]
fn french_le_in_template() {
    let source = r#"
        carte = :fem "carte";
        ennemi = :masc :vowel "ennemi";
        the_card = "{@le carte}";
        the_enemy = "{@le ennemi}";
    "#;

    let mut locale = Locale::builder().language("fr").build();
    locale.load_translations_from_str("fr", source).unwrap();

    assert_eq!(
        locale.eval_phrase("fr", "the_card", &[]).unwrap(),
        "la carte"
    );
    assert_eq!(
        locale.eval_phrase("fr", "the_enemy", &[]).unwrap(),
        "l'ennemi"  // Elision
    );
}

#[test]
fn french_contractions_in_template() {
    let source = r#"
        vide = :masc "vide";
        ami = :masc :vowel "ami";
        main = :fem "main";
        from_void = "{@de vide}";
        from_friend = "{@de ami}";
        to_hand = "{@au main}";
    "#;

    let mut locale = Locale::builder().language("fr").build();
    locale.load_translations_from_str("fr", source).unwrap();

    assert_eq!(
        locale.eval_phrase("fr", "from_void", &[]).unwrap(),
        "du vide"  // de + le = du
    );
    assert_eq!(
        locale.eval_phrase("fr", "from_friend", &[]).unwrap(),
        "de l'ami"  // de + l' (elided)
    );
    assert_eq!(
        locale.eval_phrase("fr", "to_hand", &[]).unwrap(),
        "a la main"  // No contraction for feminine
    );
}

#[test]
fn italian_il_in_template() {
    let source = r#"
        carta = :fem "carta";
        studente = :masc :s_imp "studente";
        amico = :masc :vowel "amico";
        the_card = "{@il carta}";
        the_student = "{@lo studente}";
        the_friend = "{@il amico}";
    "#;

    let mut locale = Locale::builder().language("it").build();
    locale.load_translations_from_str("it", source).unwrap();

    assert_eq!(
        locale.eval_phrase("it", "the_card", &[]).unwrap(),
        "la carta"
    );
    assert_eq!(
        locale.eval_phrase("it", "the_student", &[]).unwrap(),
        "lo studente"  // s-impura
    );
    assert_eq!(
        locale.eval_phrase("it", "the_friend", &[]).unwrap(),
        "l'amico"  // Elision
    );
}

#[test]
fn italian_un_in_template() {
    let source = r#"
        carta = :fem "carta";
        amica = :fem :vowel "amica";
        studente = :masc :s_imp "studente";
        a_card = "{@un carta}";
        a_friend = "{@un amica}";
        a_student = "{@uno studente}";
    "#;

    let mut locale = Locale::builder().language("it").build();
    locale.load_translations_from_str("it", source).unwrap();

    assert_eq!(
        locale.eval_phrase("it", "a_card", &[]).unwrap(),
        "una carta"
    );
    assert_eq!(
        locale.eval_phrase("it", "a_friend", &[]).unwrap(),
        "un'amica"  // Feminine elision
    );
    assert_eq!(
        locale.eval_phrase("it", "a_student", &[]).unwrap(),
        "uno studente"  // s-impura
    );
}

#[test]
fn italian_contractions_in_template() {
    let source = r#"
        libro = :masc "libro";
        amico = :masc :vowel "amico";
        from_book = "{@di libro}";
        from_friend = "{@di amico}";
        to_book = "{@a libro}";
        to_friend = "{@a amico}";
    "#;

    let mut locale = Locale::builder().language("it").build();
    locale.load_translations_from_str("it", source).unwrap();

    assert_eq!(
        locale.eval_phrase("it", "from_book", &[]).unwrap(),
        "del libro"
    );
    assert_eq!(
        locale.eval_phrase("it", "from_friend", &[]).unwrap(),
        "dell'amico"  // Elision
    );
    assert_eq!(
        locale.eval_phrase("it", "to_book", &[]).unwrap(),
        "al libro"
    );
    assert_eq!(
        locale.eval_phrase("it", "to_friend", &[]).unwrap(),
        "all'amico"  // Elision
    );
}

#[test]
fn french_italian_cross_language() {
    // Verify same transform name (@un) works correctly in each language
    let fr_source = r#"
        carte = :fem "carte";
        draw_card = "Piochez {@un carte}.";
    "#;

    let it_source = r#"
        carta = :fem "carta";
        draw_card = "Pesca {@un carta}.";
    "#;

    let mut locale = Locale::builder().language("fr").build();
    locale.load_translations_from_str("fr", fr_source).unwrap();
    locale.load_translations_from_str("it", it_source).unwrap();

    assert_eq!(
        locale.eval_phrase("fr", "draw_card", &[]).unwrap(),
        "Piochez une carte."  // French feminine
    );
    assert_eq!(
        locale.eval_phrase("it", "draw_card", &[]).unwrap(),
        "Pesca una carta."  // Italian feminine
    );
}

#[test]
fn all_romance_cross_language() {
    // Test that same phrase structure works across all four Romance languages
    let es_source = r#"
        carta = :fem "carta";
        the_card = "{@el carta}";
    "#;
    let pt_source = r#"
        carta = :fem "carta";
        the_card = "{@o carta}";
    "#;
    let fr_source = r#"
        carte = :fem "carte";
        the_card = "{@le carte}";
    "#;
    let it_source = r#"
        carta = :fem "carta";
        the_card = "{@il carta}";
    "#;

    let mut locale = Locale::builder().language("es").build();
    locale.load_translations_from_str("es", es_source).unwrap();
    locale.load_translations_from_str("pt", pt_source).unwrap();
    locale.load_translations_from_str("fr", fr_source).unwrap();
    locale.load_translations_from_str("it", it_source).unwrap();

    assert_eq!(locale.eval_phrase("es", "the_card", &[]).unwrap(), "la carta");
    assert_eq!(locale.eval_phrase("pt", "the_card", &[]).unwrap(), "a carta");
    assert_eq!(locale.eval_phrase("fr", "the_card", &[]).unwrap(), "la carte");
    assert_eq!(locale.eval_phrase("it", "the_card", &[]).unwrap(), "la carta");
}
```
  </action>
  <verify>Run `cargo test -p rlf` - all tests pass. Run `just review` for code quality.</verify>
  <done>Integration tests verify French and Italian transforms work in full evaluation context with elision</done>
</task>

</tasks>

<verification>
1. `cargo check -p rlf` compiles without errors
2. `cargo test -p rlf` passes all tests (existing + new French/Italian)
3. `cargo test -p rlf french` shows French-specific tests passing
4. `cargo test -p rlf italian` shows Italian-specific tests passing
5. `just review` passes all lints
</verification>

<success_criteria>
- FrenchLe, FrenchUn, FrenchDe, FrenchAu, FrenchLiaison variants added to TransformKind
- ItalianIl, ItalianUn, ItalianDi, ItalianA variants added
- French @le handles elision via :vowel tag (l' before vowels, singular only)
- French contractions handle elision correctly (de l', a l')
- Italian @il handles three sound categories (:vowel, :s_imp, normal)
- Italian @un handles feminine elision (un')
- Italian contractions handle all sound variants (dell', dello, etc.)
- Transform aliases resolve correctly (@la->@le for FR, @lo/@la->@il for IT)
- MissingTag error when gender tags absent
- Apostrophe formatting correct (no space after apostrophe)
</success_criteria>

<output>
After completion, create `.planning/phases/07-romance-language-transforms/07-02-SUMMARY.md`
</output>
