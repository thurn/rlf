---
phase: 07-romance-language-transforms
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/rlf/src/interpreter/transforms.rs
  - crates/rlf/tests/interpreter_transforms.rs
autonomous: true

must_haves:
  truths:
    - "Spanish @el selects definite article by :masc/:fem tags with plural context"
    - "Spanish @un selects indefinite article by :masc/:fem tags with plural context"
    - "Portuguese @o selects definite article by :masc/:fem tags with plural context"
    - "Portuguese @um selects indefinite article by :masc/:fem tags"
    - "Portuguese @de produces contraction (do/da/dos/das)"
    - "Portuguese @em produces contraction (no/na/nos/nas)"
    - "Missing gender tag produces MissingTag error"
  artifacts:
    - path: "crates/rlf/src/interpreter/transforms.rs"
      provides: "Spanish and Portuguese transform variants and lookup tables"
      contains: "SpanishEl"
    - path: "crates/rlf/tests/interpreter_transforms.rs"
      provides: "Tests for Spanish and Portuguese transforms"
      contains: "spanish_el_masculine"
  key_links:
    - from: "crates/rlf/src/interpreter/transforms.rs"
      to: "spanish_definite_article"
      via: "SpanishEl uses lookup table"
      pattern: "spanish_definite_article\\(gender, plural\\)"
    - from: "crates/rlf/src/interpreter/transforms.rs"
      to: "portuguese_de_contraction"
      via: "PortugueseDe uses contraction table"
      pattern: "portuguese_de_contraction\\(gender, plural\\)"
---

<objective>
Implement Spanish and Portuguese article and contraction transforms.

Purpose: Enable Spanish and Portuguese article selection based on gender tags (:masc/:fem) and plural context (:one/:other). Spanish has 4 definite (el/la/los/las) and 4 indefinite (un/una/unos/unas) forms. Portuguese adds contraction transforms (@de, @em) that combine prepositions with articles.

Output: Working @el, @un (Spanish), @o, @um, @de, @em (Portuguese) transforms with comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-romance-language-transforms/07-RESEARCH.md
@docs/APPENDIX_STDLIB.md (Spanish and Portuguese sections)
@crates/rlf/src/interpreter/transforms.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Spanish transforms with tests</name>
  <files>crates/rlf/src/interpreter/transforms.rs, crates/rlf/tests/interpreter_transforms.rs</files>
  <action>
Add Spanish article transforms following the Phase 6 German pattern.

1. Add enum variants to TransformKind:
```rust
// Spanish transforms (Phase 7)
/// @el/@la - Spanish definite article with plural context
SpanishEl,
/// @un/@una - Spanish indefinite article with plural context
SpanishUn,
```

2. Add helper types (reuse RomanceGender across languages):
```rust
// =============================================================================
// Romance Language Transforms (Phase 7)
// =============================================================================

/// Romance grammatical gender (shared by Spanish, French, Portuguese, Italian).
#[derive(Clone, Copy)]
enum RomanceGender {
    Masculine,
    Feminine,
}

/// Romance plural category (singular/plural).
#[derive(Clone, Copy)]
enum RomancePlural {
    One,    // Singular
    Other,  // Plural
}

/// Parse gender from Value's tags for Romance languages.
/// Returns None if neither :masc nor :fem tag is present.
fn parse_romance_gender(value: &Value, transform: &str) -> Result<RomanceGender, EvalError> {
    if value.has_tag("masc") {
        Ok(RomanceGender::Masculine)
    } else if value.has_tag("fem") {
        Ok(RomanceGender::Feminine)
    } else {
        Err(EvalError::MissingTag {
            transform: transform.to_string(),
            expected: vec!["masc".to_string(), "fem".to_string()],
            phrase: value.to_string(),
        })
    }
}

/// Parse plural category from context value.
/// Supports both string context (:one/:other) and numeric context.
/// Defaults to singular (One) if no context provided.
fn parse_romance_plural(context: Option<&Value>) -> RomancePlural {
    match context {
        Some(Value::String(s)) => match s.as_str() {
            "other" => RomancePlural::Other,
            _ => RomancePlural::One,
        },
        Some(Value::Number(n)) => {
            if *n == 1 { RomancePlural::One } else { RomancePlural::Other }
        },
        _ => RomancePlural::One,
    }
}
```

3. Add Spanish article lookup tables:
```rust
// =============================================================================
// Spanish Transforms (Phase 7)
// =============================================================================

/// Spanish definite article lookup table.
/// Gender x Plural -> article (el/la/los/las)
fn spanish_definite_article(gender: RomanceGender, plural: RomancePlural) -> &'static str {
    match (gender, plural) {
        (RomanceGender::Masculine, RomancePlural::One) => "el",
        (RomanceGender::Masculine, RomancePlural::Other) => "los",
        (RomanceGender::Feminine, RomancePlural::One) => "la",
        (RomanceGender::Feminine, RomancePlural::Other) => "las",
    }
}

/// Spanish indefinite article lookup table.
/// Gender x Plural -> article (un/una/unos/unas)
fn spanish_indefinite_article(gender: RomanceGender, plural: RomancePlural) -> &'static str {
    match (gender, plural) {
        (RomanceGender::Masculine, RomancePlural::One) => "un",
        (RomanceGender::Masculine, RomancePlural::Other) => "unos",
        (RomanceGender::Feminine, RomancePlural::One) => "una",
        (RomanceGender::Feminine, RomancePlural::Other) => "unas",
    }
}

/// Spanish definite article transform (@el/@la).
fn spanish_el_transform(value: &Value, context: Option<&Value>) -> Result<String, EvalError> {
    let text = value.to_string();
    let gender = parse_romance_gender(value, "el")?;
    let plural = parse_romance_plural(context);
    let article = spanish_definite_article(gender, plural);
    Ok(format!("{} {}", article, text))
}

/// Spanish indefinite article transform (@un/@una).
fn spanish_un_transform(value: &Value, context: Option<&Value>) -> Result<String, EvalError> {
    let text = value.to_string();
    let gender = parse_romance_gender(value, "un")?;
    let plural = parse_romance_plural(context);
    let article = spanish_indefinite_article(gender, plural);
    Ok(format!("{} {}", article, text))
}
```

4. Update execute() match to include Spanish:
```rust
TransformKind::SpanishEl => spanish_el_transform(value, context),
TransformKind::SpanishUn => spanish_un_transform(value, context),
```

5. Update TransformRegistry::get() with Spanish aliases:
```rust
// In alias resolution section:
"la" if lang == "es" => "el",  // Spanish alias
"una" => "un",                  // Spanish alias

// In language-specific match:
("es", "el") => Some(TransformKind::SpanishEl),
("es", "un") => Some(TransformKind::SpanishUn),
```

6. Add tests in interpreter_transforms.rs:
```rust
// =============================================================================
// Spanish Transform Tests (Phase 7)
// =============================================================================

#[test]
fn spanish_el_masculine_singular() {
    let phrase = Phrase::builder()
        .text("enemigo".to_string())
        .tags(vec!["masc".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::SpanishEl;
    let result = transform.execute(&value, None, "es").unwrap();
    assert_eq!(result, "el enemigo");
}

#[test]
fn spanish_el_feminine_singular() {
    let phrase = Phrase::builder()
        .text("carta".to_string())
        .tags(vec!["fem".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::SpanishEl;
    let result = transform.execute(&value, None, "es").unwrap();
    assert_eq!(result, "la carta");
}

#[test]
fn spanish_el_masculine_plural() {
    let phrase = Phrase::builder()
        .text("enemigos".to_string())
        .tags(vec!["masc".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let context = Value::String("other".to_string());
    let transform = TransformKind::SpanishEl;
    let result = transform.execute(&value, Some(&context), "es").unwrap();
    assert_eq!(result, "los enemigos");
}

#[test]
fn spanish_el_feminine_plural() {
    let phrase = Phrase::builder()
        .text("cartas".to_string())
        .tags(vec!["fem".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let context = Value::String("other".to_string());
    let transform = TransformKind::SpanishEl;
    let result = transform.execute(&value, Some(&context), "es").unwrap();
    assert_eq!(result, "las cartas");
}

#[test]
fn spanish_un_masculine_singular() {
    let phrase = Phrase::builder()
        .text("enemigo".to_string())
        .tags(vec!["masc".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::SpanishUn;
    let result = transform.execute(&value, None, "es").unwrap();
    assert_eq!(result, "un enemigo");
}

#[test]
fn spanish_un_feminine_singular() {
    let phrase = Phrase::builder()
        .text("carta".to_string())
        .tags(vec!["fem".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::SpanishUn;
    let result = transform.execute(&value, None, "es").unwrap();
    assert_eq!(result, "una carta");
}

#[test]
fn spanish_un_masculine_plural() {
    let phrase = Phrase::builder()
        .text("enemigos".to_string())
        .tags(vec!["masc".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let context = Value::String("other".to_string());
    let transform = TransformKind::SpanishUn;
    let result = transform.execute(&value, Some(&context), "es").unwrap();
    assert_eq!(result, "unos enemigos");
}

#[test]
fn spanish_el_missing_gender() {
    let phrase = Phrase::builder()
        .text("cosa".to_string())
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::SpanishEl;
    let result = transform.execute(&value, None, "es");
    assert!(matches!(result, Err(EvalError::MissingTag { .. })));
}

#[test]
fn spanish_transform_aliases() {
    let registry = TransformRegistry::new();
    assert_eq!(registry.get("la", "es"), Some(TransformKind::SpanishEl));
    assert_eq!(registry.get("una", "es"), Some(TransformKind::SpanishUn));
}

#[test]
fn spanish_el_numeric_context() {
    // Numeric context uses plural rules: 1=one, else=other
    let phrase = Phrase::builder()
        .text("carta".to_string())
        .tags(vec!["fem".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::SpanishEl;

    let ctx_one = Value::Number(1);
    let result_one = transform.execute(&value, Some(&ctx_one), "es").unwrap();
    assert_eq!(result_one, "la carta");

    let ctx_three = Value::Number(3);
    let result_three = transform.execute(&value, Some(&ctx_three), "es").unwrap();
    assert_eq!(result_three, "las carta");
}
```
  </action>
  <verify>Run `cargo test -p rlf spanish` to run Spanish transform tests. All should pass.</verify>
  <done>SpanishEl and SpanishUn variants exist, gender/plural lookup works, aliases resolve correctly</done>
</task>

<task type="auto">
  <name>Task 2: Add Portuguese transforms with tests</name>
  <files>crates/rlf/src/interpreter/transforms.rs, crates/rlf/tests/interpreter_transforms.rs</files>
  <action>
Add Portuguese article and contraction transforms.

1. Add enum variants to TransformKind:
```rust
// Portuguese transforms (Phase 7)
/// @o/@a - Portuguese definite article with plural context
PortugueseO,
/// @um/@uma - Portuguese indefinite article
PortugueseUm,
/// @de - Portuguese "de" + article contraction
PortugueseDe,
/// @em - Portuguese "em" + article contraction
PortugueseEm,
```

2. Add Portuguese lookup tables:
```rust
// =============================================================================
// Portuguese Transforms (Phase 7)
// =============================================================================

/// Portuguese definite article lookup table.
/// Gender x Plural -> article (o/a/os/as)
fn portuguese_definite_article(gender: RomanceGender, plural: RomancePlural) -> &'static str {
    match (gender, plural) {
        (RomanceGender::Masculine, RomancePlural::One) => "o",
        (RomanceGender::Masculine, RomancePlural::Other) => "os",
        (RomanceGender::Feminine, RomancePlural::One) => "a",
        (RomanceGender::Feminine, RomancePlural::Other) => "as",
    }
}

/// Portuguese indefinite article lookup table.
/// Gender only (no plural for indefinite in Portuguese).
fn portuguese_indefinite_article(gender: RomanceGender) -> &'static str {
    match gender {
        RomanceGender::Masculine => "um",
        RomanceGender::Feminine => "uma",
    }
}

/// Portuguese "de" + article contraction lookup table.
/// de + o = do, de + a = da, de + os = dos, de + as = das
fn portuguese_de_contraction(gender: RomanceGender, plural: RomancePlural) -> &'static str {
    match (gender, plural) {
        (RomanceGender::Masculine, RomancePlural::One) => "do",
        (RomanceGender::Masculine, RomancePlural::Other) => "dos",
        (RomanceGender::Feminine, RomancePlural::One) => "da",
        (RomanceGender::Feminine, RomancePlural::Other) => "das",
    }
}

/// Portuguese "em" + article contraction lookup table.
/// em + o = no, em + a = na, em + os = nos, em + as = nas
fn portuguese_em_contraction(gender: RomanceGender, plural: RomancePlural) -> &'static str {
    match (gender, plural) {
        (RomanceGender::Masculine, RomancePlural::One) => "no",
        (RomanceGender::Masculine, RomancePlural::Other) => "nos",
        (RomanceGender::Feminine, RomancePlural::One) => "na",
        (RomanceGender::Feminine, RomancePlural::Other) => "nas",
    }
}

/// Portuguese definite article transform (@o/@a).
fn portuguese_o_transform(value: &Value, context: Option<&Value>) -> Result<String, EvalError> {
    let text = value.to_string();
    let gender = parse_romance_gender(value, "o")?;
    let plural = parse_romance_plural(context);
    let article = portuguese_definite_article(gender, plural);
    Ok(format!("{} {}", article, text))
}

/// Portuguese indefinite article transform (@um/@uma).
fn portuguese_um_transform(value: &Value) -> Result<String, EvalError> {
    let text = value.to_string();
    let gender = parse_romance_gender(value, "um")?;
    let article = portuguese_indefinite_article(gender);
    Ok(format!("{} {}", article, text))
}

/// Portuguese "de" + article contraction transform (@de).
fn portuguese_de_transform(value: &Value, context: Option<&Value>) -> Result<String, EvalError> {
    let text = value.to_string();
    let gender = parse_romance_gender(value, "de")?;
    let plural = parse_romance_plural(context);
    let contracted = portuguese_de_contraction(gender, plural);
    Ok(format!("{} {}", contracted, text))
}

/// Portuguese "em" + article contraction transform (@em).
fn portuguese_em_transform(value: &Value, context: Option<&Value>) -> Result<String, EvalError> {
    let text = value.to_string();
    let gender = parse_romance_gender(value, "em")?;
    let plural = parse_romance_plural(context);
    let contracted = portuguese_em_contraction(gender, plural);
    Ok(format!("{} {}", contracted, text))
}
```

3. Update execute() match:
```rust
TransformKind::PortugueseO => portuguese_o_transform(value, context),
TransformKind::PortugueseUm => portuguese_um_transform(value),
TransformKind::PortugueseDe => portuguese_de_transform(value, context),
TransformKind::PortugueseEm => portuguese_em_transform(value, context),
```

4. Update TransformRegistry::get() with Portuguese:
```rust
// In alias resolution section:
"a" if lang == "pt" => "o",   // Portuguese alias
"uma" => "um",                 // Portuguese alias (shared with Spanish)

// In language-specific match:
("pt", "o") => Some(TransformKind::PortugueseO),
("pt", "um") => Some(TransformKind::PortugueseUm),
("pt", "de") => Some(TransformKind::PortugueseDe),
("pt", "em") => Some(TransformKind::PortugueseEm),
```

5. Add tests:
```rust
// =============================================================================
// Portuguese Transform Tests (Phase 7)
// =============================================================================

#[test]
fn portuguese_o_masculine_singular() {
    let phrase = Phrase::builder()
        .text("inimigo".to_string())
        .tags(vec!["masc".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::PortugueseO;
    let result = transform.execute(&value, None, "pt").unwrap();
    assert_eq!(result, "o inimigo");
}

#[test]
fn portuguese_o_feminine_singular() {
    let phrase = Phrase::builder()
        .text("carta".to_string())
        .tags(vec!["fem".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::PortugueseO;
    let result = transform.execute(&value, None, "pt").unwrap();
    assert_eq!(result, "a carta");
}

#[test]
fn portuguese_o_masculine_plural() {
    let phrase = Phrase::builder()
        .text("inimigos".to_string())
        .tags(vec!["masc".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let context = Value::String("other".to_string());
    let transform = TransformKind::PortugueseO;
    let result = transform.execute(&value, Some(&context), "pt").unwrap();
    assert_eq!(result, "os inimigos");
}

#[test]
fn portuguese_um_masculine() {
    let phrase = Phrase::builder()
        .text("inimigo".to_string())
        .tags(vec!["masc".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::PortugueseUm;
    let result = transform.execute(&value, None, "pt").unwrap();
    assert_eq!(result, "um inimigo");
}

#[test]
fn portuguese_um_feminine() {
    let phrase = Phrase::builder()
        .text("carta".to_string())
        .tags(vec!["fem".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::PortugueseUm;
    let result = transform.execute(&value, None, "pt").unwrap();
    assert_eq!(result, "uma carta");
}

#[test]
fn portuguese_de_contraction_masculine() {
    let phrase = Phrase::builder()
        .text("vazio".to_string())
        .tags(vec!["masc".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::PortugueseDe;
    let result = transform.execute(&value, None, "pt").unwrap();
    assert_eq!(result, "do vazio");  // de + o = do
}

#[test]
fn portuguese_de_contraction_feminine() {
    let phrase = Phrase::builder()
        .text("carta".to_string())
        .tags(vec!["fem".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::PortugueseDe;
    let result = transform.execute(&value, None, "pt").unwrap();
    assert_eq!(result, "da carta");  // de + a = da
}

#[test]
fn portuguese_de_contraction_plural() {
    let phrase = Phrase::builder()
        .text("cartas".to_string())
        .tags(vec!["fem".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let context = Value::String("other".to_string());
    let transform = TransformKind::PortugueseDe;
    let result = transform.execute(&value, Some(&context), "pt").unwrap();
    assert_eq!(result, "das cartas");  // de + as = das
}

#[test]
fn portuguese_em_contraction_masculine() {
    let phrase = Phrase::builder()
        .text("vazio".to_string())
        .tags(vec!["masc".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::PortugueseEm;
    let result = transform.execute(&value, None, "pt").unwrap();
    assert_eq!(result, "no vazio");  // em + o = no
}

#[test]
fn portuguese_em_contraction_feminine() {
    let phrase = Phrase::builder()
        .text("mao".to_string())
        .tags(vec!["fem".to_string()])
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::PortugueseEm;
    let result = transform.execute(&value, None, "pt").unwrap();
    assert_eq!(result, "na mao");  // em + a = na
}

#[test]
fn portuguese_transform_aliases() {
    let registry = TransformRegistry::new();
    assert_eq!(registry.get("a", "pt"), Some(TransformKind::PortugueseO));
    assert_eq!(registry.get("uma", "pt"), Some(TransformKind::PortugueseUm));
}

#[test]
fn portuguese_o_missing_gender() {
    let phrase = Phrase::builder()
        .text("coisa".to_string())
        .build();
    let value = Value::Phrase(phrase);
    let transform = TransformKind::PortugueseO;
    let result = transform.execute(&value, None, "pt");
    assert!(matches!(result, Err(EvalError::MissingTag { .. })));
}
```
  </action>
  <verify>Run `cargo test -p rlf portuguese` to run Portuguese transform tests. All should pass.</verify>
  <done>PortugueseO, PortugueseUm, PortugueseDe, PortugueseEm variants exist, all lookup tables work</done>
</task>

<task type="auto">
  <name>Task 3: Spanish and Portuguese integration tests</name>
  <files>crates/rlf/tests/interpreter_transforms.rs</files>
  <action>
Add integration tests that exercise full evaluation with Spanish and Portuguese transforms:

```rust
// =============================================================================
// Spanish/Portuguese Integration Tests (Phase 7)
// =============================================================================

#[test]
fn spanish_el_in_template() {
    let source = r#"
        carta = :fem "carta";
        enemigo = :masc "enemigo";
        the_card = "{@el carta}";
        the_enemy = "{@la enemigo}";
    "#;

    let mut locale = Locale::builder().language("es").build();
    locale.load_translations_from_str("es", source).unwrap();

    assert_eq!(
        locale.eval_phrase("es", "the_card", &[]).unwrap(),
        "la carta"
    );
    // Note: @la alias resolves to @el, then looks up fem tag
    assert_eq!(
        locale.eval_phrase("es", "the_enemy", &[]).unwrap(),
        "el enemigo"
    );
}

#[test]
fn spanish_el_with_plural_context() {
    let source = r#"
        carta = :fem { one: "carta", other: "cartas" };
        return_all(t) = "devuelve {@el:other t}";
    "#;

    let mut locale = Locale::builder().language("es").build();
    locale.load_translations_from_str("es", source).unwrap();

    // Using phrase parameter with plural context
    let carta = locale.get_phrase("es", "carta").unwrap();
    let result = locale.call_phrase("es", "return_all", &[carta.into()]).unwrap();
    assert_eq!(result, "devuelve las cartas");
}

#[test]
fn spanish_un_in_template() {
    let source = r#"
        carta = :fem "carta";
        enemigo = :masc "enemigo";
        draw_one = "Roba {@un carta}.";
        draw_enemy = "Roba {@una enemigo}.";
    "#;

    let mut locale = Locale::builder().language("es").build();
    locale.load_translations_from_str("es", source).unwrap();

    assert_eq!(
        locale.eval_phrase("es", "draw_one", &[]).unwrap(),
        "Roba una carta."
    );
    // @una resolves to @un
    assert_eq!(
        locale.eval_phrase("es", "draw_enemy", &[]).unwrap(),
        "Roba un enemigo."
    );
}

#[test]
fn portuguese_o_in_template() {
    let source = r#"
        carta = :fem "carta";
        inimigo = :masc "inimigo";
        the_card = "{@o carta}";
        the_enemy = "{@a inimigo}";
    "#;

    let mut locale = Locale::builder().language("pt").build();
    locale.load_translations_from_str("pt", source).unwrap();

    assert_eq!(
        locale.eval_phrase("pt", "the_card", &[]).unwrap(),
        "a carta"
    );
    // @a alias resolves to @o
    assert_eq!(
        locale.eval_phrase("pt", "the_enemy", &[]).unwrap(),
        "o inimigo"
    );
}

#[test]
fn portuguese_contractions_in_template() {
    let source = r#"
        vazio = :masc "vazio";
        mao = :fem "mao";
        from_void = "{@de vazio}";
        in_hand = "{@em mao}";
    "#;

    let mut locale = Locale::builder().language("pt").build();
    locale.load_translations_from_str("pt", source).unwrap();

    assert_eq!(
        locale.eval_phrase("pt", "from_void", &[]).unwrap(),
        "do vazio"  // de + o = do
    );
    assert_eq!(
        locale.eval_phrase("pt", "in_hand", &[]).unwrap(),
        "na mao"  // em + a = na
    );
}

#[test]
fn spanish_portuguese_cross_language() {
    // Verify same phrase structure works in both languages
    let es_source = r#"
        carta = :fem "carta";
        draw_card = "Roba {@un carta}.";
    "#;

    let pt_source = r#"
        carta = :fem "carta";
        draw_card = "Compre {@um carta}.";
    "#;

    let mut locale = Locale::builder().language("es").build();
    locale.load_translations_from_str("es", es_source).unwrap();
    locale.load_translations_from_str("pt", pt_source).unwrap();

    assert_eq!(
        locale.eval_phrase("es", "draw_card", &[]).unwrap(),
        "Roba una carta."
    );
    assert_eq!(
        locale.eval_phrase("pt", "draw_card", &[]).unwrap(),
        "Compre uma carta."
    );
}
```
  </action>
  <verify>Run `cargo test -p rlf` - all tests pass. Run `just review` for code quality.</verify>
  <done>Integration tests verify Spanish and Portuguese transforms work in full evaluation context</done>
</task>

</tasks>

<verification>
1. `cargo check -p rlf` compiles without errors
2. `cargo test -p rlf` passes all tests (existing + new Spanish/Portuguese)
3. `cargo test -p rlf spanish` shows Spanish-specific tests passing
4. `cargo test -p rlf portuguese` shows Portuguese-specific tests passing
5. `just review` passes all lints
</verification>

<success_criteria>
- SpanishEl and SpanishUn variants added to TransformKind enum
- PortugueseO, PortugueseUm, PortugueseDe, PortugueseEm variants added
- @el and @o read :masc/:fem tags and plural context
- @un and @um read :masc/:fem tags
- @de and @em produce correct contractions (do/da/dos/das, no/na/nos/nas)
- Transform aliases @la->@el (ES), @una->@un, @a->@o (PT), @uma->@um resolve correctly
- MissingTag error when gender tags absent
- Numeric context for plural supported (1=one, else=other)
</success_criteria>

<output>
After completion, create `.planning/phases/07-romance-language-transforms/07-01-SUMMARY.md`
</output>
