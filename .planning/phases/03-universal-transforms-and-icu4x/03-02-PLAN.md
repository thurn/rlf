---
phase: 03-universal-transforms-and-icu4x
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - crates/rlf/src/interpreter/evaluator.rs
  - crates/rlf/tests/interpreter_transforms.rs
autonomous: true

must_haves:
  truths:
    - "Transforms execute right-to-left (innermost first)"
    - "Transform context values are resolved before passing to transform"
    - "Unknown transforms return UnknownTransform error"
    - "@cap on Turkish 'istanbul' produces 'Istanbul' with dotted capital I"
    - "@upper on empty string returns empty string"
  artifacts:
    - path: "crates/rlf/src/interpreter/evaluator.rs"
      provides: "Transform execution in eval_template"
      contains: "apply_transforms"
    - path: "crates/rlf/tests/interpreter_transforms.rs"
      provides: "Transform integration tests"
      min_lines: 100
  key_links:
    - from: "crates/rlf/src/interpreter/evaluator.rs"
      to: "TransformRegistry"
      via: "transform lookup and execution"
      pattern: "registry\\.get_transform"
    - from: "crates/rlf/src/interpreter/evaluator.rs"
      to: "TransformKind::execute"
      via: "transform application"
      pattern: "transform_kind\\.execute"
---

<objective>
Wire transform execution into the evaluator and add comprehensive tests for universal transforms.

Purpose: Enable @cap, @upper, @lower transforms to actually process text during template evaluation, with correct right-to-left execution order and context resolution.

Output: Updated evaluator with transform execution, integration tests covering all transform behavior including Turkish edge cases.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-universal-transforms-and-icu4x/03-CONTEXT.md
@.planning/phases/03-universal-transforms-and-icu4x/03-RESEARCH.md
@.planning/phases/03-universal-transforms-and-icu4x/03-01-SUMMARY.md
@crates/rlf/src/interpreter/evaluator.rs
@crates/rlf/src/interpreter/transforms.rs
@crates/rlf/src/parser/ast.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire transforms into evaluator</name>
  <files>crates/rlf/src/interpreter/evaluator.rs</files>
  <action>
Modify eval_template to execute transforms instead of ignoring them.

1. Add TransformRegistry parameter to eval_template and related functions:
```rust
pub fn eval_template(
    template: &Template,
    ctx: &mut EvalContext<'_>,
    registry: &PhraseRegistry,
    transform_registry: &TransformRegistry,  // NEW
    lang: &str,
) -> Result<String, EvalError>
```

Update all call sites (resolve_reference, eval_phrase_def, eval_with_from_modifier, build_phrase_from_variants) to pass transform_registry through.

2. Replace the transforms stub in eval_template's Interpolation handling:
```rust
Segment::Interpolation {
    transforms,
    reference,
    selectors,
} => {
    // 1. Resolve reference to Value
    let value = resolve_reference(reference, ctx, registry, transform_registry, lang)?;
    // 2. Apply selectors to get variant/final value
    let selected = apply_selectors(&value, selectors, ctx, lang)?;
    // 3. Apply transforms (right-to-left per DESIGN.md)
    let transformed = apply_transforms(&selected, transforms, transform_registry, ctx, registry, lang)?;
    output.push_str(&transformed);
}
```

3. Implement apply_transforms function:
```rust
/// Apply transforms to a string value, executing right-to-left.
///
/// Per DESIGN.md: `{@cap @a card}` executes @a first, then @cap.
/// Transforms receive the current value and return transformed string.
fn apply_transforms(
    initial_value: &str,
    transforms: &[Transform],
    transform_registry: &TransformRegistry,
    ctx: &EvalContext<'_>,
    registry: &PhraseRegistry,
    lang: &str,
) -> Result<String, EvalError> {
    if transforms.is_empty() {
        return Ok(initial_value.to_string());
    }

    // Start with the initial value as a string
    let mut current = Value::String(initial_value.to_string());

    // Process right-to-left (reverse iteration)
    for transform in transforms.iter().rev() {
        let transform_kind = transform_registry
            .get(&transform.name, lang)
            .ok_or_else(|| EvalError::UnknownTransform {
                name: transform.name.clone(),
            })?;

        // Resolve context if present (for language-specific transforms in future phases)
        let context_value = if let Some(ctx_selector) = &transform.context {
            Some(resolve_transform_context(ctx_selector, ctx, lang)?)
        } else {
            None
        };

        let result = transform_kind.execute(&current, context_value.as_ref(), lang)?;
        current = Value::String(result);
    }

    Ok(current.to_string())
}

/// Resolve transform context selector to a Value.
///
/// Context can be a literal or parameter reference.
fn resolve_transform_context(
    selector: &Selector,
    ctx: &EvalContext<'_>,
    lang: &str,
) -> Result<Value, EvalError> {
    match selector {
        Selector::Identifier(name) => {
            // Check if this is a parameter reference
            if let Some(value) = ctx.get_param(name) {
                Ok(value.clone())
            } else {
                // Literal context value
                Ok(Value::String(name.clone()))
            }
        }
    }
}
```

4. Update public API in registry.rs to pass transform_registry:
- eval_str needs transform_registry parameter
- call_phrase needs transform_registry parameter
- get_phrase needs transform_registry parameter

Create a convenience method or update the API so callers can use a default TransformRegistry.
  </action>
  <verify>`just review` passes</verify>
  <done>eval_template processes transforms right-to-left using TransformRegistry, public API updated to accept TransformRegistry</done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive transform integration tests</name>
  <files>crates/rlf/tests/interpreter_transforms.rs</files>
  <action>
Create new test file with comprehensive tests for transform execution.

**Test categories:**

1. **Basic case transforms:**
```rust
#[test]
fn test_cap_basic() {
    // "hello" -> "Hello"
}

#[test]
fn test_upper_basic() {
    // "hello" -> "HELLO"
}

#[test]
fn test_lower_basic() {
    // "HELLO" -> "hello"
}
```

2. **Empty string edge cases:**
```rust
#[test]
fn test_cap_empty() {
    // "" -> ""
}

#[test]
fn test_upper_empty() {
    // "" -> ""
}
```

3. **Unicode and grapheme handling:**
```rust
#[test]
fn test_cap_unicode_cyrillic() {
    // "привет" -> "Привет"
}

#[test]
fn test_cap_combining_character() {
    // "e\u{0301}xample" (e + combining acute) -> "E\u{0301}xample"
    // First grapheme is capitalized as a unit
}

#[test]
fn test_upper_greek() {
    // Greek letters
}
```

4. **Turkish locale-sensitive case mapping:**
```rust
#[test]
fn test_upper_turkish_dotted_i() {
    // Turkish: "istanbul" should uppercase to "ISTANBUL" (with dotted capital I)
    // Not "ISTANBUL" which standard Rust would produce
}

#[test]
fn test_lower_turkish_capital_i() {
    // Turkish: "I" (undotted) should lowercase to "ı" (dotless i)
}

#[test]
fn test_cap_turkish() {
    // Turkish: "istanbul" -> "Istanbul" (with dotted capital I)
}
```

5. **Transform execution order:**
```rust
#[test]
fn test_transform_chain_right_to_left() {
    // {@upper @cap x} should: cap first, then upper
    // So "hello" -> "Hello" -> "HELLO"
}

#[test]
fn test_multiple_transforms() {
    // Test chaining multiple transforms
}
```

6. **Unknown transform error:**
```rust
#[test]
fn test_unknown_transform_error() {
    // Using @unknown should return UnknownTransform error
}
```

7. **Integration with templates:**
```rust
#[test]
fn test_transform_in_template() {
    // Parse "{@cap name}" template with params
}

#[test]
fn test_transform_with_phrase_reference() {
    // {@cap phraseName} works correctly
}
```

Use the pattern from existing tests (interpreter_eval.rs, interpreter_foundation.rs):
- Create PhraseRegistry with test phrases
- Create EvalContext with parameters
- Parse templates and evaluate
- Assert expected output

For Turkish tests, use lang="tr" to trigger locale-specific case mapping.
  </action>
  <verify>`just review` passes with all new tests</verify>
  <done>Comprehensive test coverage for all universal transforms including Turkish edge cases, empty strings, Unicode graphemes, and transform chaining</done>
</task>

<task type="auto">
  <name>Task 3: Update existing tests to use TransformRegistry</name>
  <files>crates/rlf/tests/interpreter_eval.rs, crates/rlf/tests/interpreter_foundation.rs</files>
  <action>
Update existing interpreter tests to pass TransformRegistry where needed.

1. If eval_template signature changed, update test calls to pass TransformRegistry::new()
2. If public API (eval_str, call_phrase, get_phrase) changed, update test calls
3. Ensure all existing tests still pass with the new signature

This is a mechanical update - create TransformRegistry::new() and pass it wherever the updated API requires it.
  </action>
  <verify>`just review` passes - all 128+ existing tests still pass</verify>
  <done>All existing tests updated to use new API, no test regressions</done>
</task>

</tasks>

<verification>
1. `just review` passes all checks (format, clippy, tests)
2. Transform tests verify:
   - @cap, @upper, @lower basic functionality
   - Empty string returns empty string
   - Turkish locale-sensitive case mapping
   - Unicode grapheme handling for @cap
   - Right-to-left execution order
   - UnknownTransform error for invalid transform names
3. All existing tests (128+) still pass
4. Total test count increases by ~20+ new transform tests
</verification>

<success_criteria>
- eval_template executes transforms right-to-left
- Transform context is resolved from parameters or literals
- Unknown transforms return UnknownTransform error
- Turkish "istanbul" uppercases correctly with dotted I
- Empty string edge cases handled
- Combining characters handled correctly in @cap
- All existing tests pass
- New transform test file with comprehensive coverage
- `just review` passes
</success_criteria>

<output>
After completion, create `.planning/phases/03-universal-transforms-and-icu4x/03-02-SUMMARY.md`
</output>
