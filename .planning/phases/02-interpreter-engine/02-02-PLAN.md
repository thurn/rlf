---
phase: 02-interpreter-engine
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - crates/rlf/src/interpreter/evaluator.rs
  - crates/rlf/src/interpreter/mod.rs
  - crates/rlf/src/interpreter/registry.rs
  - crates/rlf/src/types/phrase_id.rs
  - crates/rlf/tests/interpreter_eval.rs
autonomous: true

must_haves:
  truths:
    - "eval_str evaluates templates with parameters and returns formatted string"
    - "call_phrase resolves phrase by name, passes arguments, returns Phrase"
    - "get_phrase retrieves parameterless phrase as Phrase value"
    - "Variant selection uses dot-notation fallback (nom.one -> nom)"
    - "Numeric selectors map to CLDR plural categories"
    - "Tag-based selection reads first tag and uses as variant key"
    - "Metadata inheritance (:from modifier) copies tags and evaluates per-variant"
    - "Cycle detection prevents infinite recursion between phrases"
    - "Max depth limit of 64 prevents deeply nested evaluations"
  artifacts:
    - path: "crates/rlf/src/interpreter/evaluator.rs"
      provides: "Template evaluation engine"
      exports: ["eval_template", "resolve_reference", "apply_selectors"]
    - path: "crates/rlf/tests/interpreter_eval.rs"
      provides: "Integration tests for evaluation"
      min_lines: 100
  key_links:
    - from: "crates/rlf/src/interpreter/evaluator.rs"
      to: "crates/rlf/src/interpreter/registry.rs"
      via: "phrase lookup during evaluation"
      pattern: "registry\\.get"
    - from: "crates/rlf/src/interpreter/evaluator.rs"
      to: "crates/rlf/src/interpreter/plural.rs"
      via: "CLDR plural category for numeric selection"
      pattern: "plural_category"
    - from: "crates/rlf/src/interpreter/evaluator.rs"
      to: "crates/rlf/src/interpreter/context.rs"
      via: "cycle detection and depth tracking"
      pattern: "ctx\\.push_call|ctx\\.pop_call"
---

<objective>
Template evaluation engine: eval_str, call_phrase, get_phrase, variant resolution, and all evaluation logic

Purpose: Implement the core evaluation that transforms parsed templates into formatted strings. This is the heart of the interpreter - resolving references, applying selectors, building variant keys, and handling phrase calls with cycle detection.

Output: Complete evaluator module with public API matching APPENDIX_RUNTIME_INTERPRETER.md
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-interpreter-engine/02-CONTEXT.md
@.planning/phases/02-interpreter-engine/02-RESEARCH.md
@.planning/phases/02-interpreter-engine/02-01-SUMMARY.md

# Source files
@crates/rlf/src/parser/ast.rs
@crates/rlf/src/types/phrase.rs
@crates/rlf/src/types/value.rs
@docs/APPENDIX_RUNTIME_INTERPRETER.md
@docs/DESIGN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create evaluator with template evaluation and reference resolution</name>
  <files>
    crates/rlf/src/interpreter/evaluator.rs
    crates/rlf/src/interpreter/mod.rs
  </files>
  <action>
Create `crates/rlf/src/interpreter/evaluator.rs` with core evaluation logic:

1. **Imports and helper types:**
   ```rust
   use crate::parser::ast::{
       PhraseBody, PhraseDefinition, Reference, Segment, Selector, Template, Transform,
       VariantEntry,
   };
   use crate::types::{Phrase, Tag, Value, VariantKey};
   use crate::interpreter::{EvalContext, EvalError, PhraseRegistry};
   use crate::interpreter::plural::plural_category;
   use std::collections::HashMap;
   ```

2. **eval_template function** - evaluates a Template AST:
   ```rust
   pub fn eval_template(
       template: &Template,
       ctx: &mut EvalContext<'_>,
       registry: &PhraseRegistry,
       lang: &str,
   ) -> Result<String, EvalError> {
       let mut output = String::new();
       for segment in &template.segments {
           match segment {
               Segment::Literal(s) => output.push_str(s),
               Segment::Interpolation {
                   transforms,
                   reference,
                   selectors,
               } => {
                   // 1. Resolve reference to Value
                   let value = resolve_reference(reference, ctx, registry, lang)?;
                   // 2. Apply selectors to get variant/final value
                   let selected = apply_selectors(&value, selectors, ctx, lang)?;
                   // 3. Transforms are stub for Phase 3 - just pass through
                   // (transforms vec is available for Phase 3 to process)
                   let _ = transforms; // silence unused warning until Phase 3
                   output.push_str(&selected.to_string());
               }
           }
       }
       Ok(output)
   }
   ```

3. **resolve_reference function** - resolves Reference to Value:
   - Check parameters first (ctx.get_param)
   - Then try phrase lookup (registry.get)
   - For PhraseCall, resolve args and call eval_phrase_def
   - Handle cycle detection via ctx.push_call/pop_call

4. **eval_phrase_def function** - evaluates a PhraseDefinition:
   - Create child EvalContext with new params (no scope inheritance per RESEARCH.md recommendation)
   - Handle PhraseBody::Simple - eval_template, return Phrase with text and definition's tags
   - Handle PhraseBody::Variants - evaluate to Phrase with variants populated and tags
   - Handle :from modifier for metadata inheritance (INTERP-15):
     ```rust
     // When phrase has :from(param_name) modifier:
     // 1. Get the source phrase from the parameter
     let source = ctx.get_param(from_param)?.as_phrase()?;
     // 2. Copy tags from source phrase
     let inherited_tags = source.tags.clone();
     // 3. If source has variants, evaluate template once per variant:
     let mut variants = HashMap::new();
     for (key, variant_text) in &source.variants {
         // Replace {param_name} with variant_text, eval template
         let result = eval_with_substituted_param(template, from_param, variant_text, ctx, ...)?;
         variants.insert(key.clone(), result);
     }
     // 4. Return Phrase with inherited tags and computed variants
     Ok(Phrase { text: default_text, variants, tags: inherited_tags })
     ```
   - This enables `subtype(s) = :from(s) "<b>{s}</b>";` to inherit s's tags/variants

5. **apply_selectors function** - applies selectors to a Value:
   - For each selector, resolve to a key string
   - Build compound key with "." separator for chained selectors
   - Look up variant in Phrase, or return the value if no variants

6. **resolve_selector function** - resolves a Selector to a key string:
   - If selector name matches a parameter:
     - Number -> plural_category(lang, n)
     - Phrase -> first tag (or error if no tag)
     - String -> try parse as number, else use literally
   - Otherwise -> literal key string

7. **variant_lookup function** - looks up variant with fallback:
   - Try exact key
   - Progressively strip trailing ".segment"
   - Return MissingVariant error if no match

8. **build_phrase_from_variants function** - builds Phrase from VariantEntry list:
   - Evaluate each variant template
   - Use first entry's text as default .text
   - Populate variants HashMap

Update `mod.rs` to export evaluator functions and add `mod evaluator;`
  </action>
  <verify>
    `cargo build -p rlf` succeeds
    `cargo clippy -p rlf` has no errors
  </verify>
  <done>
    eval_template processes Segment::Literal and Segment::Interpolation.
    resolve_reference handles Identifier and PhraseCall.
    apply_selectors builds compound keys from selector chain.
    resolve_selector uses CLDR for numbers, first tag for phrases.
    variant_lookup implements fallback resolution.
    Transforms are stubbed (pass-through) for Phase 3.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add public API functions and PhraseId resolution</name>
  <files>
    crates/rlf/src/interpreter/registry.rs
    crates/rlf/src/interpreter/mod.rs
    crates/rlf/src/types/phrase_id.rs
  </files>
  <action>
1. Add public API methods to PhraseRegistry (in registry.rs):

   ```rust
   impl PhraseRegistry {
       /// Evaluate a template string with parameters.
       /// This is the main entry point for runtime template evaluation.
       pub fn eval_str(
           &self,
           template_str: &str,
           lang: &str,
           params: HashMap<String, Value>,
       ) -> Result<Phrase, EvalError> {
           use crate::parser::parse_template;
           let template = parse_template(template_str).map_err(|e| EvalError::PhraseNotFound {
               name: format!("parse error: {}", e),
           })?;
           let mut ctx = EvalContext::new(&params);
           let text = eval_template(&template, &mut ctx, self, lang)?;
           Ok(Phrase::builder().text(text).build())
       }

       /// Call a phrase by name with positional arguments.
       pub fn call_phrase(
           &self,
           lang: &str,
           name: &str,
           args: &[Value],
       ) -> Result<Phrase, EvalError> {
           let def = self
               .get(name)
               .ok_or_else(|| EvalError::PhraseNotFound { name: name.to_string() })?;

           // Check argument count
           if def.parameters.len() != args.len() {
               return Err(EvalError::ArgumentCount {
                   phrase: name.to_string(),
                   expected: def.parameters.len(),
                   got: args.len(),
               });
           }

           // Build param map
           let params: HashMap<String, Value> = def
               .parameters
               .iter()
               .zip(args.iter())
               .map(|(name, value)| (name.clone(), value.clone()))
               .collect();

           let mut ctx = EvalContext::new(&params);
           ctx.push_call(name)?;
           let result = eval_phrase_def(def, &mut ctx, self, lang)?;
           ctx.pop_call();
           Ok(result)
       }

       /// Get a parameterless phrase as a Phrase value.
       pub fn get_phrase(&self, lang: &str, name: &str) -> Result<Phrase, EvalError> {
           let def = self
               .get(name)
               .ok_or_else(|| EvalError::PhraseNotFound { name: name.to_string() })?;

           if !def.parameters.is_empty() {
               return Err(EvalError::ArgumentCount {
                   phrase: name.to_string(),
                   expected: def.parameters.len(),
                   got: 0,
               });
           }

           let params = HashMap::new();
           let mut ctx = EvalContext::new(&params);
           ctx.push_call(name)?;
           let result = eval_phrase_def(def, &mut ctx, self, lang)?;
           ctx.pop_call();
           Ok(result)
       }

       /// Call a phrase by PhraseId with arguments.
       pub fn call_phrase_by_id(
           &self,
           id: u64,
           lang: &str,
           args: &[Value],
       ) -> Result<Phrase, EvalError> {
           let name = self
               .id_to_name
               .get(&id)
               .ok_or(EvalError::PhraseNotFoundById { id })?;
           self.call_phrase(lang, name, args)
       }

       /// Get a phrase by PhraseId (parameterless only).
       pub fn get_phrase_by_id(&self, id: u64, lang: &str) -> Result<Phrase, EvalError> {
           let name = self
               .id_to_name
               .get(&id)
               .ok_or(EvalError::PhraseNotFoundById { id })?;
           self.get_phrase(lang, name)
       }

       /// Get the parameter count for a phrase by id.
       pub fn phrase_parameter_count(&self, id: u64) -> usize {
           self.id_to_name
               .get(&id)
               .and_then(|name| self.get(name))
               .map(|def| def.parameters.len())
               .unwrap_or(0)
       }
   }
   ```

2. Add parse_template export to parser module if not already available:
   - In `crates/rlf/src/parser/mod.rs`, ensure `pub use template::parse_template;`

3. Update PhraseId in `crates/rlf/src/types/phrase_id.rs` to add resolution methods:
   Note: Full implementation requires Locale (Phase 4). For now, add placeholder methods that work with PhraseRegistry directly:

   ```rust
   impl PhraseId {
       // ... existing methods ...

       /// Resolve using a registry directly (for use before Locale exists).
       /// Full resolve(&Locale) method will be added in Phase 4.
       pub fn resolve_with_registry(
           &self,
           registry: &crate::interpreter::PhraseRegistry,
           lang: &str,
       ) -> Result<crate::Phrase, crate::interpreter::EvalError> {
           registry.get_phrase_by_id(self.0, lang)
       }

       /// Call using a registry directly (for use before Locale exists).
       /// Full call(&Locale, &[Value]) method will be added in Phase 4.
       pub fn call_with_registry(
           &self,
           registry: &crate::interpreter::PhraseRegistry,
           lang: &str,
           args: &[crate::Value],
       ) -> Result<crate::Phrase, crate::interpreter::EvalError> {
           registry.call_phrase_by_id(self.0, lang, args)
       }
   }
   ```

4. Export from interpreter/mod.rs:
   - `pub use evaluator::{eval_template, eval_phrase_def};`
  </action>
  <verify>
    `cargo build -p rlf` succeeds
    `cargo clippy -p rlf` has no errors
  </verify>
  <done>
    eval_str parses and evaluates template strings.
    call_phrase calls phrase by name with argument validation.
    get_phrase retrieves parameterless phrases.
    call_phrase_by_id and get_phrase_by_id work via PhraseId.
    PhraseId has resolve_with_registry and call_with_registry methods.
  </done>
</task>

<task type="auto">
  <name>Task 3: Comprehensive integration tests for evaluation</name>
  <files>
    crates/rlf/tests/interpreter_eval.rs
  </files>
  <action>
Create `crates/rlf/tests/interpreter_eval.rs` with comprehensive tests:

```rust
//! Integration tests for interpreter evaluation.

use rlf::interpreter::{EvalError, PhraseRegistry};
use rlf::{PhraseId, Value};
use std::collections::HashMap;

// === Basic Template Evaluation ===

#[test]
fn eval_literal_only() {
    let mut registry = PhraseRegistry::new();
    registry.load_phrases(r#"hello = "Hello, world!";"#).unwrap();
    let result = registry.get_phrase("en", "hello").unwrap();
    assert_eq!(result.to_string(), "Hello, world!");
}

#[test]
fn eval_with_parameter() {
    let mut registry = PhraseRegistry::new();
    registry.load_phrases(r#"greet(name) = "Hello, {name}!";"#).unwrap();
    let result = registry.call_phrase("en", "greet", &[Value::from("World")]).unwrap();
    assert_eq!(result.to_string(), "Hello, World!");
}

#[test]
fn eval_with_number_parameter() {
    let mut registry = PhraseRegistry::new();
    registry.load_phrases(r#"count(n) = "Count: {n}";"#).unwrap();
    let result = registry.call_phrase("en", "count", &[Value::from(42)]).unwrap();
    assert_eq!(result.to_string(), "Count: 42");
}

// === Variant Selection ===

#[test]
fn eval_literal_variant_selector() {
    let mut registry = PhraseRegistry::new();
    registry.load_phrases(r#"
        card = { one: "card", other: "cards" };
        all_cards = "All {card:other}.";
    "#).unwrap();
    let result = registry.get_phrase("en", "all_cards").unwrap();
    assert_eq!(result.to_string(), "All cards.");
}

#[test]
fn eval_numeric_variant_selector_english() {
    let mut registry = PhraseRegistry::new();
    registry.load_phrases(r#"
        card = { one: "card", other: "cards" };
        draw(n) = "Draw {n} {card:n}.";
    "#).unwrap();

    let one = registry.call_phrase("en", "draw", &[Value::from(1)]).unwrap();
    assert_eq!(one.to_string(), "Draw 1 card.");

    let five = registry.call_phrase("en", "draw", &[Value::from(5)]).unwrap();
    assert_eq!(five.to_string(), "Draw 5 cards.");
}

#[test]
fn eval_numeric_variant_selector_russian() {
    let mut registry = PhraseRegistry::new();
    registry.load_phrases(r#"
        card = { one: "карта", few: "карты", many: "карт", other: "карты" };
        draw(n) = "Возьмите {n} {card:n}.";
    "#).unwrap();

    let one = registry.call_phrase("ru", "draw", &[Value::from(1)]).unwrap();
    assert_eq!(one.to_string(), "Возьмите 1 карта.");

    let two = registry.call_phrase("ru", "draw", &[Value::from(2)]).unwrap();
    assert_eq!(two.to_string(), "Возьмите 2 карты.");

    let five = registry.call_phrase("ru", "draw", &[Value::from(5)]).unwrap();
    assert_eq!(five.to_string(), "Возьмите 5 карт.");

    let twenty_one = registry.call_phrase("ru", "draw", &[Value::from(21)]).unwrap();
    assert_eq!(twenty_one.to_string(), "Возьмите 21 карта.");
}

// === Multi-dimensional Variants ===

#[test]
fn eval_multidimensional_variant() {
    let mut registry = PhraseRegistry::new();
    registry.load_phrases(r#"
        card = {
            nom.one: "карта",
            nom.few: "карты",
            nom.many: "карт",
            acc.one: "карту",
            acc.few: "карты",
            acc.many: "карт",
        };
        draw(n) = "Возьмите {card:acc:n}.";
    "#).unwrap();

    let one = registry.call_phrase("ru", "draw", &[Value::from(1)]).unwrap();
    assert_eq!(one.to_string(), "Возьмите карту.");

    let five = registry.call_phrase("ru", "draw", &[Value::from(5)]).unwrap();
    assert_eq!(five.to_string(), "Возьмите карт.");
}

#[test]
fn eval_variant_fallback() {
    let mut registry = PhraseRegistry::new();
    // "nom" is fallback for nom.one, nom.few, etc.
    registry.load_phrases(r#"
        card = {
            nom: "card-nom",
            nom.other: "cards-nom-other",
            acc: "card-acc",
        };
        test_nom_one = "{card:nom.one}";
        test_nom_other = "{card:nom.other}";
        test_acc_one = "{card:acc.one}";
    "#).unwrap();

    // nom.one -> fallback to nom
    let nom_one = registry.get_phrase("en", "test_nom_one").unwrap();
    assert_eq!(nom_one.to_string(), "card-nom");

    // nom.other -> exact match
    let nom_other = registry.get_phrase("en", "test_nom_other").unwrap();
    assert_eq!(nom_other.to_string(), "cards-nom-other");

    // acc.one -> fallback to acc
    let acc_one = registry.get_phrase("en", "test_acc_one").unwrap();
    assert_eq!(acc_one.to_string(), "card-acc");
}

// === Tag-based Selection ===

#[test]
fn eval_tag_based_selection() {
    let mut registry = PhraseRegistry::new();
    registry.load_phrases(r#"
        destroyed = { masc: "destruido", fem: "destruida" };
        card = :fem "carta";
        enemy = :masc "enemigo";
        destroy(thing) = "{thing} fue {destroyed:thing}.";
    "#).unwrap();

    // card has :fem tag -> selects "destruida"
    let card = registry.get_phrase("es", "card").unwrap();
    let card_destroyed = registry.call_phrase("es", "destroy", &[Value::Phrase(card)]).unwrap();
    assert_eq!(card_destroyed.to_string(), "carta fue destruida.");

    // enemy has :masc tag -> selects "destruido"
    let enemy = registry.get_phrase("es", "enemy").unwrap();
    let enemy_destroyed = registry.call_phrase("es", "destroy", &[Value::Phrase(enemy)]).unwrap();
    assert_eq!(enemy_destroyed.to_string(), "enemigo fue destruido.");
}

// === Phrase Calls with Arguments ===

#[test]
fn eval_phrase_call_in_template() {
    let mut registry = PhraseRegistry::new();
    registry.load_phrases(r#"
        card = { one: "card", other: "cards" };
        draw(n) = "Draw {n} {card:n}.";
        draw_and_play(n) = "{draw(n)} Then play one.";
    "#).unwrap();

    let result = registry.call_phrase("en", "draw_and_play", &[Value::from(3)]).unwrap();
    assert_eq!(result.to_string(), "Draw 3 cards. Then play one.");
}

// === Phrase as Return Value ===

#[test]
fn get_phrase_returns_phrase_with_variants() {
    let mut registry = PhraseRegistry::new();
    registry.load_phrases(r#"
        card = { one: "card", other: "cards" };
    "#).unwrap();

    let phrase = registry.get_phrase("en", "card").unwrap();
    assert_eq!(phrase.to_string(), "card"); // default is first variant
    assert_eq!(phrase.variant("one"), "card");
    assert_eq!(phrase.variant("other"), "cards");
}

#[test]
fn get_phrase_with_tags() {
    let mut registry = PhraseRegistry::new();
    registry.load_phrases(r#"
        card = :a "card";
        event = :an "event";
    "#).unwrap();

    let card = registry.get_phrase("en", "card").unwrap();
    assert!(card.has_tag("a"));
    assert!(!card.has_tag("an"));

    let event = registry.get_phrase("en", "event").unwrap();
    assert!(event.has_tag("an"));
}

// === eval_str ===

#[test]
fn eval_str_basic() {
    let mut registry = PhraseRegistry::new();
    registry.load_phrases(r#"
        card = { one: "card", other: "cards" };
    "#).unwrap();

    let params: HashMap<String, Value> = [("n".to_string(), Value::from(3))].into_iter().collect();
    let result = registry.eval_str("Draw {n} {card:n}.", "en", params).unwrap();
    assert_eq!(result.to_string(), "Draw 3 cards.");
}

// === PhraseId Resolution ===

#[test]
fn phrase_id_resolve() {
    let mut registry = PhraseRegistry::new();
    registry.load_phrases(r#"hello = "Hello!";"#).unwrap();

    let id = PhraseId::from_name("hello");
    let phrase = id.resolve_with_registry(&registry, "en").unwrap();
    assert_eq!(phrase.to_string(), "Hello!");
}

#[test]
fn phrase_id_call() {
    let mut registry = PhraseRegistry::new();
    registry.load_phrases(r#"greet(name) = "Hello, {name}!";"#).unwrap();

    let id = PhraseId::from_name("greet");
    let phrase = id.call_with_registry(&registry, "en", &[Value::from("World")]).unwrap();
    assert_eq!(phrase.to_string(), "Hello, World!");
}

// === Error Cases ===

#[test]
fn error_phrase_not_found() {
    let registry = PhraseRegistry::new();
    let err = registry.get_phrase("en", "missing").unwrap_err();
    assert!(matches!(err, EvalError::PhraseNotFound { name } if name == "missing"));
}

#[test]
fn error_argument_count() {
    let mut registry = PhraseRegistry::new();
    registry.load_phrases(r#"greet(name) = "Hello, {name}!";"#).unwrap();

    // Too few args
    let err = registry.call_phrase("en", "greet", &[]).unwrap_err();
    assert!(matches!(err, EvalError::ArgumentCount { expected: 1, got: 0, .. }));

    // Too many args
    let err = registry.call_phrase("en", "greet", &[Value::from("a"), Value::from("b")]).unwrap_err();
    assert!(matches!(err, EvalError::ArgumentCount { expected: 1, got: 2, .. }));
}

#[test]
fn error_missing_variant() {
    let mut registry = PhraseRegistry::new();
    registry.load_phrases(r#"
        card = { one: "card", other: "cards" };
        bad = "{card:accusative}";
    "#).unwrap();

    let err = registry.get_phrase("en", "bad").unwrap_err();
    assert!(matches!(err, EvalError::MissingVariant { key, .. } if key == "accusative"));
}

#[test]
fn error_cyclic_reference() {
    let mut registry = PhraseRegistry::new();
    registry.load_phrases(r#"
        a = "see {b}";
        b = "see {c}";
        c = "see {a}";
    "#).unwrap();

    let err = registry.get_phrase("en", "a").unwrap_err();
    assert!(matches!(err, EvalError::CyclicReference { chain } if chain.contains(&"a".to_string())));
}

#[test]
fn error_max_depth() {
    // Create a deep chain that doesn't cycle but exceeds depth
    let mut content = String::new();
    for i in 0..70 {
        content.push_str(&format!("p{} = \"{{p{}}}\";\n", i, i + 1));
    }
    content.push_str("p70 = \"end\";\n");

    let mut registry = PhraseRegistry::new();
    registry.load_phrases(&content).unwrap();

    let err = registry.get_phrase("en", "p0").unwrap_err();
    assert!(matches!(err, EvalError::MaxDepthExceeded));
}

// === Metadata Inheritance (:from) ===

#[test]
fn eval_from_modifier_inherits_tags() {
    let mut registry = PhraseRegistry::new();
    registry.load_phrases(r#"
        ancient = :an { one: "Ancient", other: "Ancients" };
        subtype(s) = :from(s) "<b>{s}</b>";
    "#).unwrap();

    let ancient = registry.get_phrase("en", "ancient").unwrap();
    let subtype = registry.call_phrase("en", "subtype", &[Value::Phrase(ancient)]).unwrap();

    // Should inherit :an tag from ancient
    assert!(subtype.has_tag("an"));
    // Should have variants from evaluating template with each variant
    assert_eq!(subtype.variant("one"), "<b>Ancient</b>");
    assert_eq!(subtype.variant("other"), "<b>Ancients</b>");
}

// === Escape Sequences ===

#[test]
fn eval_escape_sequences() {
    let mut registry = PhraseRegistry::new();
    registry.load_phrases(r#"
        braces = "Use {{name}} for interpolation.";
        at_sign = "Use @@ for transforms.";
        colon = "Ratio 1::2.";
    "#).unwrap();

    assert_eq!(registry.get_phrase("en", "braces").unwrap().to_string(), "Use {name} for interpolation.");
    assert_eq!(registry.get_phrase("en", "at_sign").unwrap().to_string(), "Use @ for transforms.");
    assert_eq!(registry.get_phrase("en", "colon").unwrap().to_string(), "Ratio 1:2.");
}
```
  </action>
  <verify>
    `cargo test -p rlf` passes all tests
    `cargo clippy -p rlf` has no warnings
    Test count increased significantly (should have 20+ new tests)
  </verify>
  <done>
    All evaluation scenarios tested:
    - Literal templates
    - Parameter substitution
    - Variant selection (literal, numeric, tag-based)
    - Multi-dimensional variants with fallback
    - Phrase calls with arguments
    - Phrase return with variants and tags
    - eval_str API
    - PhraseId resolution
    - All error cases (not found, arg count, missing variant, cycle, depth)
    - Escape sequences
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. `cargo build -p rlf` - compiles without errors
2. `cargo test -p rlf` - all tests pass (84 existing + foundation + eval tests)
3. `cargo clippy -p rlf` - no warnings
4. Public API available:
   - `registry.eval_str(template, lang, params)` -> Result<Phrase, EvalError>
   - `registry.call_phrase(lang, name, args)` -> Result<Phrase, EvalError>
   - `registry.get_phrase(lang, name)` -> Result<Phrase, EvalError>
   - `registry.call_phrase_by_id(id, lang, args)` -> Result<Phrase, EvalError>
   - `registry.get_phrase_by_id(id, lang)` -> Result<Phrase, EvalError>
   - `PhraseId::resolve_with_registry(&registry, lang)` -> Result<Phrase, EvalError>
   - `PhraseId::call_with_registry(&registry, lang, args)` -> Result<Phrase, EvalError>
</verification>

<success_criteria>
1. eval_str evaluates arbitrary template strings with parameters
2. call_phrase resolves phrase by name and validates argument count
3. get_phrase retrieves parameterless phrases as Phrase values
4. Numeric selectors use CLDR plural categories (tested for English, Russian)
5. Literal selectors use key directly
6. Tag-based selection reads first tag from Phrase parameter
7. Multi-dimensional keys work with dot notation (nom.one, acc.many)
8. Variant fallback works (nom.one -> nom when nom.one missing)
9. Cycle detection catches a -> b -> a patterns
10. Max depth (64) catches deeply nested but non-cyclic patterns
11. Error messages are descriptive with available variants listed
</success_criteria>

<output>
After completion, create `.planning/phases/02-interpreter-engine/02-02-SUMMARY.md`
</output>
