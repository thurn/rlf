---
phase: 02-interpreter-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/rlf/src/interpreter/mod.rs
  - crates/rlf/src/interpreter/error.rs
  - crates/rlf/src/interpreter/registry.rs
  - crates/rlf/src/interpreter/context.rs
  - crates/rlf/src/interpreter/plural.rs
  - crates/rlf/src/lib.rs
  - crates/rlf/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "PhraseRegistry can store and retrieve phrase definitions by name"
    - "PhraseRegistry can retrieve phrases by PhraseId hash"
    - "EvalContext tracks call stack, depth, and parameters"
    - "EvalError variants cover all interpreter failure modes"
    - "Plural category resolves numbers to CLDR categories for any supported language"
  artifacts:
    - path: "crates/rlf/src/interpreter/error.rs"
      provides: "EvalError enum with all required variants"
      exports: ["EvalError"]
    - path: "crates/rlf/src/interpreter/registry.rs"
      provides: "PhraseRegistry with phrase storage and lookup"
      exports: ["PhraseRegistry"]
    - path: "crates/rlf/src/interpreter/context.rs"
      provides: "EvalContext for evaluation state"
      exports: ["EvalContext"]
    - path: "crates/rlf/src/interpreter/plural.rs"
      provides: "CLDR plural category resolution"
      exports: ["plural_category"]
  key_links:
    - from: "crates/rlf/src/interpreter/registry.rs"
      to: "crates/rlf/src/parser/ast.rs"
      via: "PhraseDefinition storage"
      pattern: "PhraseDefinition"
    - from: "crates/rlf/src/interpreter/registry.rs"
      to: "crates/rlf/src/types/phrase_id.rs"
      via: "PhraseId hash lookup"
      pattern: "PhraseId::from_name"
---

<objective>
Interpreter foundation: error types, phrase registry, evaluation context, and CLDR plural rules

Purpose: Establish the core infrastructure that the evaluator will use. The registry stores loaded phrases per language, context tracks evaluation state for cycle detection and depth limiting, and plural rules enable numeric selection.

Output: `interpreter` module with EvalError, PhraseRegistry, EvalContext, and plural_category function
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-interpreter-engine/02-CONTEXT.md
@.planning/phases/02-interpreter-engine/02-RESEARCH.md

# Source files to understand
@crates/rlf/src/parser/ast.rs
@crates/rlf/src/types/phrase_id.rs
@crates/rlf/src/types/value.rs
@docs/APPENDIX_RUNTIME_INTERPRETER.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create interpreter module structure with EvalError and PhraseRegistry</name>
  <files>
    crates/rlf/src/interpreter/mod.rs
    crates/rlf/src/interpreter/error.rs
    crates/rlf/src/interpreter/registry.rs
    crates/rlf/src/lib.rs
    crates/rlf/Cargo.toml
  </files>
  <action>
1. Add `thiserror = "2"` to Cargo.toml dependencies (already has bon, winnow, serde, const-fnv1a-hash)

2. Create `crates/rlf/src/interpreter/mod.rs`:
   - Declare submodules: `mod error; mod registry; mod context; mod plural;`
   - Re-export: `pub use error::EvalError; pub use registry::PhraseRegistry; pub use context::EvalContext;`

3. Create `crates/rlf/src/interpreter/error.rs` with EvalError enum:
   ```rust
   use thiserror::Error;

   #[derive(Debug, Error)]
   pub enum EvalError {
       #[error("phrase not found: '{name}'")]
       PhraseNotFound { name: String },

       #[error("phrase not found for id: {id}")]
       PhraseNotFoundById { id: u64 },

       #[error("missing variant '{key}' in phrase '{phrase}', available: {}", available.join(", "))]
       MissingVariant {
           phrase: String,
           key: String,
           available: Vec<String>,
       },

       #[error("transform '@{transform}' requires tag {expected:?} on phrase '{phrase}'")]
       MissingTag {
           transform: String,
           expected: Vec<String>,
           phrase: String,
       },

       #[error("phrase '{phrase}' expects {expected} arguments, got {got}")]
       ArgumentCount {
           phrase: String,
           expected: usize,
           got: usize,
       },

       #[error("cyclic reference detected: {}", chain.join(" -> "))]
       CyclicReference { chain: Vec<String> },

       #[error("maximum recursion depth exceeded")]
       MaxDepthExceeded,
   }
   ```

4. Create `crates/rlf/src/interpreter/registry.rs`:
   - Import `PhraseDefinition` from parser/ast
   - Import `PhraseId` from types
   - Struct `PhraseRegistry`:
     - `phrases: HashMap<String, PhraseDefinition>` (by name)
     - `id_to_name: HashMap<u64, String>` (PhraseId hash to name)
   - Methods:
     - `new() -> Self`
     - `get(&self, name: &str) -> Option<&PhraseDefinition>`
     - `get_by_id(&self, id: u64) -> Option<&PhraseDefinition>`
     - `insert(&mut self, def: PhraseDefinition) -> Result<(), EvalError>` - detect hash collisions

5. Update `crates/rlf/src/lib.rs`:
   - Add `pub mod interpreter;`
   - Add to exports: `pub use interpreter::{EvalError, PhraseRegistry, EvalContext};`
  </action>
  <verify>
    `cargo build -p rlf` succeeds with new module structure
  </verify>
  <done>
    EvalError has all 7 variants matching APPENDIX_RUNTIME_INTERPRETER.md.
    PhraseRegistry can store/retrieve phrases by name and by PhraseId hash.
    Module is exported from lib.rs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create EvalContext and plural category resolution</name>
  <files>
    crates/rlf/src/interpreter/context.rs
    crates/rlf/src/interpreter/plural.rs
    crates/rlf/src/interpreter/mod.rs
    crates/rlf/Cargo.toml
  </files>
  <action>
1. Add ICU4X dependencies to Cargo.toml:
   ```toml
   icu_plurals = "2"
   icu_locale_core = "2"
   ```

2. Create `crates/rlf/src/interpreter/context.rs`:
   ```rust
   use crate::types::Value;
   use crate::interpreter::EvalError;
   use std::collections::HashMap;

   /// Evaluation context carrying state through recursive evaluation.
   pub struct EvalContext<'a> {
       /// Parameters available during evaluation
       params: &'a HashMap<String, Value>,
       /// Call stack for cycle detection (phrase names)
       call_stack: Vec<String>,
       /// Current recursion depth
       depth: usize,
       /// Maximum allowed depth (default 64)
       max_depth: usize,
   }

   impl<'a> EvalContext<'a> {
       /// Create new context with parameters.
       pub fn new(params: &'a HashMap<String, Value>) -> Self {
           Self {
               params,
               call_stack: Vec::new(),
               depth: 0,
               max_depth: 64,
           }
       }

       /// Create context with custom max depth.
       pub fn with_max_depth(params: &'a HashMap<String, Value>, max_depth: usize) -> Self {
           Self {
               params,
               call_stack: Vec::new(),
               depth: 0,
               max_depth,
           }
       }

       /// Get a parameter value.
       pub fn get_param(&self, name: &str) -> Option<&Value> {
           self.params.get(name)
       }

       /// Check if a name is in the current call stack (cycle detection).
       pub fn is_in_call_stack(&self, name: &str) -> bool {
           self.call_stack.iter().any(|n| n == name)
       }

       /// Push a phrase call onto the stack. Returns error if cycle or depth exceeded.
       pub fn push_call(&mut self, name: &str) -> Result<(), EvalError> {
           if self.depth >= self.max_depth {
               return Err(EvalError::MaxDepthExceeded);
           }
           if self.is_in_call_stack(name) {
               let mut chain = self.call_stack.clone();
               chain.push(name.to_string());
               return Err(EvalError::CyclicReference { chain });
           }
           self.call_stack.push(name.to_string());
           self.depth += 1;
           Ok(())
       }

       /// Pop a phrase call from the stack.
       pub fn pop_call(&mut self) {
           self.call_stack.pop();
           if self.depth > 0 {
               self.depth -= 1;
           }
       }

       /// Get current recursion depth.
       pub fn depth(&self) -> usize {
           self.depth
       }

       /// Get the call stack for error reporting.
       pub fn call_stack(&self) -> &[String] {
           &self.call_stack
       }
   }
   ```

3. Create `crates/rlf/src/interpreter/plural.rs`:
   ```rust
   use icu_plurals::{PluralCategory, PluralRuleType, PluralRules};
   use icu_locale_core::locale;

   /// Get CLDR plural category for a number in a given language.
   ///
   /// Returns one of: "zero", "one", "two", "few", "many", "other"
   pub fn plural_category(lang: &str, n: i64) -> &'static str {
       let loc = match lang {
           "en" => locale!("en"),
           "ru" => locale!("ru"),
           "ar" => locale!("ar"),
           "de" => locale!("de"),
           "es" => locale!("es"),
           "fr" => locale!("fr"),
           "it" => locale!("it"),
           "pt" => locale!("pt"),
           "ja" => locale!("ja"),
           "zh" => locale!("zh"),
           "ko" => locale!("ko"),
           "nl" => locale!("nl"),
           "pl" => locale!("pl"),
           "tr" => locale!("tr"),
           "uk" => locale!("uk"),
           "vi" => locale!("vi"),
           "th" => locale!("th"),
           "id" => locale!("id"),
           "el" => locale!("el"),
           "ro" => locale!("ro"),
           "fa" => locale!("fa"),
           "bn" => locale!("bn"),
           "hi" => locale!("hi"),
           "he" => locale!("he"),
           _ => locale!("en"), // fallback
       };

       let rules = PluralRules::try_new(loc.into(), PluralRuleType::Cardinal)
           .expect("locale should be supported");

       match rules.category_for(n) {
           PluralCategory::Zero => "zero",
           PluralCategory::One => "one",
           PluralCategory::Two => "two",
           PluralCategory::Few => "few",
           PluralCategory::Many => "many",
           PluralCategory::Other => "other",
       }
   }
   ```

4. Update `crates/rlf/src/interpreter/mod.rs` to export:
   - `pub use context::EvalContext;`
   - `pub use plural::plural_category;`
  </action>
  <verify>
    `cargo build -p rlf` succeeds.
    `cargo test -p rlf` all existing tests still pass.
  </verify>
  <done>
    EvalContext tracks params, call_stack, depth with push_call/pop_call methods.
    Cycle detection returns CyclicReference error with chain.
    Depth limit returns MaxDepthExceeded error.
    plural_category function returns CLDR category for 24+ languages.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add load_phrases function and integration tests</name>
  <files>
    crates/rlf/src/interpreter/registry.rs
    crates/rlf/src/interpreter/mod.rs
    crates/rlf/tests/interpreter_foundation.rs
  </files>
  <action>
1. Add `load_phrases` function to registry.rs:
   ```rust
   use crate::parser::parse_file;
   use crate::parser::ParseError;

   impl PhraseRegistry {
       /// Load phrases from a string containing .rlf format.
       /// Returns the number of phrases loaded.
       pub fn load_phrases(&mut self, content: &str) -> Result<usize, ParseError> {
           let definitions = parse_file(content)?;
           let count = definitions.len();
           for def in definitions {
               // insert handles collision detection
               self.insert(def).map_err(|e| ParseError::Syntax {
                   line: 0,
                   column: 0,
                   message: format!("{}", e),
               })?;
           }
           Ok(count)
       }
   }
   ```

2. Export from mod.rs: `pub use plural::plural_category;`

3. Create `crates/rlf/tests/interpreter_foundation.rs`:
   ```rust
   //! Tests for interpreter foundation: registry, context, plural rules.

   use rlf::interpreter::{EvalContext, EvalError, PhraseRegistry};
   use rlf::interpreter::plural_category;
   use rlf::Value;
   use std::collections::HashMap;

   // === PhraseRegistry Tests ===

   #[test]
   fn registry_load_and_get() {
       let mut registry = PhraseRegistry::new();
       let content = r#"
           hello = "Hello, world!";
           card = { one: "card", other: "cards" };
       "#;
       let count = registry.load_phrases(content).unwrap();
       assert_eq!(count, 2);

       let hello = registry.get("hello").unwrap();
       assert_eq!(hello.name, "hello");

       let card = registry.get("card").unwrap();
       assert_eq!(card.name, "card");

       assert!(registry.get("missing").is_none());
   }

   #[test]
   fn registry_get_by_id() {
       let mut registry = PhraseRegistry::new();
       registry.load_phrases(r#"hello = "Hello!";"#).unwrap();

       let id = rlf::PhraseId::from_name("hello");
       let phrase = registry.get_by_id(id.as_u64()).unwrap();
       assert_eq!(phrase.name, "hello");
   }

   // === EvalContext Tests ===

   #[test]
   fn context_params() {
       let params: HashMap<String, Value> = [
           ("n".to_string(), Value::Number(5)),
       ].into_iter().collect();

       let ctx = EvalContext::new(&params);
       assert_eq!(ctx.get_param("n").unwrap().as_number(), Some(5));
       assert!(ctx.get_param("missing").is_none());
   }

   #[test]
   fn context_cycle_detection() {
       let params = HashMap::new();
       let mut ctx = EvalContext::new(&params);

       ctx.push_call("a").unwrap();
       ctx.push_call("b").unwrap();

       // Trying to push "a" again should fail
       let err = ctx.push_call("a").unwrap_err();
       match err {
           EvalError::CyclicReference { chain } => {
               assert_eq!(chain, vec!["a", "b", "a"]);
           }
           _ => panic!("Expected CyclicReference"),
       }
   }

   #[test]
   fn context_max_depth() {
       let params = HashMap::new();
       let mut ctx = EvalContext::with_max_depth(&params, 3);

       ctx.push_call("a").unwrap();
       ctx.push_call("b").unwrap();
       ctx.push_call("c").unwrap();

       // Fourth push should fail
       let err = ctx.push_call("d").unwrap_err();
       assert!(matches!(err, EvalError::MaxDepthExceeded));
   }

   #[test]
   fn context_pop_call() {
       let params = HashMap::new();
       let mut ctx = EvalContext::new(&params);

       ctx.push_call("a").unwrap();
       ctx.push_call("b").unwrap();
       assert_eq!(ctx.depth(), 2);

       ctx.pop_call();
       assert_eq!(ctx.depth(), 1);

       // Now we can push "b" again (it's no longer in stack)
       ctx.push_call("b").unwrap();
       assert_eq!(ctx.depth(), 2);
   }

   // === Plural Category Tests ===

   #[test]
   fn plural_english() {
       assert_eq!(plural_category("en", 0), "other");
       assert_eq!(plural_category("en", 1), "one");
       assert_eq!(plural_category("en", 2), "other");
       assert_eq!(plural_category("en", 5), "other");
   }

   #[test]
   fn plural_russian() {
       // Russian: 1=one, 2-4=few, 5-20=many, 21=one, 22-24=few, etc.
       assert_eq!(plural_category("ru", 1), "one");
       assert_eq!(plural_category("ru", 2), "few");
       assert_eq!(plural_category("ru", 5), "many");
       assert_eq!(plural_category("ru", 21), "one");
       assert_eq!(plural_category("ru", 22), "few");
       assert_eq!(plural_category("ru", 25), "many");
   }

   #[test]
   fn plural_arabic() {
       // Arabic has all 6 categories
       assert_eq!(plural_category("ar", 0), "zero");
       assert_eq!(plural_category("ar", 1), "one");
       assert_eq!(plural_category("ar", 2), "two");
       assert_eq!(plural_category("ar", 3), "few");
       assert_eq!(plural_category("ar", 11), "many");
       assert_eq!(plural_category("ar", 100), "other");
   }

   #[test]
   fn plural_japanese() {
       // Japanese has only "other" for all numbers
       assert_eq!(plural_category("ja", 0), "other");
       assert_eq!(plural_category("ja", 1), "other");
       assert_eq!(plural_category("ja", 100), "other");
   }
   ```
  </action>
  <verify>
    `cargo test -p rlf` passes all tests including new interpreter_foundation tests.
    `cargo clippy -p rlf` has no warnings.
  </verify>
  <done>
    load_phrases parses .rlf content and stores in registry.
    All foundation tests pass: registry, context, plural categories.
    Ready for Phase 2 Plan 02 (evaluation logic).
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. `cargo build -p rlf` - compiles without errors
2. `cargo test -p rlf` - all tests pass (existing 84 + new foundation tests)
3. `cargo clippy -p rlf` - no warnings
4. Module structure exists: `crates/rlf/src/interpreter/{mod,error,registry,context,plural}.rs`
5. Types exported from `rlf::interpreter`: EvalError, PhraseRegistry, EvalContext, plural_category
</verification>

<success_criteria>
1. EvalError enum has all 7 variants from APPENDIX_RUNTIME_INTERPRETER.md
2. PhraseRegistry stores phrases by name and by PhraseId hash
3. EvalContext tracks parameters, call stack, depth with push_call/pop_call
4. Cycle detection returns CyclicReference error with full chain
5. Max depth returns MaxDepthExceeded error
6. plural_category returns correct CLDR categories for English, Russian, Arabic, Japanese
7. load_phrases loads .rlf content into registry
</success_criteria>

<output>
After completion, create `.planning/phases/02-interpreter-engine/02-01-SUMMARY.md`
</output>
