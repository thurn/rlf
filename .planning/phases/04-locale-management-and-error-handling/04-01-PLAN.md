---
phase: 04-locale-management-and-error-handling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/rlf/Cargo.toml
  - crates/rlf/src/interpreter/error.rs
  - crates/rlf/src/interpreter/mod.rs
autonomous: true

must_haves:
  truths:
    - "LoadError provides file path, line, and column for parse failures"
    - "EvalError::MissingVariant includes 'did you mean' suggestions"
    - "All error types implement std::error::Error"
  artifacts:
    - path: "crates/rlf/src/interpreter/error.rs"
      provides: "LoadError enum and enhanced EvalError"
      contains: "pub enum LoadError"
    - path: "crates/rlf/Cargo.toml"
      provides: "strsim dependency"
      contains: "strsim"
  key_links:
    - from: "crates/rlf/src/interpreter/error.rs"
      to: "strsim"
      via: "levenshtein import"
      pattern: "strsim::levenshtein"
---

<objective>
Create comprehensive error types for translation loading and enhance variant error messages with "did you mean" suggestions.

Purpose: Users get clear, actionable error messages when loading fails or variants are missing. This provides the foundation for the Locale API in Plan 02.

Output: LoadError enum, enhanced EvalError::MissingVariant with suggestions, helper function for computing suggestions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-locale-management-and-error-handling/04-CONTEXT.md
@.planning/phases/04-locale-management-and-error-handling/04-RESEARCH.md
@crates/rlf/src/interpreter/error.rs
@crates/rlf/src/parser/error.rs
@crates/rlf/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add strsim dependency and create LoadError</name>
  <files>
    crates/rlf/Cargo.toml
    crates/rlf/src/interpreter/error.rs
  </files>
  <action>
1. Add `strsim = "0.11"` to Cargo.toml dependencies section.

2. In error.rs, add the new LoadError enum BEFORE EvalError:

```rust
use std::path::PathBuf;

/// Errors that occur during translation loading.
#[derive(Debug, Error)]
pub enum LoadError {
    /// File I/O error when reading translation file.
    #[error("failed to read '{path}': {source}")]
    Io {
        path: PathBuf,
        #[source]
        source: std::io::Error,
    },

    /// Parse error with file location context.
    #[error("{path}:{line}:{column}: {message}")]
    Parse {
        path: PathBuf,
        line: usize,
        column: usize,
        message: String,
    },

    /// Attempted to reload translations that were loaded from a string.
    #[error("cannot reload '{language}': was loaded from string, not file")]
    NoPathForReload { language: String },
}
```

3. Add `use std::path::PathBuf;` at the top of the file.
  </action>
  <verify>Run `just review` - must pass with no errors.</verify>
  <done>LoadError enum exists with Io, Parse, and NoPathForReload variants. strsim is in Cargo.toml.</done>
</task>

<task type="auto">
  <name>Task 2: Enhance MissingVariant with suggestions</name>
  <files>
    crates/rlf/src/interpreter/error.rs
    crates/rlf/src/interpreter/mod.rs
  </files>
  <action>
1. Add `use strsim::levenshtein;` at the top of error.rs.

2. Add a helper function to compute "did you mean" suggestions:

```rust
/// Compute "did you mean" suggestions for a key using Levenshtein distance.
///
/// Returns up to 3 suggestions with edit distance <= 2 (or <= 1 for short keys).
pub fn compute_suggestions(target: &str, available: &[String]) -> Vec<String> {
    let max_distance = if target.len() <= 3 { 1 } else { 2 };

    let mut scored: Vec<_> = available
        .iter()
        .filter_map(|candidate| {
            let dist = levenshtein(target, candidate);
            if dist <= max_distance && dist > 0 {
                Some((candidate.clone(), dist))
            } else {
                None
            }
        })
        .collect();

    scored.sort_by_key(|(_, dist)| *dist);
    scored.truncate(3);
    scored.into_iter().map(|(s, _)| s).collect()
}

fn format_suggestions(suggestions: &[String]) -> String {
    if suggestions.is_empty() {
        String::new()
    } else {
        format!("; did you mean: {}?", suggestions.join(", "))
    }
}
```

3. Update the MissingVariant error to include a suggestions field. Change from:

```rust
#[error("missing variant '{key}' in phrase '{phrase}', available: {}", available.join(", "))]
MissingVariant {
    phrase: String,
    key: String,
    available: Vec<String>,
},
```

To:

```rust
#[error("missing variant '{key}' in phrase '{phrase}', available: {}{}", available.join(", "), format_suggestions(suggestions))]
MissingVariant {
    phrase: String,
    key: String,
    available: Vec<String>,
    suggestions: Vec<String>,
},
```

4. Export `LoadError` and `compute_suggestions` from interpreter/mod.rs by adding to the pub use line:
   `pub use error::{EvalError, LoadError, compute_suggestions};`

5. Update ALL call sites that create MissingVariant errors to include the new `suggestions` field. Search the codebase for `MissingVariant` construction and add:
   `suggestions: compute_suggestions(&key, &available),`

   The call sites are likely in evaluator.rs (variant_lookup or apply_selectors functions).
  </action>
  <verify>Run `just review` - must pass. All existing tests should pass (may need to update test expectations if any test snapshots include MissingVariant errors).</verify>
  <done>MissingVariant includes suggestions field. compute_suggestions function exists and is exported. All call sites updated.</done>
</task>

<task type="auto">
  <name>Task 3: Add error type tests</name>
  <files>
    crates/rlf-tests/tests/interpreter_errors.rs
  </files>
  <action>
Create a new test file for error type verification:

```rust
//! Tests for error types and error message formatting.

use rlf::{compute_suggestions, EvalError, LoadError};
use std::path::PathBuf;

#[test]
fn compute_suggestions_finds_similar_keys() {
    let available = vec![
        "one".to_string(),
        "other".to_string(),
        "few".to_string(),
        "many".to_string(),
    ];

    // "on" is close to "one" (distance 1)
    let suggestions = compute_suggestions("on", &available);
    assert_eq!(suggestions, vec!["one"]);

    // "oter" is close to "other" (distance 1)
    let suggestions = compute_suggestions("oter", &available);
    assert_eq!(suggestions, vec!["other"]);

    // "xyz" has no close matches
    let suggestions = compute_suggestions("xyz", &available);
    assert!(suggestions.is_empty());
}

#[test]
fn compute_suggestions_limits_to_three() {
    let available: Vec<String> = (0..10)
        .map(|i| format!("item{}", i))
        .collect();

    // "item" is close to all of them
    let suggestions = compute_suggestions("item", &available);
    assert!(suggestions.len() <= 3);
}

#[test]
fn load_error_io_displays_path() {
    let err = LoadError::Io {
        path: PathBuf::from("/path/to/file.rlf"),
        source: std::io::Error::new(std::io::ErrorKind::NotFound, "file not found"),
    };
    let msg = err.to_string();
    assert!(msg.contains("/path/to/file.rlf"));
    assert!(msg.contains("file not found"));
}

#[test]
fn load_error_parse_displays_location() {
    let err = LoadError::Parse {
        path: PathBuf::from("translations/ru.rlf"),
        line: 42,
        column: 15,
        message: "unexpected token".to_string(),
    };
    let msg = err.to_string();
    assert!(msg.contains("translations/ru.rlf"));
    assert!(msg.contains("42:15"));
    assert!(msg.contains("unexpected token"));
}

#[test]
fn load_error_no_path_for_reload() {
    let err = LoadError::NoPathForReload {
        language: "ru".to_string(),
    };
    let msg = err.to_string();
    assert!(msg.contains("ru"));
    assert!(msg.contains("string"));
}

#[test]
fn missing_variant_includes_suggestions() {
    let err = EvalError::MissingVariant {
        phrase: "card".to_string(),
        key: "on".to_string(),
        available: vec!["one".to_string(), "other".to_string()],
        suggestions: vec!["one".to_string()],
    };
    let msg = err.to_string();
    assert!(msg.contains("did you mean: one?"));
}

#[test]
fn missing_variant_no_suggestions_when_empty() {
    let err = EvalError::MissingVariant {
        phrase: "card".to_string(),
        key: "xyz".to_string(),
        available: vec!["one".to_string(), "other".to_string()],
        suggestions: vec![],
    };
    let msg = err.to_string();
    assert!(!msg.contains("did you mean"));
}
```
  </action>
  <verify>Run `just review` - all tests must pass including the new error tests.</verify>
  <done>Error type tests exist and pass, verifying LoadError formatting and MissingVariant suggestions.</done>
</task>

</tasks>

<verification>
1. `cargo build` compiles without errors
2. `just review` passes all checks
3. `cargo test -p rlf-tests` runs all tests including new error tests
4. LoadError has Io, Parse, NoPathForReload variants
5. MissingVariant error messages include "did you mean" when applicable
6. compute_suggestions is exported from rlf crate
</verification>

<success_criteria>
- LoadError enum exists with path/line/column context for parse failures
- MissingVariant includes suggestions computed via strsim
- All errors implement std::error::Error (via thiserror derive)
- Error message tests verify formatting
- All 158+ existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-locale-management-and-error-handling/04-01-SUMMARY.md`
</output>
