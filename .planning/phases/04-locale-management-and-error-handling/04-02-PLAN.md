---
phase: 04-locale-management-and-error-handling
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - crates/rlf/src/interpreter/locale.rs
  - crates/rlf/src/interpreter/mod.rs
  - crates/rlf/src/lib.rs
  - crates/rlf-tests/tests/locale.rs
autonomous: true

must_haves:
  truths:
    - "Locale can be created via builder pattern with optional language and fallback"
    - "Language can be changed via set_language"
    - "Translations can be loaded from file or string, stored per-language"
    - "Reloading translations re-reads from original file path"
    - "Reloading string-loaded content returns NoPathForReload error"
    - "Fallback language is used when primary language missing (if configured)"
    - "Loading same language twice replaces previous phrases (not merge)"
  artifacts:
    - path: "crates/rlf/src/interpreter/locale.rs"
      provides: "Locale struct with builder pattern and per-language registries"
      contains: "pub struct Locale"
    - path: "crates/rlf-tests/tests/locale.rs"
      provides: "Integration tests for Locale"
      contains: "fn locale_"
  key_links:
    - from: "crates/rlf/src/interpreter/locale.rs"
      to: "crates/rlf/src/interpreter/registry.rs"
      via: "HashMap of PhraseRegistry per language"
      pattern: "registries: HashMap<String, PhraseRegistry>"
    - from: "crates/rlf/src/interpreter/locale.rs"
      to: "crates/rlf/src/interpreter/transforms.rs"
      via: "TransformRegistry field owned by Locale"
      pattern: "transforms: TransformRegistry"
    - from: "crates/rlf/src/interpreter/locale.rs"
      to: "crates/rlf/src/interpreter/error.rs"
      via: "LoadError return type"
      pattern: "Result<.*LoadError>"
---

<objective>
Implement the Locale struct that users interact with to manage language selection, load translations, and access the interpreter.

Purpose: Provides the user-facing API for localization management. Users create a Locale, load translations per language, switch languages, and access phrases through a clean, ergonomic interface.

Output: Locale struct with builder pattern, per-language phrase storage, translation loading from files and strings, hot-reload support, and optional fallback language.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-locale-management-and-error-handling/04-CONTEXT.md
@.planning/phases/04-locale-management-and-error-handling/04-RESEARCH.md
@.planning/phases/04-locale-management-and-error-handling/04-01-SUMMARY.md
@crates/rlf/src/interpreter/mod.rs
@crates/rlf/src/interpreter/registry.rs
@crates/rlf/src/interpreter/error.rs
@crates/rlf/src/lib.rs
@docs/APPENDIX_RUNTIME_INTERPRETER.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Locale struct with per-language registries</name>
  <files>
    crates/rlf/src/interpreter/locale.rs
    crates/rlf/src/interpreter/mod.rs
  </files>
  <action>
1. Create new file `crates/rlf/src/interpreter/locale.rs`:

```rust
//! Locale management for RLF translations.
//!
//! The Locale struct provides the user-facing API for managing language selection,
//! loading translations, and accessing phrases.

use std::collections::HashMap;
use std::path::{Path, PathBuf};

use bon::Builder;

use crate::interpreter::error::LoadError;
use crate::interpreter::registry::PhraseRegistry;
use crate::interpreter::transforms::TransformRegistry;
use crate::interpreter::{EvalContext, EvalError, eval_phrase_def};
use crate::parser::{ParseError, parse_file};
use crate::types::{Phrase, Value};

/// User-facing locale management for RLF translations.
///
/// Locale owns per-language phrase registries and a shared transform registry.
/// This design provides:
/// - Language-scoped phrase storage (each language has its own registry)
/// - Shared transforms across all languages
/// - Clean replacement semantics (loading same language replaces all phrases)
///
/// # Example
///
/// ```
/// use rlf::Locale;
///
/// let mut locale = Locale::builder()
///     .language("en")
///     .build();
///
/// // Load translations (would normally read from file)
/// locale.load_translations_str("en", r#"hello = "Hello!";"#).unwrap();
///
/// assert_eq!(locale.language(), "en");
/// ```
#[derive(Builder)]
pub struct Locale {
    /// Current language code (e.g., "en", "ru", "de").
    #[builder(default = "en".to_string())]
    language: String,

    /// Optional fallback language for missing phrases.
    /// If set, phrases not found in the primary language will be looked up here.
    /// Default is None (no fallback - missing phrases return error).
    #[builder(default)]
    fallback_language: Option<String>,

    /// Per-language phrase registries.
    /// Each language has its own PhraseRegistry, enabling:
    /// - Clean "replace" semantics when reloading a language
    /// - Language-scoped phrase lookup
    /// - Independent phrase storage per language
    #[builder(skip)]
    registries: HashMap<String, PhraseRegistry>,

    /// Shared transform registry for all languages.
    /// Transforms (like UPPERCASE, lowercase) are language-independent.
    #[builder(skip)]
    transforms: TransformRegistry,

    /// File paths for hot-reload support: language -> PathBuf.
    /// Only populated for file-loaded translations, not string-loaded.
    #[builder(skip)]
    loaded_paths: HashMap<String, PathBuf>,
}

impl Default for Locale {
    fn default() -> Self {
        Self::builder().build()
    }
}

impl Locale {
    /// Create a new Locale with default settings (English, no fallback).
    pub fn new() -> Self {
        Self::default()
    }

    /// Create a new Locale with the specified language.
    pub fn with_language(language: impl Into<String>) -> Self {
        Self::builder().language(language.into()).build()
    }

    // =========================================================================
    // Language Management
    // =========================================================================

    /// Get the current language code.
    pub fn language(&self) -> &str {
        &self.language
    }

    /// Change the current language.
    ///
    /// This does not reload translations - the new language must already have
    /// translations loaded via `load_translations` or `load_translations_str`.
    pub fn set_language(&mut self, language: impl Into<String>) {
        self.language = language.into();
    }

    // =========================================================================
    // Registry Access
    // =========================================================================

    /// Get the phrase registry for a specific language (read-only).
    ///
    /// Returns None if no translations have been loaded for that language.
    pub fn registry_for(&self, language: &str) -> Option<&PhraseRegistry> {
        self.registries.get(language)
    }

    /// Get the phrase registry for the current language (read-only).
    pub fn registry(&self) -> Option<&PhraseRegistry> {
        self.registries.get(&self.language)
    }

    /// Get the shared transform registry (read-only).
    pub fn transforms(&self) -> &TransformRegistry {
        &self.transforms
    }

    /// Get the shared transform registry (mutable) for registering custom transforms.
    pub fn transforms_mut(&mut self) -> &mut TransformRegistry {
        &mut self.transforms
    }

    /// Get or create the phrase registry for a language (mutable).
    fn registry_for_mut(&mut self, language: &str) -> &mut PhraseRegistry {
        self.registries
            .entry(language.to_string())
            .or_insert_with(PhraseRegistry::new)
    }

    /// Clear all phrases for a specific language.
    ///
    /// This is called internally before loading to implement "replace" semantics.
    fn clear_language(&mut self, language: &str) {
        self.registries.remove(language);
    }
}
```

2. Add `mod locale;` to interpreter/mod.rs and export it:
   - Add `mod locale;` after `mod transforms;`
   - Add `pub use locale::Locale;` to the pub use section
  </action>
  <verify>Run `just review` - must compile without errors.</verify>
  <done>Locale struct exists with per-language registries (HashMap&lt;String, PhraseRegistry&gt;), owned TransformRegistry, builder pattern, and language getter/setter.</done>
</task>

<task type="auto">
  <name>Task 2: Implement translation loading methods</name>
  <files>
    crates/rlf/src/interpreter/locale.rs
  </files>
  <action>
Add the translation loading methods to the Locale impl block in locale.rs:

```rust
impl Locale {
    // ... existing methods ...

    // =========================================================================
    // Translation Loading
    // =========================================================================

    /// Load translations from a file for a specific language.
    ///
    /// The file path is stored for later `reload_translations()` support.
    /// Loading the same language twice **replaces** all previous phrases for that language.
    ///
    /// # Example
    ///
    /// ```ignore
    /// locale.load_translations("ru", "assets/localization/ru.rlf")?;
    /// ```
    pub fn load_translations(
        &mut self,
        language: &str,
        path: impl AsRef<Path>,
    ) -> Result<usize, LoadError> {
        let path = path.as_ref();

        // Read file content
        let content = std::fs::read_to_string(path).map_err(|e| LoadError::Io {
            path: path.to_path_buf(),
            source: e,
        })?;

        // Clear existing phrases for this language (replace semantics)
        self.clear_language(language);

        // Load via internal method, which handles parsing
        let count = self.load_translations_str_internal(language, &content, Some(path))?;

        // Store path for reload support
        self.loaded_paths.insert(language.to_string(), path.to_path_buf());

        Ok(count)
    }

    /// Load translations from a string for a specific language.
    ///
    /// Translations loaded this way cannot be reloaded via `reload_translations()`.
    /// Loading the same language twice **replaces** all previous phrases for that language.
    ///
    /// # Example
    ///
    /// ```
    /// use rlf::Locale;
    ///
    /// let mut locale = Locale::new();
    /// let count = locale.load_translations_str("en", r#"
    ///     hello = "Hello!";
    ///     card = { one: "card", other: "cards" };
    /// "#).unwrap();
    /// assert_eq!(count, 2);
    /// ```
    pub fn load_translations_str(
        &mut self,
        language: &str,
        content: &str,
    ) -> Result<usize, LoadError> {
        // Remove from loaded_paths since this is string-loaded
        self.loaded_paths.remove(language);

        // Clear existing phrases for this language (replace semantics)
        self.clear_language(language);

        self.load_translations_str_internal(language, content, None)
    }

    /// Hot-reload translations from the original file path.
    ///
    /// Returns an error if the translations were loaded from a string
    /// (via `load_translations_str`) rather than a file.
    ///
    /// # Example
    ///
    /// ```ignore
    /// // Initial load
    /// locale.load_translations("ru", "assets/localization/ru.rlf")?;
    ///
    /// // Later, after file is modified
    /// locale.reload_translations("ru")?;
    /// ```
    pub fn reload_translations(&mut self, language: &str) -> Result<usize, LoadError> {
        let path = self.loaded_paths.get(language).cloned().ok_or_else(|| {
            LoadError::NoPathForReload {
                language: language.to_string(),
            }
        })?;

        self.load_translations(language, path)
    }

    /// Internal loading implementation.
    fn load_translations_str_internal(
        &mut self,
        language: &str,
        content: &str,
        path: Option<&Path>,
    ) -> Result<usize, LoadError> {
        // Parse the content
        let definitions = parse_file(content).map_err(|e| {
            let default_path = PathBuf::from(format!("<{}>", language));
            let path_buf = path.map(|p| p.to_path_buf()).unwrap_or(default_path);

            match e {
                ParseError::Syntax { line, column, message } => LoadError::Parse {
                    path: path_buf,
                    line,
                    column,
                    message,
                },
                ParseError::UnexpectedEof { line, column } => LoadError::Parse {
                    path: path_buf,
                    line,
                    column,
                    message: "unexpected end of file".to_string(),
                },
                ParseError::InvalidUtf8 => LoadError::Parse {
                    path: path_buf,
                    line: 0,
                    column: 0,
                    message: "invalid UTF-8".to_string(),
                },
            }
        })?;

        // Get or create registry for this language
        let registry = self.registry_for_mut(language);

        // Insert phrases (registry handles collision detection)
        let count = definitions.len();
        for def in definitions {
            registry.insert(def).map_err(|e| {
                let default_path = PathBuf::from(format!("<{}>", language));
                LoadError::Parse {
                    path: path.map(|p| p.to_path_buf()).unwrap_or(default_path),
                    line: 0,
                    column: 0,
                    message: format!("{}", e),
                }
            })?;
        }

        Ok(count)
    }
}
```
  </action>
  <verify>Run `just review` - must compile and all tests pass.</verify>
  <done>load_translations, load_translations_str, and reload_translations methods implemented with per-language storage and replace semantics.</done>
</task>

<task type="auto">
  <name>Task 3: Add phrase evaluation methods with fallback support</name>
  <files>
    crates/rlf/src/interpreter/locale.rs
    crates/rlf/src/lib.rs
  </files>
  <action>
1. Add phrase evaluation methods with fallback support to Locale in locale.rs:

```rust
impl Locale {
    // ... existing methods ...

    // =========================================================================
    // Phrase Evaluation (with fallback support)
    // =========================================================================

    /// Get a parameterless phrase.
    ///
    /// If the phrase is not found in the current language and a fallback
    /// language is configured, the fallback is tried.
    pub fn get_phrase(&self, name: &str) -> Result<Phrase, EvalError> {
        // Try primary language
        match self.get_phrase_for_language(&self.language, name) {
            Ok(phrase) => Ok(phrase),
            Err(e) => {
                // Try fallback if configured
                if let Some(fallback) = &self.fallback_language {
                    if fallback != &self.language {
                        return self.get_phrase_for_language(fallback, name);
                    }
                }
                Err(e)
            }
        }
    }

    /// Get a parameterless phrase for a specific language.
    fn get_phrase_for_language(&self, language: &str, name: &str) -> Result<Phrase, EvalError> {
        let registry = self.registries.get(language).ok_or_else(|| EvalError::PhraseNotFound {
            name: name.to_string(),
        })?;

        let def = registry.get(name).ok_or_else(|| EvalError::PhraseNotFound {
            name: name.to_string(),
        })?;

        if !def.parameters.is_empty() {
            return Err(EvalError::ArgumentCount {
                phrase: name.to_string(),
                expected: def.parameters.len(),
                got: 0,
            });
        }

        let params = HashMap::new();
        let mut ctx = EvalContext::new(&params);
        ctx.push_call(name)?;
        let result = eval_phrase_def(def, &mut ctx, registry, &self.transforms, language)?;
        ctx.pop_call();
        Ok(result)
    }

    /// Call a phrase with arguments.
    ///
    /// If the phrase is not found in the current language and a fallback
    /// language is configured, the fallback is tried.
    pub fn call_phrase(&self, name: &str, args: &[Value]) -> Result<Phrase, EvalError> {
        // Try primary language
        match self.call_phrase_for_language(&self.language, name, args) {
            Ok(phrase) => Ok(phrase),
            Err(e) => {
                // Try fallback if configured
                if let Some(fallback) = &self.fallback_language {
                    if fallback != &self.language {
                        return self.call_phrase_for_language(fallback, name, args);
                    }
                }
                Err(e)
            }
        }
    }

    /// Call a phrase for a specific language.
    fn call_phrase_for_language(&self, language: &str, name: &str, args: &[Value]) -> Result<Phrase, EvalError> {
        let registry = self.registries.get(language).ok_or_else(|| EvalError::PhraseNotFound {
            name: name.to_string(),
        })?;

        let def = registry.get(name).ok_or_else(|| EvalError::PhraseNotFound {
            name: name.to_string(),
        })?;

        // Check argument count
        if def.parameters.len() != args.len() {
            return Err(EvalError::ArgumentCount {
                phrase: name.to_string(),
                expected: def.parameters.len(),
                got: args.len(),
            });
        }

        // Build param map
        let params: HashMap<String, Value> = def
            .parameters
            .iter()
            .zip(args.iter())
            .map(|(name, value)| (name.clone(), value.clone()))
            .collect();

        let mut ctx = EvalContext::new(&params);
        ctx.push_call(name)?;
        let result = eval_phrase_def(def, &mut ctx, registry, &self.transforms, language)?;
        ctx.pop_call();
        Ok(result)
    }

    /// Evaluate a template string with parameters.
    ///
    /// Uses the current language for plural rules.
    pub fn eval_str(
        &self,
        template: &str,
        params: HashMap<String, Value>,
    ) -> Result<Phrase, EvalError> {
        let registry = self.registries.get(&self.language).ok_or_else(|| EvalError::PhraseNotFound {
            name: format!("no translations loaded for language '{}'", self.language),
        })?;

        registry.eval_str_with_transforms(template, &self.language, params, &self.transforms)
    }
}
```

2. Add a helper method to PhraseRegistry in registry.rs for eval_str with external transforms:

```rust
/// Evaluate a template string with external transform registry.
///
/// This is used by Locale to pass its owned TransformRegistry.
pub fn eval_str_with_transforms(
    &self,
    template_str: &str,
    lang: &str,
    params: HashMap<String, Value>,
    transform_registry: &TransformRegistry,
) -> Result<Phrase, EvalError> {
    let template = parse_template(template_str).map_err(|e| EvalError::PhraseNotFound {
        name: format!("parse error: {}", e),
    })?;
    let mut ctx = EvalContext::new(&params);
    let text = crate::interpreter::eval_template(
        &template,
        &mut ctx,
        self,
        transform_registry,
        lang,
    )?;
    Ok(Phrase::builder().text(text).build())
}
```

3. Export Locale and LoadError from the main lib.rs. Update the pub use line in `crates/rlf/src/lib.rs`:

Change from:
```rust
pub use interpreter::{EvalContext, EvalError, PhraseRegistry, TransformRegistry};
```

To:
```rust
pub use interpreter::{EvalContext, EvalError, LoadError, Locale, PhraseRegistry, TransformRegistry, compute_suggestions};
```
  </action>
  <verify>Run `just review` - must compile and pass all tests.</verify>
  <done>Phrase evaluation methods use owned TransformRegistry. Locale exported from main crate.</done>
</task>

<task type="auto">
  <name>Task 4: Add comprehensive Locale tests</name>
  <files>
    crates/rlf-tests/tests/locale.rs
    crates/rlf-tests/Cargo.toml
  </files>
  <action>
1. Add `tempfile = "3"` to the dev-dependencies in `crates/rlf-tests/Cargo.toml` for the file tests.

2. Create comprehensive integration tests for the Locale API:

```rust
//! Integration tests for Locale management.

use rlf::{EvalError, LoadError, Locale, Value};
use std::collections::HashMap;
use std::io::{Seek, Write};
use tempfile::NamedTempFile;

// =========================================================================
// Builder and Basic API
// =========================================================================

#[test]
fn locale_default_is_english() {
    let locale = Locale::new();
    assert_eq!(locale.language(), "en");
}

#[test]
fn locale_builder_sets_language() {
    let locale = Locale::builder().language("ru").build();
    assert_eq!(locale.language(), "ru");
}

#[test]
fn locale_with_language_shorthand() {
    let locale = Locale::with_language("de");
    assert_eq!(locale.language(), "de");
}

#[test]
fn locale_set_language_changes_current() {
    let mut locale = Locale::new();
    assert_eq!(locale.language(), "en");

    locale.set_language("ru");
    assert_eq!(locale.language(), "ru");
}

// =========================================================================
// Translation Loading from String
// =========================================================================

#[test]
fn load_translations_str_parses_phrases() {
    let mut locale = Locale::new();
    let count = locale.load_translations_str("en", r#"
        hello = "Hello!";
        card = { one: "card", other: "cards" };
    "#).unwrap();

    assert_eq!(count, 2);
}

#[test]
fn load_translations_str_replaces_on_reload() {
    let mut locale = Locale::new();

    // First load
    locale.load_translations_str("en", r#"hello = "Hello!";"#).unwrap();
    let phrase = locale.get_phrase("hello").unwrap();
    assert_eq!(phrase.to_string(), "Hello!");

    // Second load should replace all phrases for that language
    locale.load_translations_str("en", r#"goodbye = "Goodbye!";"#).unwrap();

    // Old phrase should be gone
    let result = locale.get_phrase("hello");
    assert!(result.is_err());

    // New phrase should exist
    let phrase = locale.get_phrase("goodbye").unwrap();
    assert_eq!(phrase.to_string(), "Goodbye!");
}

#[test]
fn load_translations_str_returns_parse_error() {
    let mut locale = Locale::new();
    let result = locale.load_translations_str("en", r#"invalid syntax here"#);

    assert!(result.is_err());
    let err = result.unwrap_err();
    assert!(matches!(err, LoadError::Parse { .. }));
}

// =========================================================================
// Per-Language Storage
// =========================================================================

#[test]
fn translations_stored_per_language() {
    let mut locale = Locale::new();

    // Load English
    locale.load_translations_str("en", r#"hello = "Hello!";"#).unwrap();

    // Load Russian
    locale.load_translations_str("ru", r#"hello = "Привет!";"#).unwrap();

    // English lookup
    locale.set_language("en");
    let phrase = locale.get_phrase("hello").unwrap();
    assert_eq!(phrase.to_string(), "Hello!");

    // Russian lookup
    locale.set_language("ru");
    let phrase = locale.get_phrase("hello").unwrap();
    assert_eq!(phrase.to_string(), "Привет!");
}

#[test]
fn reloading_language_only_affects_that_language() {
    let mut locale = Locale::new();

    // Load both languages
    locale.load_translations_str("en", r#"hello = "Hello!";"#).unwrap();
    locale.load_translations_str("ru", r#"privet = "Привет!";"#).unwrap();

    // Reload English with different content
    locale.load_translations_str("en", r#"goodbye = "Goodbye!";"#).unwrap();

    // Russian should be unaffected
    locale.set_language("ru");
    let phrase = locale.get_phrase("privet").unwrap();
    assert_eq!(phrase.to_string(), "Привет!");
}

// =========================================================================
// Translation Loading from File
// =========================================================================

#[test]
fn load_translations_from_file() {
    let mut locale = Locale::new();

    // Create temp file with translation content
    let mut file = NamedTempFile::new().unwrap();
    writeln!(file, r#"hello = "Hello from file!";"#).unwrap();

    let count = locale.load_translations("en", file.path()).unwrap();
    assert_eq!(count, 1);
}

#[test]
fn load_translations_file_not_found() {
    let mut locale = Locale::new();
    let result = locale.load_translations("en", "/nonexistent/path/file.rlf");

    assert!(result.is_err());
    let err = result.unwrap_err();
    assert!(matches!(err, LoadError::Io { .. }));
}

// =========================================================================
// Hot Reload
// =========================================================================

#[test]
fn reload_translations_rereads_file() {
    let mut locale = Locale::new();

    // Create temp file
    let mut file = NamedTempFile::new().unwrap();
    writeln!(file, r#"hello = "Original";"#).unwrap();
    file.flush().unwrap();

    // Initial load
    locale.load_translations("en", file.path()).unwrap();
    let phrase = locale.get_phrase("hello").unwrap();
    assert_eq!(phrase.to_string(), "Original");

    // Modify file
    file.rewind().unwrap();
    file.set_len(0).unwrap();
    writeln!(file, r#"hello = "Modified";"#).unwrap();
    file.flush().unwrap();

    // Reload
    let count = locale.reload_translations("en").unwrap();
    assert_eq!(count, 1);

    let phrase = locale.get_phrase("hello").unwrap();
    assert_eq!(phrase.to_string(), "Modified");
}

#[test]
fn reload_string_loaded_returns_error() {
    let mut locale = Locale::new();

    // Load from string
    locale.load_translations_str("en", r#"hello = "Hello!";"#).unwrap();

    // Attempt reload should fail
    let result = locale.reload_translations("en");
    assert!(result.is_err());
    let err = result.unwrap_err();
    assert!(matches!(err, LoadError::NoPathForReload { .. }));
}

#[test]
fn reload_unloaded_language_returns_error() {
    let locale = Locale::new();
    let result = locale.reload_translations("ru");

    assert!(result.is_err());
    assert!(matches!(result.unwrap_err(), LoadError::NoPathForReload { .. }));
}

// =========================================================================
// Phrase Evaluation
// =========================================================================

#[test]
fn get_phrase_returns_phrase() {
    let mut locale = Locale::new();
    locale.load_translations_str("en", r#"hello = "Hello, world!";"#).unwrap();

    let phrase = locale.get_phrase("hello").unwrap();
    assert_eq!(phrase.to_string(), "Hello, world!");
}

#[test]
fn get_phrase_not_found_returns_error() {
    let mut locale = Locale::new();
    locale.load_translations_str("en", r#"hello = "Hello!";"#).unwrap();

    let result = locale.get_phrase("nonexistent");
    assert!(result.is_err());
    assert!(matches!(result.unwrap_err(), EvalError::PhraseNotFound { .. }));
}

#[test]
fn call_phrase_with_args() {
    let mut locale = Locale::new();
    locale.load_translations_str("en", r#"
        greet(name) = "Hello, {name}!";
    "#).unwrap();

    let phrase = locale.call_phrase("greet", &[Value::from("World")]).unwrap();
    assert_eq!(phrase.to_string(), "Hello, World!");
}

#[test]
fn eval_str_evaluates_template() {
    let mut locale = Locale::new();
    locale.load_translations_str("en", r#"
        card = { one: "card", other: "cards" };
    "#).unwrap();

    let params: HashMap<String, Value> = [("n".to_string(), Value::from(3))].into_iter().collect();
    let phrase = locale.eval_str("Draw {n} {card:n}.", params).unwrap();
    assert_eq!(phrase.to_string(), "Draw 3 cards.");
}

// =========================================================================
// Fallback Language
// =========================================================================

#[test]
fn fallback_language_used_when_primary_missing() {
    let mut locale = Locale::builder()
        .language("ru")
        .fallback_language("en".to_string())
        .build();

    // Load English only
    locale.load_translations_str("en", r#"hello = "Hello!";"#).unwrap();

    // Russian phrase lookup should fall back to English
    let phrase = locale.get_phrase("hello").unwrap();
    assert_eq!(phrase.to_string(), "Hello!");
}

#[test]
fn fallback_not_used_when_primary_has_phrase() {
    let mut locale = Locale::builder()
        .language("ru")
        .fallback_language("en".to_string())
        .build();

    locale.load_translations_str("en", r#"hello = "Hello!";"#).unwrap();
    locale.load_translations_str("ru", r#"hello = "Привет!";"#).unwrap();

    // Should use Russian, not fallback to English
    let phrase = locale.get_phrase("hello").unwrap();
    assert_eq!(phrase.to_string(), "Привет!");
}

#[test]
fn no_fallback_by_default() {
    let mut locale = Locale::builder()
        .language("ru")
        .build();

    // Load English only (no fallback configured)
    locale.load_translations_str("en", r#"hello = "Hello!";"#).unwrap();

    // Russian phrase lookup should fail (no fallback)
    let result = locale.get_phrase("hello");
    assert!(result.is_err());
}

#[test]
fn fallback_works_for_call_phrase() {
    let mut locale = Locale::builder()
        .language("ru")
        .fallback_language("en".to_string())
        .build();

    locale.load_translations_str("en", r#"greet(name) = "Hello, {name}!";"#).unwrap();

    // Should fall back to English
    let phrase = locale.call_phrase("greet", &[Value::from("World")]).unwrap();
    assert_eq!(phrase.to_string(), "Hello, World!");
}

// =========================================================================
// Transform Registry Access
// =========================================================================

#[test]
fn transforms_accessible_from_locale() {
    let locale = Locale::new();

    // Should have default transforms available
    let transforms = locale.transforms();
    // TransformRegistry exists and is accessible
    assert!(std::ptr::eq(transforms, locale.transforms()));
}

// =========================================================================
// Registry Access
// =========================================================================

#[test]
fn registry_for_returns_language_registry() {
    let mut locale = Locale::new();
    locale.load_translations_str("en", r#"hello = "Hello!";"#).unwrap();
    locale.load_translations_str("ru", r#"privet = "Привет!";"#).unwrap();

    let en_registry = locale.registry_for("en").unwrap();
    assert!(en_registry.get("hello").is_some());
    assert!(en_registry.get("privet").is_none());

    let ru_registry = locale.registry_for("ru").unwrap();
    assert!(ru_registry.get("privet").is_some());
    assert!(ru_registry.get("hello").is_none());
}

#[test]
fn registry_returns_current_language_registry() {
    let mut locale = Locale::new();
    locale.load_translations_str("en", r#"hello = "Hello!";"#).unwrap();

    let registry = locale.registry().unwrap();
    assert!(registry.get("hello").is_some());
}
```
  </action>
  <verify>Run `just review` - all tests must pass including the new Locale tests.</verify>
  <done>Comprehensive Locale tests exist covering builder, per-language storage, loading, reload, fallback, and evaluation.</done>
</task>

</tasks>

<verification>
1. `cargo build` compiles without errors
2. `just review` passes all checks
3. `cargo test -p rlf-tests` runs all tests including new Locale tests
4. Locale owns HashMap&lt;String, PhraseRegistry&gt; (per-language storage)
5. Locale owns TransformRegistry (not creating new instances)
6. load_translations stores phrases in language-specific registry
7. Loading same language twice replaces previous phrases
8. Fallback language is used when configured and primary missing
9. All 158+ existing tests still pass
</verification>

<success_criteria>
- Locale struct exists with per-language registries (LOC-01, LOC-02)
- Locale owns TransformRegistry (context_compliance fix)
- Language-scoped phrase storage works (LOC-07, LOC-08, LOC-09)
- Locale::with_language() constructor works (LOC-03)
- set_language() and language() work (LOC-04, LOC-05)
- registry() and registry_for() accessors work (LOC-06)
- load_translations() reads from file with replace semantics (LOC-07)
- load_translations_str() loads from string with replace semantics (LOC-08)
- reload_translations() hot-reloads from file (LOC-09)
- All requirements ERR-01 through ERR-09 addressed by Plan 01 error types
- Comprehensive test coverage for all Locale methods
</success_criteria>

<output>
After completion, create `.planning/phases/04-locale-management-and-error-handling/04-02-SUMMARY.md`
</output>
