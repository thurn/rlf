---
phase: 01-core-types-and-parser
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - crates/rlf/src/parser/mod.rs
  - crates/rlf/src/parser/ast.rs
  - crates/rlf/src/parser/file.rs
  - crates/rlf/tests/file_parser.rs
autonomous: true

must_haves:
  truths:
    - "Parser can parse phrase definitions from .rlf file content"
    - "Parser can parse simple phrases (name = \"text\";)"
    - "Parser can parse phrases with parameters (name(p) = \"text\";)"
    - "Parser can parse variant blocks ({ one: \"x\", other: \"y\" })"
    - "Parser can parse metadata tags (:fem, :masc, :a, :an)"
    - "Parser can parse :from(param) inheritance"
    - "Parser can parse multi-key variants (nom, acc: \"x\")"
    - "Parser can parse line comments (// comment)"
    - "Parser can parse multiple phrase definitions in a file"
  artifacts:
    - path: "crates/rlf/src/parser/ast.rs"
      provides: "AST types for file parsing"
      exports: ["PhraseDefinition", "PhraseBody"]
      contains: "pub struct PhraseDefinition"
    - path: "crates/rlf/src/parser/file.rs"
      provides: "File format parser"
      contains: "pub fn parse_file"
  key_links:
    - from: "crates/rlf/src/parser/file.rs"
      to: "crates/rlf/src/parser/ast.rs"
      via: "returns Vec<PhraseDefinition>"
      pattern: "Vec<PhraseDefinition>"
    - from: "crates/rlf/src/parser/file.rs"
      to: "crates/rlf/src/parser/template.rs"
      via: "uses parse_template internally"
      pattern: "parse_template\\|template"
---

<objective>
Implement the .rlf file format parser. This parses entire translation files containing multiple phrase definitions.

Purpose: Complete the parser implementation to handle the full .rlf file format, enabling loading of source and translation files.

Output: A working file parser that can parse any valid .rlf file into a list of phrase definitions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-types-and-parser/01-CONTEXT.md
@.planning/phases/01-core-types-and-parser/01-RESEARCH.md
@docs/DESIGN.md
@docs/APPENDIX_RUST_INTEGRATION.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add file-level AST types</name>
  <files>
    crates/rlf/src/parser/ast.rs
    crates/rlf/src/parser/mod.rs
  </files>
  <action>
    Extend ast.rs with types for phrase definitions (file-level constructs):

    ```rust
    use crate::types::Tag;

    // ... existing Template, Segment, Transform, Reference, Selector types ...

    /// A parsed phrase definition from a .rlf file.
    #[derive(Debug, Clone, PartialEq)]
    pub struct PhraseDefinition {
        /// Phrase name (snake_case identifier)
        pub name: String,
        /// Parameter names (empty if no parameters)
        pub parameters: Vec<String>,
        /// Metadata tags (e.g., :fem, :masc, :a)
        pub tags: Vec<Tag>,
        /// :from(param) inheritance (None if not present)
        pub from_param: Option<String>,
        /// Phrase body (simple template or variants)
        pub body: PhraseBody,
    }

    /// The body of a phrase definition.
    #[derive(Debug, Clone, PartialEq)]
    pub enum PhraseBody {
        /// Simple phrase: name = "text";
        Simple(Template),
        /// Variant phrase: name = { one: "x", other: "y" };
        Variants(Vec<VariantEntry>),
    }

    /// A single variant entry in a variant block.
    #[derive(Debug, Clone, PartialEq)]
    pub struct VariantEntry {
        /// Variant keys (multiple keys share the same template)
        pub keys: Vec<String>,
        /// Template for this variant
        pub template: Template,
    }
    ```

    Update mod.rs to export new types:
    ```rust
    pub use ast::{
        Template, Segment, Transform, Reference, Selector,
        PhraseDefinition, PhraseBody, VariantEntry,
    };
    ```
  </action>
  <verify>
    `cargo check --workspace` - new types compile
  </verify>
  <done>
    PhraseDefinition, PhraseBody, VariantEntry types exist and are exported
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement file format parser</name>
  <files>
    crates/rlf/src/parser/file.rs
    crates/rlf/src/parser/mod.rs
  </files>
  <action>
    Implement the .rlf file format parser using winnow.

    **File format syntax from DESIGN.md:**
    ```
    // Line comment
    name = "template";
    name(param1, param2) = "template with {param1}";
    name = :tag "template";
    name = :tag1 :tag2 "template";
    name(s) = :from(s) "template";
    name = { one: "singular", other: "plural" };
    name = { nom.one: "x", nom.other: "y", acc: "z" };
    name = { key1, key2: "shared value" };  // multi-key
    ```

    **CONTEXT.md decisions:**
    - Line comments only: `// comment`
    - UTF-8 encoding only
    - Allow trailing commas in variant lists
    - Phrase names use snake_case only

    **Parser structure:**
    ```rust
    use winnow::prelude::*;
    use winnow::combinator::{alt, repeat, opt, preceded, delimited, separated, terminated};
    use winnow::token::{take_while, take_until, any, one_of, none_of};
    use winnow::ascii::{space0, space1, line_ending, multispace0};

    use super::ast::*;
    use super::error::ParseError;
    use super::template::parse_template_inner; // Internal parser function

    /// Parse an entire .rlf file into phrase definitions.
    pub fn parse_file(input: &str) -> Result<Vec<PhraseDefinition>, ParseError> {
        // Reject non-UTF-8 (Rust strings are always UTF-8, so this is a no-op)
        // But we could add BOM detection here if needed

        let mut input = input;
        match file.parse_next(&mut input) {
            Ok(phrases) => Ok(phrases),
            Err(e) => {
                let (line, column) = calculate_position_from_remaining(input);
                Err(ParseError::Syntax {
                    line,
                    column,
                    message: format!("{}", e),
                })
            }
        }
    }

    fn file(input: &mut &str) -> ModalResult<Vec<PhraseDefinition>> {
        // Skip leading whitespace/comments
        repeat(0.., preceded(multispace_and_comments, phrase_definition))
            .parse_next(input)
    }

    fn multispace_and_comments(input: &mut &str) -> ModalResult<()> {
        // Handle whitespace and // line comments
    }

    fn phrase_definition(input: &mut &str) -> ModalResult<PhraseDefinition> {
        // name(params)? = tags? (:from(p))? body ;
    }

    fn identifier(input: &mut &str) -> ModalResult<String> {
        // snake_case: [a-z][a-z0-9_]*
    }

    fn parameter_list(input: &mut &str) -> ModalResult<Vec<String>> {
        // (param1, param2, ...)
    }

    fn tags(input: &mut &str) -> ModalResult<Vec<Tag>> {
        // :tag1 :tag2 ...
    }

    fn from_modifier(input: &mut &str) -> ModalResult<String> {
        // :from(param)
    }

    fn phrase_body(input: &mut &str) -> ModalResult<PhraseBody> {
        alt((
            variant_block.map(PhraseBody::Variants),
            template_string.map(PhraseBody::Simple),
        )).parse_next(input)
    }

    fn variant_block(input: &mut &str) -> ModalResult<Vec<VariantEntry>> {
        // { key1, key2: "template", key3: "template", }
        // Trailing comma allowed
    }

    fn variant_entry(input: &mut &str) -> ModalResult<VariantEntry> {
        // key1, key2: "template"
    }

    fn variant_keys(input: &mut &str) -> ModalResult<Vec<String>> {
        // key1, key2, key3 (before the colon)
    }

    fn template_string(input: &mut &str) -> ModalResult<Template> {
        // "content" - parse the content using template parser
        delimited('"', template_content, '"')
            .parse_next(input)
    }
    ```

    **Important details:**
    1. Comments: `//` to end of line
    2. Whitespace: flexible between tokens
    3. Trailing commas: allowed in variant blocks
    4. Snake_case: enforce `[a-z][a-z0-9_]*` for phrase names
    5. Template strings: parse content between quotes using template parser
    6. Multi-key variants: `nom, acc: "text"` -> keys: ["nom", "acc"]
    7. Wildcard keys: `nom:` is valid (partial key for fallback)

    **Error positions:**
    Track line and column for error messages. Use winnow's position tracking or manually count newlines.
  </action>
  <verify>
    `cargo check --workspace` - compiles
    Basic test:
    ```rust
    let phrases = parse_file(r#"
        hello = "Hello!";
        greet(name) = "Hello, {name}!";
    "#).unwrap();
    assert_eq!(phrases.len(), 2);
    ```
  </verify>
  <done>
    File parser handles all file-level syntax: definitions, parameters, tags, from, variants
  </done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive file parser tests</name>
  <files>
    crates/rlf/tests/file_parser.rs
  </files>
  <action>
    Create integration tests for the file format parser covering all syntax forms.

    ```rust
    //! Integration tests for .rlf file parsing

    use rlf::parser::{parse_file, PhraseDefinition, PhraseBody, VariantEntry};
    use rlf::types::Tag;

    #[test]
    fn test_simple_phrase() {
        let phrases = parse_file(r#"hello = "Hello, world!";"#).unwrap();
        assert_eq!(phrases.len(), 1);
        assert_eq!(phrases[0].name, "hello");
        assert!(phrases[0].parameters.is_empty());
        assert!(phrases[0].tags.is_empty());
        assert!(phrases[0].from_param.is_none());
        match &phrases[0].body {
            PhraseBody::Simple(t) => {
                assert_eq!(t.segments.len(), 1);
            }
            _ => panic!("expected simple body"),
        }
    }

    #[test]
    fn test_phrase_with_parameters() {
        let phrases = parse_file(r#"greet(name) = "Hello, {name}!";"#).unwrap();
        assert_eq!(phrases[0].parameters, vec!["name"]);
    }

    #[test]
    fn test_phrase_with_multiple_parameters() {
        let phrases = parse_file(r#"damage(amount, target) = "Deal {amount} to {target}.";"#).unwrap();
        assert_eq!(phrases[0].parameters, vec!["amount", "target"]);
    }

    #[test]
    fn test_phrase_with_tag() {
        let phrases = parse_file(r#"card = :fem "carta";"#).unwrap();
        assert_eq!(phrases[0].tags, vec![Tag::new("fem")]);
    }

    #[test]
    fn test_phrase_with_multiple_tags() {
        let phrases = parse_file(r#"card = :a :noun "card";"#).unwrap();
        assert_eq!(phrases[0].tags.len(), 2);
    }

    #[test]
    fn test_phrase_with_from() {
        let phrases = parse_file(r#"subtype(s) = :from(s) "{s}";"#).unwrap();
        assert_eq!(phrases[0].from_param, Some("s".to_string()));
    }

    #[test]
    fn test_phrase_with_tags_and_from() {
        let phrases = parse_file(r#"subtype(s) = :an :from(s) "<b>{s}</b>";"#).unwrap();
        assert_eq!(phrases[0].tags, vec![Tag::new("an")]);
        assert_eq!(phrases[0].from_param, Some("s".to_string()));
    }

    #[test]
    fn test_simple_variants() {
        let phrases = parse_file(r#"
            card = {
                one: "card",
                other: "cards",
            };
        "#).unwrap();
        match &phrases[0].body {
            PhraseBody::Variants(entries) => {
                assert_eq!(entries.len(), 2);
            }
            _ => panic!("expected variants"),
        }
    }

    #[test]
    fn test_multidimensional_variants() {
        let phrases = parse_file(r#"
            card = {
                nom.one: "carta",
                nom.other: "cartas",
                acc.one: "carta",
                acc.other: "cartas",
            };
        "#).unwrap();
        match &phrases[0].body {
            PhraseBody::Variants(entries) => {
                assert_eq!(entries.len(), 4);
                assert_eq!(entries[0].keys, vec!["nom.one"]);
            }
            _ => panic!("expected variants"),
        }
    }

    #[test]
    fn test_multikey_variants() {
        let phrases = parse_file(r#"
            card = {
                nom, acc: "card",
                nom.other, acc.other: "cards",
            };
        "#).unwrap();
        match &phrases[0].body {
            PhraseBody::Variants(entries) => {
                assert_eq!(entries.len(), 2);
                assert_eq!(entries[0].keys, vec!["nom", "acc"]);
            }
            _ => panic!("expected variants"),
        }
    }

    #[test]
    fn test_trailing_comma() {
        let phrases = parse_file(r#"
            card = {
                one: "card",
                other: "cards",
            };
        "#).unwrap();
        assert_eq!(phrases.len(), 1);
    }

    #[test]
    fn test_line_comments() {
        let phrases = parse_file(r#"
            // This is a comment
            hello = "Hello!";
            // Another comment
            bye = "Goodbye!"; // inline comment
        "#).unwrap();
        assert_eq!(phrases.len(), 2);
    }

    #[test]
    fn test_multiple_phrases() {
        let phrases = parse_file(r#"
            hello = "Hello!";
            goodbye = "Goodbye!";
            greet(name) = "Hello, {name}!";
        "#).unwrap();
        assert_eq!(phrases.len(), 3);
    }

    #[test]
    fn test_empty_file() {
        let phrases = parse_file("").unwrap();
        assert!(phrases.is_empty());
    }

    #[test]
    fn test_only_comments() {
        let phrases = parse_file(r#"
            // Just comments
            // Nothing else
        "#).unwrap();
        assert!(phrases.is_empty());
    }

    #[test]
    fn test_variants_with_tags() {
        let phrases = parse_file(r#"
            card = :fem {
                one: "carta",
                other: "cartas",
            };
        "#).unwrap();
        assert_eq!(phrases[0].tags, vec![Tag::new("fem")]);
        match &phrases[0].body {
            PhraseBody::Variants(_) => {}
            _ => panic!("expected variants"),
        }
    }

    #[test]
    fn test_complex_file() {
        // A realistic .rlf file
        let phrases = parse_file(r#"
            // English source file
            card = :a { one: "card", other: "cards" };
            event = :an "event";
            draw(n) = "Draw {n} {card:n}.";
            subtype(s) = :from(s) "<b>{s}</b>";
        "#).unwrap();
        assert_eq!(phrases.len(), 4);
    }

    #[test]
    fn test_snake_case_names() {
        let phrases = parse_file(r#"my_phrase = "text";"#).unwrap();
        assert_eq!(phrases[0].name, "my_phrase");
    }

    #[test]
    fn test_error_invalid_name() {
        // Names must be snake_case (start with lowercase)
        let result = parse_file(r#"MyPhrase = "text";"#);
        assert!(result.is_err());
    }

    #[test]
    fn test_error_missing_semicolon() {
        let result = parse_file(r#"hello = "Hello!""#);
        assert!(result.is_err());
    }

    #[test]
    fn test_wildcard_fallback_key() {
        // "nom" without a dimension is a fallback
        let phrases = parse_file(r#"
            card = {
                nom: "carta",
                nom.other: "cartas",
            };
        "#).unwrap();
        match &phrases[0].body {
            PhraseBody::Variants(entries) => {
                // "nom" should be parsed as a single-segment key
                assert!(entries.iter().any(|e| e.keys == vec!["nom"]));
            }
            _ => panic!("expected variants"),
        }
    }
    ```
  </action>
  <verify>
    `cargo test --workspace` - all tests pass
  </verify>
  <done>
    Comprehensive tests exist for all file format syntax.
    All tests pass.
    Error cases are tested.
  </done>
</task>

</tasks>

<verification>
Run the following checks:

1. `cargo check --workspace` - compiles without errors
2. `cargo test --workspace` - all tests pass
3. Verify parser handles a complete example file:
   ```rlf
   // Test file
   hello = "Hello!";
   card = :a { one: "card", other: "cards" };
   draw(n) = "Draw {n} {card:n}.";
   ```
</verification>

<success_criteria>
- [ ] PhraseDefinition, PhraseBody, VariantEntry AST types exist
- [ ] parse_file() function works
- [ ] Simple phrases parse correctly
- [ ] Phrases with parameters parse correctly
- [ ] Metadata tags (:fem, :a, etc.) parse correctly
- [ ] :from(param) inheritance parses correctly
- [ ] Variant blocks parse correctly
- [ ] Multi-key variants parse correctly
- [ ] Trailing commas allowed
- [ ] Line comments handled
- [ ] Snake_case names enforced
- [ ] Error positions include line and column
- [ ] Comprehensive tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-types-and-parser/01-03-SUMMARY.md`
</output>
