---
phase: 01-core-types-and-parser
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - crates/rlf/Cargo.toml
  - crates/rlf/src/lib.rs
  - crates/rlf/src/parser/mod.rs
  - crates/rlf/src/parser/ast.rs
  - crates/rlf/src/parser/template.rs
  - crates/rlf/src/parser/error.rs
autonomous: true

must_haves:
  truths:
    - "Parser can parse template strings with literal text"
    - "Parser can parse interpolations with parameter references"
    - "Parser can parse interpolations with phrase references"
    - "Parser can parse transforms with optional context"
    - "Parser can parse selections (single and chained)"
    - "Parser can parse escape sequences ({{ }} @@ ::)"
    - "Parser produces structured AST with Segment variants"
  artifacts:
    - path: "crates/rlf/src/parser/ast.rs"
      provides: "Public AST types for templates"
      exports: ["Template", "Segment", "Transform", "Reference", "Selector"]
    - path: "crates/rlf/src/parser/template.rs"
      provides: "Template string parser"
      contains: "pub fn parse_template"
    - path: "crates/rlf/src/parser/error.rs"
      provides: "Parse error types"
      exports: ["ParseError"]
      contains: "pub enum ParseError"
  key_links:
    - from: "crates/rlf/src/parser/template.rs"
      to: "crates/rlf/src/parser/ast.rs"
      via: "returns Template"
      pattern: "-> .*Template"
    - from: "crates/rlf/src/lib.rs"
      to: "crates/rlf/src/parser/mod.rs"
      via: "pub mod parser"
      pattern: "pub mod parser"
---

<objective>
Implement the template string parser using winnow. This parses the content inside phrase definitions (the template part between quotes).

Purpose: Template parsing is the core of RLF - it handles interpolations, transforms, selections, and escape sequences. This must correctly handle all LANG-* requirements from the roadmap.

Output: A working template parser that can parse any valid RLF template string into an AST.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-types-and-parser/01-CONTEXT.md
@.planning/phases/01-core-types-and-parser/01-RESEARCH.md
@docs/DESIGN.md
@docs/APPENDIX_RUST_INTEGRATION.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add winnow dependency and create parser module structure</name>
  <files>
    crates/rlf/Cargo.toml
    crates/rlf/src/lib.rs
    crates/rlf/src/parser/mod.rs
    crates/rlf/src/parser/ast.rs
    crates/rlf/src/parser/error.rs
  </files>
  <action>
    1. Add winnow to crates/rlf/Cargo.toml:
       ```toml
       winnow = "0.7"
       ```

    2. Add parser module to lib.rs:
       ```rust
       pub mod parser;
       ```

    3. Create parser/mod.rs:
       ```rust
       pub mod ast;
       pub mod error;
       mod template;

       pub use ast::*;
       pub use error::ParseError;
       pub use template::parse_template;
       ```

    4. Create parser/ast.rs with public AST types:
       ```rust
       //! Public AST types for RLF templates and phrase definitions.
       //!
       //! These types are public to enable external tooling (linters, formatters, etc.).

       use crate::types::Tag;

       /// A parsed template string containing segments.
       #[derive(Debug, Clone, PartialEq)]
       pub struct Template {
           pub segments: Vec<Segment>,
       }

       /// A segment within a template.
       #[derive(Debug, Clone, PartialEq)]
       pub enum Segment {
           /// Literal text (no interpolation).
           Literal(String),
           /// An interpolation: {transforms reference selectors}
           Interpolation {
               transforms: Vec<Transform>,
               reference: Reference,
               selectors: Vec<Selector>,
           },
       }

       /// A transform applied to a reference (e.g., @cap, @a, @der:acc).
       #[derive(Debug, Clone, PartialEq)]
       pub struct Transform {
           /// Transform name without @ (e.g., "cap", "a", "der")
           pub name: String,
           /// Optional context for the transform (e.g., "acc" in @der:acc)
           pub context: Option<Selector>,
       }

       /// A reference to a parameter or phrase.
       #[derive(Debug, Clone, PartialEq)]
       pub enum Reference {
           /// Reference to a parameter: {name}
           Parameter(String),
           /// Reference to a phrase: {phrase_name}
           Phrase(String),
           /// Reference to a phrase call with arguments: {phrase(arg1, arg2)}
           PhraseCall {
               name: String,
               args: Vec<Reference>,
           },
       }

       /// A selector for variant selection.
       #[derive(Debug, Clone, PartialEq)]
       pub enum Selector {
           /// Literal selector: :one, :other, :nom.many
           Literal(String),
           /// Parameter-based selector: :n (where n is a parameter)
           Parameter(String),
       }
       ```

    5. Create parser/error.rs:
       ```rust
       use thiserror::Error;

       #[derive(Debug, Error)]
       pub enum ParseError {
           #[error("syntax error at {line}:{column}: {message}")]
           Syntax {
               line: usize,
               column: usize,
               message: String,
           },

           #[error("unexpected end of input at {line}:{column}")]
           UnexpectedEof {
               line: usize,
               column: usize,
           },

           #[error("invalid UTF-8 in input")]
           InvalidUtf8,
       }
       ```
  </action>
  <verify>
    `cargo check --workspace` - compiles with new module structure
  </verify>
  <done>
    Parser module exists with AST types and error types defined
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement template parser with winnow</name>
  <files>
    crates/rlf/src/parser/template.rs
  </files>
  <action>
    Implement the template string parser using winnow. Follow DESIGN.md syntax exactly.

    **Key parsing requirements from LANG-* requirements:**
    - LANG-01: Literal text segments
    - LANG-02: Parameter interpolation {name}
    - LANG-03: Phrase interpolation {phrase}
    - LANG-04: Selection with literal :one, :other
    - LANG-05: Selection with parameter :n
    - LANG-06: Multi-dimensional selection :acc:n
    - LANG-07: Transforms @cap, @upper, @lower
    - LANG-08: Transform with context @der:acc
    - LANG-09: Chained transforms @cap @a
    - LANG-10: Phrase call with arguments {foo(x, y)}
    - LANG-11: Escape sequences {{ }} @@ ::
    - LANG-12: Automatic capitalization {Card} -> @cap card
    - LANG-13: Variant definitions (Phase 03 - file parser)
    - LANG-14: Metadata tags (Phase 03 - file parser)
    - LANG-15: :from(param) inheritance (Phase 03 - file parser)
    - LANG-16: Multi-key variants (Phase 03 - file parser)
    - LANG-17: Comments (Phase 03 - file parser)

    **Parser structure:**
    ```rust
    use winnow::prelude::*;
    use winnow::combinator::{alt, repeat, opt, preceded, delimited, separated};
    use winnow::token::{take_while, take_until, any, one_of, none_of};
    use winnow::ascii::{alpha1, alphanumeric1};

    use super::ast::*;
    use super::error::ParseError;

    /// Parse a template string into an AST.
    pub fn parse_template(input: &str) -> Result<Template, ParseError> {
        let mut input = input;
        match template.parse_next(&mut input) {
            Ok(t) => Ok(t),
            Err(e) => {
                // Convert winnow error to ParseError with line:column
                let (line, column) = calculate_position(input, e);
                Err(ParseError::Syntax {
                    line,
                    column,
                    message: format!("{}", e),
                })
            }
        }
    }

    fn template(input: &mut &str) -> ModalResult<Template> {
        repeat(0.., segment)
            .map(|segments| Template { segments })
            .parse_next(input)
    }

    fn segment(input: &mut &str) -> ModalResult<Segment> {
        alt((
            escape_sequence,
            interpolation,
            literal_text,
        )).parse_next(input)
    }
    ```

    **CRITICAL parsing order (from RESEARCH.md pitfalls):**
    1. Parse escape sequences FIRST in alt() before other forms
    2. Parse transforms with optional context BEFORE reference+selectors
    3. Escape sequences: `{{` -> `{`, `}}` -> `}`, `@@` -> `@`, `::` -> `:`

    **Escape sequence handling:**
    - `{{` produces literal `{`
    - `}}` produces literal `}`
    - `@@` produces literal `@`
    - `::` produces literal `:`

    **Automatic capitalization:**
    - If reference name starts with uppercase letter, wrap in @cap transform
    - `{Card}` is equivalent to `{@cap card}`
    - Convert first letter to lowercase for the actual reference

    **Interpolation structure:**
    ```
    { transforms* reference selectors* }
    ```

    **Transform parsing:**
    - `@name` - simple transform
    - `@name:context` - transform with context (context is a Selector)
    - Multiple transforms are space-separated and applied right-to-left

    **Reference parsing:**
    - Simple identifier: could be parameter or phrase (resolved later)
    - With parens: `name(args)` is a phrase call
    - Arguments are comma-separated References

    **Selector parsing:**
    - `:identifier` - literal selector
    - Multi-dimensional: `:acc:n` -> two selectors
  </action>
  <verify>
    Create a simple test in the template.rs file or a test module:
    ```rust
    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn test_literal() {
            let t = parse_template("Hello, world!").unwrap();
            assert_eq!(t.segments.len(), 1);
        }

        #[test]
        fn test_simple_interpolation() {
            let t = parse_template("Hello, {name}!").unwrap();
            assert_eq!(t.segments.len(), 3); // "Hello, " + interpolation + "!"
        }

        #[test]
        fn test_escape_braces() {
            let t = parse_template("Use {{name}} syntax").unwrap();
            // Should produce literal "{name}"
        }
    }
    ```
  </verify>
  <done>
    Template parser handles all LANG-01 through LANG-12 requirements.
    Escape sequences work correctly.
    Transforms with context parse correctly.
    Automatic capitalization works.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive template parser tests</name>
  <files>
    crates/rlf/tests/template_parser.rs
  </files>
  <action>
    Create integration tests for the template parser covering all syntax forms from DESIGN.md.

    **Test file structure:**
    ```rust
    //! Integration tests for template parsing

    use rlf::parser::{parse_template, Template, Segment, Reference, Selector, Transform};

    #[test]
    fn test_pure_literal() {
        let t = parse_template("Hello, world!").unwrap();
        assert_eq!(t.segments, vec![Segment::Literal("Hello, world!".into())]);
    }

    #[test]
    fn test_simple_parameter() {
        let t = parse_template("Hello, {name}!").unwrap();
        assert_eq!(t.segments.len(), 3);
        match &t.segments[1] {
            Segment::Interpolation { transforms, reference, selectors } => {
                assert!(transforms.is_empty());
                assert_eq!(*reference, Reference::Parameter("name".into()));
                assert!(selectors.is_empty());
            }
            _ => panic!("expected interpolation"),
        }
    }

    #[test]
    fn test_selection_literal() {
        // {card:other}
        let t = parse_template("{card:other}").unwrap();
        match &t.segments[0] {
            Segment::Interpolation { selectors, .. } => {
                assert_eq!(selectors, &[Selector::Literal("other".into())]);
            }
            _ => panic!("expected interpolation"),
        }
    }

    #[test]
    fn test_selection_parameter() {
        // {card:n} where n is a parameter
        let t = parse_template("{card:n}").unwrap();
        // Note: at parse time we don't know if 'n' is a parameter or literal
        // The parser produces Selector::Literal, resolution happens later
    }

    #[test]
    fn test_chained_selection() {
        // {card:acc:n}
        let t = parse_template("{card:acc:n}").unwrap();
        match &t.segments[0] {
            Segment::Interpolation { selectors, .. } => {
                assert_eq!(selectors.len(), 2);
            }
            _ => panic!("expected interpolation"),
        }
    }

    #[test]
    fn test_transform_simple() {
        // {@cap name}
        let t = parse_template("{@cap name}").unwrap();
        match &t.segments[0] {
            Segment::Interpolation { transforms, .. } => {
                assert_eq!(transforms.len(), 1);
                assert_eq!(transforms[0].name, "cap");
                assert!(transforms[0].context.is_none());
            }
            _ => panic!("expected interpolation"),
        }
    }

    #[test]
    fn test_transform_with_context() {
        // {@der:acc karte}
        let t = parse_template("{@der:acc karte}").unwrap();
        match &t.segments[0] {
            Segment::Interpolation { transforms, .. } => {
                assert_eq!(transforms[0].name, "der");
                assert_eq!(transforms[0].context, Some(Selector::Literal("acc".into())));
            }
            _ => panic!("expected interpolation"),
        }
    }

    #[test]
    fn test_chained_transforms() {
        // {@cap @a card}
        let t = parse_template("{@cap @a card}").unwrap();
        match &t.segments[0] {
            Segment::Interpolation { transforms, .. } => {
                assert_eq!(transforms.len(), 2);
                assert_eq!(transforms[0].name, "cap");
                assert_eq!(transforms[1].name, "a");
            }
            _ => panic!("expected interpolation"),
        }
    }

    #[test]
    fn test_phrase_call() {
        // {subtype(s)}
        let t = parse_template("{subtype(s)}").unwrap();
        match &t.segments[0] {
            Segment::Interpolation { reference, .. } => {
                match reference {
                    Reference::PhraseCall { name, args } => {
                        assert_eq!(name, "subtype");
                        assert_eq!(args.len(), 1);
                    }
                    _ => panic!("expected phrase call"),
                }
            }
            _ => panic!("expected interpolation"),
        }
    }

    #[test]
    fn test_escape_braces() {
        // "Use {{name}} syntax" -> "Use {name} syntax"
        let t = parse_template("Use {{name}} syntax").unwrap();
        assert_eq!(t.segments, vec![Segment::Literal("Use {name} syntax".into())]);
    }

    #[test]
    fn test_escape_at() {
        // "Use @@ for transforms" -> "Use @ for transforms"
        let t = parse_template("Use @@ for transforms").unwrap();
        assert_eq!(t.segments, vec![Segment::Literal("Use @ for transforms".into())]);
    }

    #[test]
    fn test_escape_colon() {
        // "ratio 1::2" -> "ratio 1:2"
        let t = parse_template("ratio 1::2").unwrap();
        assert_eq!(t.segments, vec![Segment::Literal("ratio 1:2".into())]);
    }

    #[test]
    fn test_auto_capitalization() {
        // {Card} -> @cap card
        let t = parse_template("{Card}").unwrap();
        match &t.segments[0] {
            Segment::Interpolation { transforms, reference, .. } => {
                assert_eq!(transforms.len(), 1);
                assert_eq!(transforms[0].name, "cap");
                // Reference should be lowercase
                match reference {
                    Reference::Parameter(name) | Reference::Phrase(name) => {
                        assert_eq!(name, "card");
                    }
                    _ => panic!("expected simple reference"),
                }
            }
            _ => panic!("expected interpolation"),
        }
    }

    #[test]
    fn test_complex_template() {
        // "Draw {n} {@cap card:n}."
        let t = parse_template("Draw {n} {@cap card:n}.").unwrap();
        assert_eq!(t.segments.len(), 4); // "Draw " + {n} + " " + {@cap card:n} + "."
    }
    ```

    Run tests with: `cargo test --workspace`
  </action>
  <verify>
    `cargo test --workspace` - all template parser tests pass
  </verify>
  <done>
    Comprehensive tests exist for all template syntax forms.
    All tests pass.
  </done>
</task>

</tasks>

<verification>
Run the following checks:

1. `cargo check --workspace` - compiles without errors
2. `cargo test --workspace` - all tests pass
3. Verify parser handles these examples correctly:
   - `"Hello, world!"` -> single Literal segment
   - `"Hello, {name}!"` -> Literal + Interpolation + Literal
   - `"{@cap @a card:n}"` -> Interpolation with 2 transforms and 1 selector
   - `"Use {{braces}}"` -> Literal containing "{braces}"
</verification>

<success_criteria>
- [ ] winnow dependency added
- [ ] Parser module exists with public AST types
- [ ] parse_template() function works
- [ ] All escape sequences handled ({{ }} @@ ::)
- [ ] Transforms with optional context parse correctly
- [ ] Selections (single and chained) parse correctly
- [ ] Phrase calls with arguments parse correctly
- [ ] Automatic capitalization works ({Card} -> @cap card)
- [ ] Integration tests cover all syntax forms
- [ ] All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-types-and-parser/01-02-SUMMARY.md`
</output>
