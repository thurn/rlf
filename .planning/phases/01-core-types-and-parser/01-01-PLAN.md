---
phase: 01-core-types-and-parser
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/rlf/Cargo.toml
  - crates/rlf/src/lib.rs
  - crates/rlf/src/types/mod.rs
  - crates/rlf/src/types/phrase.rs
  - crates/rlf/src/types/value.rs
  - crates/rlf/src/types/phrase_id.rs
  - crates/rlf/src/types/variant_key.rs
  - crates/rlf/src/types/tag.rs
autonomous: true

must_haves:
  truths:
    - "Phrase struct can be constructed with text, variants HashMap, and tags Vec"
    - "PhraseId can be constructed at const time from phrase name"
    - "PhraseId can be used as HashMap key"
    - "Value enum can hold Number, Float, String, Phrase variants"
    - "Common Rust types convert into Value via Into trait"
  artifacts:
    - path: "crates/rlf/src/types/phrase.rs"
      provides: "Phrase struct with builder"
      exports: ["Phrase"]
      contains: "pub struct Phrase"
    - path: "crates/rlf/src/types/value.rs"
      provides: "Value enum with Into impls"
      exports: ["Value"]
      contains: "pub enum Value"
    - path: "crates/rlf/src/types/phrase_id.rs"
      provides: "PhraseId hash wrapper"
      exports: ["PhraseId"]
      contains: "const fn from_name"
    - path: "crates/rlf/src/types/variant_key.rs"
      provides: "VariantKey newtype"
      exports: ["VariantKey"]
    - path: "crates/rlf/src/types/tag.rs"
      provides: "Tag newtype"
      exports: ["Tag"]
  key_links:
    - from: "crates/rlf/src/lib.rs"
      to: "crates/rlf/src/types/mod.rs"
      via: "pub mod types"
      pattern: "pub mod types"
    - from: "crates/rlf/src/types/phrase.rs"
      to: "crates/rlf/src/types/variant_key.rs"
      via: "HashMap<VariantKey, String>"
      pattern: "HashMap<VariantKey"
---

<objective>
Create the foundational Rust types for RLF: Phrase, Value, PhraseId, VariantKey, and Tag.

Purpose: These types are the building blocks that all other phases depend on. The parser produces ASTs containing these types, and the interpreter consumes them.

Output: A working `rlf` crate with core types that compile and pass basic tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-types-and-parser/01-CONTEXT.md
@.planning/phases/01-core-types-and-parser/01-RESEARCH.md
@docs/DESIGN.md
@docs/APPENDIX_RUST_INTEGRATION.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create workspace and crate structure</name>
  <files>
    Cargo.toml
    crates/rlf/Cargo.toml
    crates/rlf/src/lib.rs
    crates/rlf/src/types/mod.rs
    justfile
  </files>
  <action>
    Create the Rust workspace structure per PROJECT.md constraints:

    1. Root Cargo.toml as workspace:
       ```toml
       [workspace]
       resolver = "2"
       members = ["crates/*"]
       ```

    2. crates/rlf/Cargo.toml:
       - name = "rlf"
       - edition = "2024"
       - Dependencies: bon = "3.8", thiserror = "2.0", serde = { version = "1.0", features = ["derive"] }, const-fnv1a-hash = "1.1"
       - Dev-dependencies: insta (for snapshot tests later)

    3. crates/rlf/src/lib.rs:
       - pub mod types;
       - Re-export public types: pub use types::{Phrase, Value, PhraseId, VariantKey, Tag};

    4. crates/rlf/src/types/mod.rs:
       - mod phrase; mod value; mod phrase_id; mod variant_key; mod tag;
       - pub use phrase::Phrase; etc.

    5. justfile with basic commands:
       - `check`: cargo check --workspace
       - `test`: cargo test --workspace
       - `build`: cargo build --workspace

    Do NOT add winnow yet (that's for Plan 02).
  </action>
  <verify>
    Run `cargo check --workspace` - should compile with no errors (empty modules are fine)
  </verify>
  <done>
    Workspace compiles, crate structure exists, justfile has basic commands
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement VariantKey and Tag newtypes</name>
  <files>
    crates/rlf/src/types/variant_key.rs
    crates/rlf/src/types/tag.rs
  </files>
  <action>
    Implement the newtype wrappers per RESEARCH.md patterns:

    **VariantKey** (crates/rlf/src/types/variant_key.rs):
    ```rust
    use serde::{Serialize, Deserialize};

    #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub struct VariantKey(String);

    impl VariantKey {
        pub fn new(s: impl Into<String>) -> Self {
            Self(s.into())
        }

        pub fn as_str(&self) -> &str {
            &self.0
        }
    }

    impl std::ops::Deref for VariantKey {
        type Target = str;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    impl From<&str> for VariantKey {
        fn from(s: &str) -> Self {
            Self(s.to_string())
        }
    }

    impl From<String> for VariantKey {
        fn from(s: String) -> Self {
            Self(s)
        }
    }

    impl std::fmt::Display for VariantKey {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{}", self.0)
        }
    }
    ```

    **Tag** (crates/rlf/src/types/tag.rs):
    Same pattern as VariantKey - newtype wrapping String with Deref, From impls, Display, serde derives.

    Both types must be: Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize
  </action>
  <verify>
    `cargo check --workspace` passes, types are usable in HashMap keys
  </verify>
  <done>
    VariantKey and Tag newtypes exist with proper trait implementations
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement Phrase, Value, and PhraseId types</name>
  <files>
    crates/rlf/src/types/phrase.rs
    crates/rlf/src/types/value.rs
    crates/rlf/src/types/phrase_id.rs
    crates/rlf/src/types/mod.rs
  </files>
  <action>
    Implement the three main types per DESIGN.md and RESEARCH.md:

    **Phrase** (crates/rlf/src/types/phrase.rs):
    ```rust
    use bon::Builder;
    use std::collections::HashMap;
    use super::{VariantKey, Tag};

    #[derive(Debug, Clone, Builder)]
    pub struct Phrase {
        /// Default text when displayed
        pub text: String,
        /// Variant key -> variant text
        #[builder(default)]
        pub variants: HashMap<VariantKey, String>,
        /// Metadata tags
        #[builder(default)]
        pub tags: Vec<Tag>,
    }

    impl Phrase {
        /// Get a specific variant by key, with fallback resolution.
        /// Tries exact match first, then progressively shorter keys.
        /// Panics if no match found.
        pub fn variant(&self, key: &str) -> &str {
            // Try exact match
            if let Some(v) = self.variants.get(&VariantKey::new(key)) {
                return v;
            }
            // Try progressively shorter keys (fallback resolution)
            let mut current = key;
            while let Some(dot_pos) = current.rfind('.') {
                current = &current[..dot_pos];
                if let Some(v) = self.variants.get(&VariantKey::new(current)) {
                    return v;
                }
            }
            // No match - panic with helpful error
            panic!(
                "No variant '{}' in phrase. Available: {:?}",
                key,
                self.variants.keys().collect::<Vec<_>>()
            );
        }
    }

    impl std::fmt::Display for Phrase {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{}", self.text)
        }
    }
    ```

    **Value** (crates/rlf/src/types/value.rs):
    ```rust
    use super::Phrase;

    #[derive(Debug, Clone)]
    pub enum Value {
        Number(i64),
        Float(f64),
        String(String),
        Phrase(Phrase),
    }

    // Implement From for common types
    impl From<i32> for Value {
        fn from(n: i32) -> Self { Value::Number(n as i64) }
    }
    impl From<i64> for Value {
        fn from(n: i64) -> Self { Value::Number(n) }
    }
    impl From<f64> for Value {
        fn from(n: f64) -> Self { Value::Float(n) }
    }
    impl From<String> for Value {
        fn from(s: String) -> Self { Value::String(s) }
    }
    impl From<&str> for Value {
        fn from(s: &str) -> Self { Value::String(s.to_string()) }
    }
    impl From<Phrase> for Value {
        fn from(p: Phrase) -> Self { Value::Phrase(p) }
    }
    ```

    **PhraseId** (crates/rlf/src/types/phrase_id.rs):
    ```rust
    use const_fnv1a_hash::fnv1a_hash_str_64;
    use serde::{Serialize, Deserialize};

    #[derive(Copy, Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
    pub struct PhraseId(u64);

    impl PhraseId {
        /// Create a PhraseId from a phrase name at compile time.
        pub const fn from_name(name: &str) -> Self {
            Self(fnv1a_hash_str_64(name, None))
        }

        /// Get the raw hash value.
        pub fn as_u64(&self) -> u64 {
            self.0
        }
    }

    // Note: resolve() and call() methods require Locale (Phase 4)
    // Note: name() method requires registry (Phase 2)
    ```

    Update mod.rs to properly export all types.
  </action>
  <verify>
    Run `cargo check --workspace` - all types compile.
    Run `cargo test --workspace` - any existing tests pass.
    Verify PhraseId::from_name can be used in const context:
    ```rust
    const TEST_ID: PhraseId = PhraseId::from_name("test");
    ```
  </verify>
  <done>
    All five core types (Phrase, Value, PhraseId, VariantKey, Tag) exist and compile.
    PhraseId::from_name is const fn.
    Phrase::variant() implements fallback resolution.
    Value has Into impls for i32, i64, f64, String, &str, Phrase.
  </done>
</task>

</tasks>

<verification>
Run the following checks:

1. `cargo check --workspace` - compiles without errors
2. `cargo build --workspace` - builds successfully
3. Verify const fn works:
   ```rust
   // In any test or example
   const CARD_ID: PhraseId = PhraseId::from_name("card");
   ```
4. Verify types are exported from crate root:
   ```rust
   use rlf::{Phrase, Value, PhraseId, VariantKey, Tag};
   ```
</verification>

<success_criteria>
- [ ] Workspace structure exists (root Cargo.toml, crates/rlf/)
- [ ] All five types compile: Phrase, Value, PhraseId, VariantKey, Tag
- [ ] Phrase has builder pattern via bon
- [ ] Phrase::variant() implements fallback resolution per DESIGN.md
- [ ] PhraseId::from_name() is const fn (verifiable with const declaration)
- [ ] PhraseId has Copy, Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize
- [ ] Value has Into impls for i32, i64, f64, String, &str, Phrase
- [ ] VariantKey and Tag are newtypes with proper traits
- [ ] justfile exists with check/test/build commands
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-types-and-parser/01-01-SUMMARY.md`
</output>
