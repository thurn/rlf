# Appendix: RLF Runtime Interpreter

This appendix describes the design of the runtime interpreter for RLF, which
evaluates translation files and data-driven templates at runtime.

## Motivation

The RLF architecture uses a unified interpreter for all languages:

1. **Source language**: The `rlf!` macro validates syntax at compile time and
   embeds the source phrases as data. At startup, these are loaded into the
   interpreter.

2. **Translations**: Translation files (`.rlf`) are loaded into the interpreter
   at runtime.

All evaluation goes through the interpreter. This design achieves:

- **Simplicity**: One code path for all languages
- **Immediate IDE support**: Add phrase, use it with autocomplete
- **Flexible workflows**: Edit translations, reload without recompiling
- **Consistent behavior**: Source and translations work identically

The interpreter also supports:

- **Data-driven content**: Evaluate templates from TOML, JSON, or other data files
- **User-generated content**: Load card text from external sources
- **Development workflow**: Test templates without recompiling
- **Hot reloading**: Update translations without restarting

---

## Architecture Overview

The interpreter consists of four core components:

**Parser** converts template strings and `.rlf` files into an abstract syntax
tree (AST). It handles the full RLF grammar including literals, interpolations,
transforms, selections, and escape sequences.

**Evaluator** traverses the AST and produces output strings. It resolves
references, applies selections, executes transforms, and handles errors.

**PhraseRegistry** stores phrases loaded from `.rlf` files. Each language has
its own registry. The interpreter looks up phrases by name when evaluating
templates.

**TransformRegistry** maps transform names to implementations. Universal
transforms (`@cap`, `@upper`, `@lower`) are always available. Language-specific
transforms are registered per language.

---

## Integration with Generated Code

### Generated Function Structure

Each function generated by `rlf!` delegates to the interpreter:

```rust
pub fn draw(locale: &Locale, n: impl Into<Value>) -> Phrase {
    locale.interpreter()
        .call_phrase(locale.language(), "draw", &[n.into()])
        .expect("phrase 'draw' should exist")
}
```

The macro also generates a registration function and embedded source data:

```rust
const SOURCE_PHRASES: &str = r#"
    card = { one: "card", other: "cards" };
    draw(n) = "Draw {n} {card:n}.";
"#;

pub fn register_source_phrases(interpreter: &mut RlfInterpreter) {
    interpreter.load_phrases("en", SOURCE_PHRASES)
        .expect("source phrases should parse successfully");
}
```

### Phrase Lookup Flow

When evaluating a phrase:

1. `strings::draw(&locale, 3)` is called
2. `locale.interpreter().call_phrase("ru", "draw", &[3])` is called
3. Interpreter looks up "draw" in the current language's phrase registry
4. If found, interpreter evaluates the template
5. If not found, interpreter returns `PhraseNotFound` error

### Initialization

At application startup, register source phrases:

```rust
fn setup_localization() -> Locale {
    let mut locale = Locale::new();

    // Register source language (from macro-embedded data)
    strings::register_source_phrases(locale.interpreter_mut());

    // Load translation files
    locale.load_translations("ru", "assets/localization/ru.rlf")?;
    locale.load_translations("es", "assets/localization/es.rlf")?;

    locale
}
```

---

## Parser

The parser converts template strings and `.rlf` files into an AST.

### Grammar

The grammar handles:

- **Literals**: Any text not containing special characters
- **Escape sequences**: `{{`, `}}`, `@@`, `::` for literal braces, at-signs, colons
- **Interpolations**: `{...}` blocks containing transforms, references, selectors
- **Comments**: `//` to end of line (in `.rlf` files)
- **Phrase definitions**: `name = "template";` or `name(params) = "template";`

Within interpolations:
- **Transforms**: Zero or more `@name` or `@name:context` prefixes
- **References**: Parameter names, phrase names, or phrase calls with arguments
- **Selectors**: Zero or more `:key` suffixes for variant selection

### AST Structure

```rust
struct Template {
    segments: Vec<Segment>,
}

enum Segment {
    Literal(String),
    Interpolation {
        transforms: Vec<Transform>,
        reference: Reference,
        selectors: Vec<Selector>,
    },
}

struct Transform {
    name: String,
    context: Option<Selector>,
}

enum Reference {
    Parameter(String),
    Phrase(String),
    PhraseCall { name: String, args: Vec<Reference> },
}

enum Selector {
    Literal(String),
    Parameter(String),
}
```

### File Format

`.rlf` files use a simple text format:

```
// Comment
name = "simple phrase";
name = :tag "tagged phrase";
name = :tag1 :tag2 { key1: "variant1", key2: "variant2" };
name(param1, param2) = "template with {param1} and {param2}";
name(p) = :from(p) "wrapper around {p}";
```

---

## Evaluator

The evaluator traverses the AST and produces output strings.

### Evaluation Context

Evaluation requires:

- **Phrase registry**: For resolving phrase references
- **Transform registry**: For executing transforms
- **Parameters**: A map from parameter names to `Value`s
- **Language code**: For CLDR plural rules and language-specific transforms
- **Phrase stack**: For cycle detection
- **Max depth**: Configurable recursion limit (default 64)

### Evaluation Algorithm

Template evaluation processes segments sequentially:

1. **Literals**: Copy directly to output
2. **Interpolations**: Resolve reference, apply selectors, apply transforms

For interpolations:

1. **Resolve reference**: Parameters return their value. Phrase references look
   up in the registry and either return the `Phrase` value (parameterless) or
   evaluate with provided arguments.

2. **Apply selectors**: Each selector extracts a variant from the current value.
   For numeric selectors, compute CLDR plural category. For phrase selectors,
   read the phrase's first tag. Literal selectors use the key directly.

3. **Apply transforms**: Transforms execute right-to-left (innermost first).
   Each transform receives the current value and optional context.

### Selector Resolution

Variant selection follows fallback logic:

1. Try exact key match (e.g., "nom.many")
2. Try progressively shorter keys by removing the last dot-segment (e.g., "nom")
3. If no match found, return `MissingVariant` error

For parameter-based selectors:

- **Numbers**: Map to CLDR plural category via `icu_plurals`
- **Phrases**: Use the phrase's first metadata tag
- **Strings**: Parse as number if possible, otherwise use literally

### Cycle Detection

Before resolving a phrase, the evaluator checks if the phrase name exists in the
current stack. If found, it returns a `CyclicReference` error.

### Metadata Inheritance (`:from`)

When a phrase has `:from(param)`, evaluation produces a `Phrase` instead of a
simple string:

1. **Read source metadata**: Get tags and variants from the parameter phrase
2. **Evaluate per variant**: Run the template once for each variant of the source
3. **Inherit tags**: Copy tags from the source phrase to the result
4. **Return Phrase**: The result is a `Phrase` with computed variants and inherited tags

This enables phrase composition where transforms like `@a` can read inherited
tags and selectors like `:other` can access inherited variants.

---

## Transforms

All transforms are built into RLF and available automatically. Users do not need
to register or configure transforms—they are ready to use as soon as RLF is
initialized.

### Universal Transforms

These transforms are available in all languages:

| Transform | Effect |
|-----------|--------|
| `@cap` | Capitalize first letter |
| `@upper` | All uppercase |
| `@lower` | All lowercase |

### Language-Specific Transforms

Each supported language has its own set of transforms. These are automatically
available when using that language—no registration required.

For example, English has `@a`/`@an` for indefinite articles, Spanish has
`@el`/`@un` for articles, German has `@der`/`@ein` for case-inflected articles,
etc.

See **APPENDIX_STDLIB.md** for the complete list of transforms per language

---

## Loading Translation Files

### API

```rust
impl Locale {
    /// Load translations from a file path.
    pub fn load_translations(
        &mut self,
        language: &str,
        path: impl AsRef<Path>,
    ) -> Result<(), LoadError>;

    /// Load translations from a string.
    pub fn load_translations_str(
        &mut self,
        language: &str,
        content: &str,
    ) -> Result<(), LoadError>;
}
```

### Loading Process

1. Parse the `.rlf` file into phrase definitions
2. For each phrase, create an entry in the language's phrase registry
3. Register language-specific transforms based on the language code

### Hot Reloading

In development mode, translations can be reloaded:

```rust
impl Locale {
    /// Reload translations for a language.
    pub fn reload_translations(&mut self, language: &str) -> Result<(), LoadError>;
}
```

This clears the existing phrases for that language and reloads from the original
source.

---

## Public API

### RlfInterpreter

```rust
impl RlfInterpreter {
    /// Create with default configuration.
    pub fn new() -> Self;

    /// Parse and evaluate a template string.
    pub fn eval_str(
        &self,
        template: &str,
        language: &str,
        params: HashMap<String, Value>,
    ) -> Result<Phrase, EvalError>;

    /// Call a phrase by name with arguments.
    pub fn call_phrase(
        &self,
        language: &str,
        name: &str,
        args: &[Value],
    ) -> Result<Phrase, EvalError>;

    /// Get a phrase as a Phrase value (parameterless phrases only).
    pub fn get_phrase(
        &self,
        language: &str,
        name: &str,
    ) -> Result<Phrase, EvalError>;

    /// Call a phrase by PhraseId with arguments.
    pub fn call_phrase_by_id(
        &self,
        id: u64,
        language: &str,
        args: &[Value],
    ) -> Result<Phrase, EvalError>;

    /// Get a phrase by PhraseId (parameterless phrases only).
    pub fn get_phrase_by_id(
        &self,
        id: u64,
        language: &str,
    ) -> Result<Phrase, EvalError>;

    /// Load phrases from a string.
    pub fn load_phrases(
        &mut self,
        language: &str,
        content: &str,
    ) -> Result<usize, LoadError>;
}
```

**Note:** All evaluation methods return `Phrase`. For phrases without `:from` or
declared variants/tags, the `Phrase` has empty variants and tags, behaving like
a string when displayed.

### EvalError

```rust
pub enum EvalError {
    /// Phrase not found in current language.
    PhraseNotFound { name: String },
    /// Variant key not found in phrase's variant table.
    MissingVariant { phrase: String, key: String, available: Vec<String> },
    /// Transform requires a tag that the phrase doesn't have.
    MissingTag { transform: String, expected: Vec<String>, phrase: String },
    /// Wrong number of arguments passed to phrase.
    ArgumentCount { phrase: String, expected: usize, got: usize },
    /// Cyclic reference detected during evaluation.
    CyclicReference { chain: Vec<String> },
}
```

### Value Type

```rust
pub enum Value {
    Number(i64),
    Float(f64),
    String(String),
    Phrase(Phrase),
}
```

Values convert automatically via `Into<Value>` for common types.

---

## Error Handling

### Error Behavior

RLF uses a two-layer error model:

**Interpreter layer** — All interpreter methods return `Result`:

- **Load errors** (`LoadError`): Parse failures when loading `.rlf` files,
  including line number and position
- **Evaluation errors** (`EvalError`): Runtime failures during template
  evaluation:
  - `PhraseNotFound`: Phrase missing from current language
  - `MissingVariant`: Selector key doesn't match any variant
  - `MissingTag`: Transform requires a tag the phrase doesn't have
  - `ArgumentCount`: Wrong number of arguments passed to phrase
  - `CyclicReference`: Phrase references itself (directly or indirectly)

**Generated function layer** — Functions generated by `rlf!` panic on errors:

```rust
pub fn draw(locale: &Locale, n: impl Into<Value>) -> Phrase {
    locale.interpreter()
        .call_phrase(locale.language(), "draw", &[n.into()])
        .expect("phrase 'draw' should exist")
}
```

**When to use which:**

| Use Case | API | Error Handling |
|----------|-----|----------------|
| Static UI strings | `strings::phrase_name(&locale, ...)` | Panic (programming error) |
| Data-driven templates | `interpreter.eval_str(...)` | `Result` (handle gracefully) |
| Dynamic phrase lookup | `interpreter.get_phrase(...)` | `Result` (handle gracefully) |

Use the interpreter API directly for templates from TOML, JSON, or user-provided
data. This lets you catch and handle errors rather than panicking.

### No Language Fallback

RLF does **not** fall back to another language when a phrase is missing. If you
request `draw` in Russian and it doesn't exist, you get `PhraseNotFound`—not the
English version.

This is intentional: translations must be complete. Missing phrases are errors
that should be caught during development or by CI tooling, not silently papered
over with fallback behavior.

### Error Messages

Error messages aim to be actionable:

- **Location**: Line/column in file, or position in template
- **Context**: What was being parsed/evaluated
- **Suggestions**: For unknown names, suggest similar alternatives
- **Hints**: For missing tags, show example of correct definition

---

## Performance

### Unified Interpreter

All languages use the interpreter:

| Aspect | All Languages |
|--------|---------------|
| Overhead | Per-call evaluation |
| Allocation | String per result |
| Startup | Parse source + load files |
| Hot reload | File reload (translations only) |

This simplicity is acceptable because localized text is rarely on the critical
performance path. Hot paths can cache results if needed.

### Caching

**Template caching**: Parsed ASTs are cached. Source phrases are parsed once at
startup. Translation files are parsed once when loaded.

**Plural rules**: CLDR plural rules are computed once per language using
`icu_plurals`. The `PluralRules` object is cached.

**Phrase lookup**: HashMap-based O(1) lookup by phrase name.

### Memory

**Loaded phrases**: Each phrase stores its template AST, variant table, and tags.
For typical translation files (hundreds of phrases), this uses a few hundred KB.

**Evaluation**: Temporary allocations during evaluation are minimal. Results are
returned as owned strings.

---

## Command Line Tool

The `rlf` binary provides utilities for working with RLF files:

### rlf check

Validates `.rlf` files for syntax errors:

```bash
rlf check assets/localization/ru.rlf
rlf check --strict assets/localization/*.rlf
```

With `--strict`, also checks for missing phrases compared to source.

### rlf eval

Evaluates a template with given parameters:

```bash
rlf eval --lang ru --param n=3 --template "Возьмите {n} {card:n}."
rlf eval --lang en --phrases strings.rlf.rs --template "{draw(3)}"
```

### rlf coverage

Shows translation coverage:

```bash
rlf coverage --source strings.rlf.rs --lang ru,es,zh_cn

Language  Phrases  Translated  Missing
ru        150      145         5
es        150      150         0
zh_cn     150      120         30
```

---

## Summary

The runtime interpreter evaluates all RLF phrases, including the source language:

| Component | Source Language | Translations |
|-----------|-----------------|--------------|
| Definition | `rlf!` macro | `.rlf` files |
| Evaluation | Interpreter | Interpreter |
| Validation | Compile-time | Load-time |
| Hot reload | Restart required | File reload |

### Key Design Decisions

| Decision | Rationale |
|----------|-----------|
| Unified interpreter | One code path, simpler to understand and debug |
| Embedded source data | No duplication, macro extracts from `rlf!` block |
| Missing phrases error | Translations must be complete; missing phrases are programming errors |
| Consistent behavior | Source and translations work identically |

The interpreter enables a practical development workflow: write phrases in
`strings.rlf.rs` for immediate IDE support and compile-time validation, add
translations later in `.rlf` files that can be edited and reloaded without
recompilation.
